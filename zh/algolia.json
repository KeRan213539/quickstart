[{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Install Admin Console","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/admin-console/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f48f0cb8fe59983b07673f0fee44fe94","permalink":"/docs/v2.7/admin/install/admin-console/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/admin-console/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Why use dubbo","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Background","lvl1":"docs","lvl2":"/docs/v2.7/user/preface/background/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4119c14632ed40134afb7bd0ae619802","permalink":"/docs/v2.7/user/preface/background/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/preface/background/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Build dubbo from source code","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Source Code Build","lvl1":"docs","lvl2":"/docs/v2.7/dev/build/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1d019c7b9259a751ab469ea16cda57c8","permalink":"/docs/v2.7/dev/build/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/build/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Apache Committer Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/new-committer-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c1f4b41e085f4dadb02215fea3b4d2f4","permalink":"/docs/contribution-guidelines/committer/new-committer-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/new-committer-guide_dev/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Guidelines for dubbo contributor","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Contributor Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8322ad9625f5b143d03a17e2ffb2b1d7","permalink":"/docs/contribution-guidelines/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Dubbo Contributor 指南","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Contributor 指南","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8322ad9625f5b143d03a17e2ffb2b1d7","permalink":"/zh/docs/contribution-guidelines/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/contribution-guidelines/contributor/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The Devil Is In The Details","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/code-detail/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"54c57c2435d742959cefeb668147b267","permalink":"/docs/v2.7/dev/principals/code-detail/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/code-detail/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Guide for dubbo-admin","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Admin Guide","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"877294f5f814ad55e965193def47a924","permalink":"/docs/v2.7/admin/ops/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"如何安装、使用、运维 Dubbo Admin 控制台","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo Admin 运维指南","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/","lvl3":4,"lvl4":"docs","lvl5":null,"objectID":"877294f5f814ad55e965193def47a924","permalink":"/zh/docs/v2.7/admin/ops/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/","summary":"这篇文档详细讲述了 Dubbo Admin 的结构、部署方式和功能介绍","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"本文介绍了 Dubbo SPI 的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":1300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo SPI","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/dubbo-spi/","lvl3":1222,"lvl4":"docs","lvl5":null,"objectID":"48904427c039cc5a66b7e810c6c3cce7","permalink":"/zh/docs/v2.7/dev/source/dubbo-spi/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/docs/v2.7/dev/source/dubbo-spi/","summary":"1.简介 SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。\n需要特别说明的是，本篇文章以及本系列其他文章所分析的源码版本均为 dubbo-2.6.4。因此大家在阅读文章的过程中，需注意将代码版本切换到 dubbo-2.6.4 tag 上。\n2.SPI 示例 2.1 Java SPI 示例 前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。\npublic interface Robot { void sayHello(); } 接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。\npublic class OptimusPrime implements Robot { @Override public void sayHello() { System.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"References documentation for dubbo protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/dubbo/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"2dee61ea6a25cfb027147957aaa8063c","permalink":"/docs/v2.7/user/references/protocol/dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/dubbo/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/dubbo/","lvl3":220,"lvl4":"docs","lvl5":null,"objectID":"2dee61ea6a25cfb027147957aaa8063c","permalink":"/zh/docs/v2.7/user/references/protocol/dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/protocol/dubbo/","summary":"Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。\n反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。\n Transporter: mina, netty, grizzy Serialization: dubbo, hessian2, java, json Dispatcher: all, direct, message, execution, connection ThreadPool: fixed, cached  特性 缺省协议，使用基于 mina 1.1.7 和 hessian 3.2.1 的 tbremoting 交互。\n 连接个数：单连接 连接方式：长连接 传输协议：TCP 传输方式：NIO 异步传输 序列化：Hessian 二进制序列化 适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。 适用场景：常规远程服务方法调用  约束  参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。 Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 12：     数据通讯 情况 结果     A-\u0026gt;B 类A多一种 属性（或者说类B少一种 属性） 不抛异常，A多的那 个属性的值，B没有， 其他正常   A-\u0026gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输 抛异常   A-\u0026gt;B 枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输 不抛异常，B正常接 收数据   A-\u0026gt;B A和B的属性 名相同，但类型不相同 抛异常   A-\u0026gt;B serialId 不相同 正常传输    接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:application element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:application","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-application/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4100d61e5f7c36f73c9f7795936d071f","permalink":"/docs/v2.7/user/references/xml/dubbo-application/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-application/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:application 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:application","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-application/","lvl3":67,"lvl4":"docs","lvl5":null,"objectID":"4100d61e5f7c36f73c9f7795936d071f","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-application/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-application/","summary":"应用信息配置。对应的配置类：org.apache.dubbo.config.ApplicationConfig\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     name application string 必填  服务治理 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关，比如：kylin应用调用了morgan应用的服务，则kylin项目配成kylin，morgan项目配成morgan，可能kylin也提供其它服务给别人使用，但kylin项目永远配成kylin，这样注册中心将显示kylin依赖于morgan 1.0.16以上版本   version application.version string 可选  服务治理 当前应用的版本 2.2.0以上版本   owner owner string 可选  服务治理 应用负责人，用于服务治理，请填写负责人公司邮箱前缀 2.0.5以上版本   organization organization string 可选  服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.0.0以上版本   architecture  architecture  string 可选  服务治理 用于服务分层对应的架构。如，intl、china。不同的架构使用不同的分层。 2.0.7以上版本   environment environment string 可选  服务治理 应用环境，如：develop/test/product，不同环境使用不同的缺省值，以及作为只用于开发测试功能的限制条件 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:argument element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:argument","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-argument/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"04d676b3bc46ab11c372bb69d34db4c4","permalink":"/docs/v2.7/user/references/xml/dubbo-argument/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-argument/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:argument 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:argument","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-argument/","lvl3":40,"lvl4":"docs","lvl5":null,"objectID":"04d676b3bc46ab11c372bb69d34db4c4","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-argument/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-argument/","summary":"方法参数配置。对应的配置类： org.apache.dubbo.config.ArgumentConfig。该标签为 \u0026lt;dubbo:method\u0026gt; 的子标签，用于方法参数的特征描述，比如：\n\u0026lt;dubbo:method name=\u0026#34;findXxx\u0026#34; timeout=\u0026#34;3000\u0026#34; retries=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;dubbo:argument index=\u0026#34;0\u0026#34; callback=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/dubbo:method\u0026gt;    属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     index  int 必填  标识 参数索引 2.0.6以上版本   type  String 与index二选一  标识 通过参数类型查找参数的index 2.0.6以上版本   callback \u0026lt;metodName\u0026gt;\u0026lt;index\u0026gt;.retries boolean 可选  服务治理 参数是否为callback接口，如果为callback，服务提供方将生成反向代理，可以从服务提供方反向调用消费方，通常用于事件推送. 2.0.6以上版本    ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:config-center element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:config-center","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-config-center/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"231e28fb8fee54d37d758acea9f1d73f","permalink":"/docs/v2.7/user/references/xml/dubbo-config-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-config-center/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:config-center 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:config-center","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-config-center/","lvl3":120,"lvl4":"docs","lvl5":null,"objectID":"231e28fb8fee54d37d758acea9f1d73f","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-config-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-config-center/","summary":"配置中心。对应的配置类：org.apache.dubbo.config.ConfigCenterConfig\n   属性 对应URL参数 类型 是否必填 缺省值 描述 兼容性     protocol config.protocol string 可选 zookeeper 使用哪个配置中心：apollo、zookeeper、nacos等。\n以zookeeper为例\n1. 指定protocol，则address可以简化为127.0.0.1:2181；\n2. 不指定protocol，则address取值为zookeeper://127.0.0.1:2181 2.7.0+   address config.address string 必填  配置中心地址。\n取值参见protocol说明 2.7.0+   highest-priority config.highestPriority boolean 可选 true 来自配置中心的配置项具有最高优先级，即会覆盖本地配置项。 2.7.0+   namespace config.namespace string 可选 dubbo 通常用于多租户隔离，实际含义视具体配置中心而不同。\n如：\nzookeeper - 环境隔离，默认值dubbo；\napollo - 区分不同领域的配置集合，默认使用dubbo和application 2.7.0+   cluster config.cluster string 可选  含义视所选定的配置中心而不同。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:consumer element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:consumer","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-consumer/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8e663c49666810d8d792a3a48588f246","permalink":"/docs/v2.7/user/references/xml/dubbo-consumer/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-consumer/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:consumer 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:consumer","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-consumer/","lvl3":152,"lvl4":"docs","lvl5":null,"objectID":"8e663c49666810d8d792a3a48588f246","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-consumer/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-consumer/","summary":"服务消费者缺省值配置。配置类： org.apache.dubbo.config.ConsumerConfig 。同时该标签为 \u0026lt;dubbo:reference\u0026gt; 标签的缺省值设置。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     timeout default.timeout int 可选 1000 性能调优 远程服务调用超时时间(毫秒) 1.0.16以上版本   retries default.retries int 可选 2 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0,仅在cluster为failback/failover时有效 1.0.16以上版本   loadbalance default.loadbalance string 可选 random 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 1.0.16以上版本   async default.async boolean 可选 false 性能调优 是否缺省异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 2.0.0以上版本   connections default.connections int 可选 100 性能调优 每个服务对每个提供者的最大连接数，rmi、http、hessian等短连接协议支持此配置，dubbo协议长连接不支持此配置 1.0.16以上版本   generic generic boolean 可选 false 服务治理 是否缺省泛化接口，如果为泛化接口，将返回GenericService 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:method element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:method","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-method/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"67fff0eb94223dc7a154dd486f2ebe34","permalink":"/docs/v2.7/user/references/xml/dubbo-method/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-method/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:method 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:method","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-method/","lvl3":148,"lvl4":"docs","lvl5":null,"objectID":"67fff0eb94223dc7a154dd486f2ebe34","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-method/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-method/","summary":"方法级配置。对应的配置类： org.apache.dubbo.config.MethodConfig。同时该标签为 \u0026lt;dubbo:service\u0026gt; 或 \u0026lt;dubbo:reference\u0026gt; 的子标签，用于控制到方法级。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     name  string 必填  标识 方法名 1.0.8以上版本   timeout \u0026lt;methodName\u0026gt;.timeout int 可选 缺省为的timeout 性能调优 方法调用超时时间(毫秒) 1.0.8以上版本   retries \u0026lt;methodName\u0026gt;.retries int 可选 缺省为\u0026lt;dubbo:reference\u0026gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.0.0以上版本   loadbalance \u0026lt;methodName\u0026gt;.loadbalance string 可选 缺省为的loadbalance 性能调优 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用 2.0.0以上版本   async \u0026lt;methodName\u0026gt;.async boolean 可选 缺省为\u0026lt;dubbo:reference\u0026gt;的async 性能调优 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程 1.0.9以上版本   sent \u0026lt;methodName\u0026gt;.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:module element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:module","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-module/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"999cac8e5703106a8c6fd02c573bfeaf","permalink":"/docs/v2.7/user/references/xml/dubbo-module/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-module/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:module 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:module","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-module/","lvl3":38,"lvl4":"docs","lvl5":null,"objectID":"999cac8e5703106a8c6fd02c573bfeaf","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-module/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-module/","summary":"模块信息配置。对应的配置类 org.apache.dubbo.config.ModuleConfig\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     name module string 必填  服务治理 当前模块名称，用于注册中心计算模块间依赖关系 2.2.0以上版本   version module.version string 可选  服务治理 当前模块的版本 2.2.0以上版本   owner owner string 可选  服务治理 模块负责人，用于服务治理，请填写负责人公司邮箱前缀 2.2.0以上版本   organization organization string 可选  服务治理 组织名称(BU或部门)，用于注册中心区分服务来源，此配置项建议不要使用autoconfig，直接写死在配置中，比如china,intl,itu,crm,asc,dw,aliexpress等 2.2.0以上版本    ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:monitor element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:monitor","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-monitor/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c5d376c321cee9d7aeb45fe26fdcdd14","permalink":"/docs/v2.7/user/references/xml/dubbo-monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-monitor/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:monitor 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:monitor","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-monitor/","lvl3":26,"lvl4":"docs","lvl5":null,"objectID":"c5d376c321cee9d7aeb45fe26fdcdd14","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-monitor/","summary":"监控中心配置。对应的配置类： org.apache.dubbo.config.MonitorConfig\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     protocol protocol string 可选 dubbo 服务治理 监控中心协议，如果为protocol=\u0026ldquo;registry\u0026rdquo;，表示从注册中心发现监控中心地址，否则直连监控中心。 2.0.9以上版本   address \u0026lt;url\u0026gt; string 可选 N/A 服务治理 直连监控中心服务器地址，address=\u0026ldquo;10.20.130.230:12080\u0026rdquo; 1.0.16以上版本    ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:parameter element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:parameter","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-parameter/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c37a7be11745551af028d5166b07be0b","permalink":"/docs/v2.7/user/references/xml/dubbo-parameter/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-parameter/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:parameter 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:parameter","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-parameter/","lvl3":36,"lvl4":"docs","lvl5":null,"objectID":"c37a7be11745551af028d5166b07be0b","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-parameter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-parameter/","summary":"选项参数配置。对应的配置类：java.util.Map。同时该标签为\u0026lt;dubbo:protocol\u0026gt;或\u0026lt;dubbo:service\u0026gt;或\u0026lt;dubbo:provider\u0026gt;或\u0026lt;dubbo:reference\u0026gt;或\u0026lt;dubbo:consumer\u0026gt;的子标签，用于配置自定义参数，该配置项将作为扩展点设置自定义参数使用。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     key key string 必填  服务治理 路由参数键 2.0.0以上版本   value value string 必填  服务治理 路由参数值 2.0.0以上版本    比如：\n\u0026lt;dubbo:protocol name=\u0026#34;napoli\u0026#34;\u0026gt; \u0026lt;dubbo:parameter key=\u0026#34;http://10.20.160.198/wiki/display/dubbo/napoli.queue.name\u0026#34; value=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;/dubbo:protocol\u0026gt; 也可以：\n\u0026lt;dubbo:protocol name=\u0026#34;jms\u0026#34; p:queue=\u0026#34;xxx\u0026#34; /\u0026gt; ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:protocol element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-protocol/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"258bac91a446a205ffd2b6050fcd595c","permalink":"/docs/v2.7/user/references/xml/dubbo-protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-protocol/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:protocol 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:protocol","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-protocol/","lvl3":209,"lvl4":"docs","lvl5":null,"objectID":"258bac91a446a205ffd2b6050fcd595c","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-protocol/","summary":"服务提供者协议配置。对应的配置类： org.apache.dubbo.config.ProtocolConfig。同时，如果需要支持多协议，可以声明多个 \u0026lt;dubbo:protocol\u0026gt; 标签，并在 \u0026lt;dubbo:service\u0026gt; 中通过 protocol 属性指定使用的协议。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     id  string 可选 dubbo 配置关联 协议BeanId，可以在\u0026lt;dubbo:service protocol=\u0026quot;\u0026quot;\u0026gt;中引用此ID，如果ID不填，缺省和name属性值一样，重复则在name后加序号。 2.0.5以上版本   name \u0026lt;protocol\u0026gt; string 必填 dubbo 性能调优 协议名称 2.0.5以上版本   port \u0026lt;port\u0026gt; int 可选 dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为-1，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控。 服务发现 服务端口 2.0.5以上版本   host \u0026lt;host\u0026gt; string 可选 自动查找本机IP 服务发现 -服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，-建议不要配置，让Dubbo自动获取本机IP 2.0.5以上版本   threadpool threadpool string 可选 fixed 性能调优 线程池类型，可选：fixed/cached 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:provider element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:provider","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-provider/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e930530cf8b518db7a78b1d899f159ae","permalink":"/docs/v2.7/user/references/xml/dubbo-provider/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-provider/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:provider 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:provider","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-provider/","lvl3":362,"lvl4":"docs","lvl5":null,"objectID":"e930530cf8b518db7a78b1d899f159ae","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-provider/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-provider/","summary":"服务提供者缺省值配置。对应的配置类： org.apache.dubbo.config.ProviderConfig。同时该标签为 \u0026lt;dubbo:service\u0026gt; 和 \u0026lt;dubbo:protocol\u0026gt; 标签的缺省值设置。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     id  string 可选 dubbo 配置关联 协议BeanId，可以在\u0026lt;dubbo:service proivder=\u0026quot;\u0026quot;\u0026gt;中引用此ID 1.0.16以上版本   protocol \u0026lt;protocol\u0026gt; string 可选 dubbo 性能调优 协议名称 1.0.16以上版本   host \u0026lt;host\u0026gt; string 可选 自动查找本机IP 服务发现 服务主机名，多网卡选择或指定VIP及域名时使用，为空则自动查找本机IP，建议不要配置，让Dubbo自动获取本机IP 1.0.16以上版本   threads threads int 可选 200 性能调优 服务线程池大小(固定大小) 1.0.16以上版本   payload payload int 可选 8388608(=8M) 性能调优 请求及响应数据包大小限制，单位：字节 2.0.0以上版本   path \u0026lt;path\u0026gt; string 可选  服务发现 提供者上下文路径，为服务path的前缀 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:reference element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-reference/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"67512b989cd6e3e767d99561d5eb5736","permalink":"/docs/v2.7/user/references/xml/dubbo-reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-reference/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:reference 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:reference","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-reference/","lvl3":215,"lvl4":"docs","lvl5":null,"objectID":"67512b989cd6e3e767d99561d5eb5736","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-reference/","summary":"服务消费者引用服务配置。对应的配置类： org.apache.dubbo.config.ReferenceConfig\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     id  string 必填  配置关联 服务引用BeanId 1.0.0以上版本   interface  class 必填  服务发现 服务接口名 1.0.0以上版本   version version string 可选  服务发现 服务版本，与服务提供者的版本一致 1.0.0以上版本   group group string 可选  服务发现 服务分组，当一个接口有多个实现，可以用分组区分，必需和服务提供方一致 1.0.7以上版本   timeout timeout long 可选 缺省使用\u0026lt;dubbo:consumer\u0026gt;的timeout 性能调优 服务方法调用超时时间(毫秒) 1.0.5以上版本   retries retries int 可选 缺省使用\u0026lt;dubbo:consumer\u0026gt;的retries 性能调优 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:registry element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:registry","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-registry/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"02a4ab3e12d8cfdcf455be6194066c37","permalink":"/docs/v2.7/user/references/xml/dubbo-registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-registry/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:registry 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:registry","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-registry/","lvl3":164,"lvl4":"docs","lvl5":null,"objectID":"02a4ab3e12d8cfdcf455be6194066c37","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-registry/","summary":"注册中心配置。对应的配置类： org.apache.dubbo.config.RegistryConfig。同时如果有多个不同的注册中心，可以声明多个 \u0026lt;dubbo:registry\u0026gt; 标签，并在 \u0026lt;dubbo:service\u0026gt; 或 \u0026lt;dubbo:reference\u0026gt; 的 registry 属性指定使用的注册中心。\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     id  string 可选  配置关联 注册中心引用BeanId，可以在\u0026lt;dubbo:service registry=\u0026quot;\u0026quot;\u0026gt;或\u0026lt;dubbo:reference registry=\u0026quot;\u0026quot;\u0026gt;中引用此ID 1.0.16以上版本   address \u0026lt;host:port\u0026gt; string 必填  服务发现 注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个\u0026lt;dubbo:registry\u0026gt;标签 1.0.16以上版本   protocol \u0026lt;protocol\u0026gt; string 可选 dubbo 服务发现 注册中心地址协议，支持dubbo, multicast, zookeeper, redis, consul(2.7.1), sofa(2.7.2), etcd(2.7.2), nacos(2.7.2)等协议 2.0.0以上版本   port \u0026lt;port\u0026gt; int 可选 9090 服务发现 注册中心缺省端口，当address没有带端口时使用此端口做为缺省值 2.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:service element","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"dubbo:service","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/dubbo-service/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"3e997acf35bb1f6d38d79215bbd3ac93","permalink":"/docs/v2.7/user/references/xml/dubbo-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/dubbo-service/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"dubbo:service 配置","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"dubbo:service","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/dubbo-service/","lvl3":253,"lvl4":"docs","lvl5":null,"objectID":"3e997acf35bb1f6d38d79215bbd3ac93","permalink":"/zh/docs/v2.7/user/references/xml/dubbo-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/xml/dubbo-service/","summary":"服务提供者暴露服务配置。对应的配置类：org.apache.dubbo.config.ServiceConfig\n   属性 对应URL参数 类型 是否必填 缺省值 作用 描述 兼容性     interface  class 必填  服务发现 服务接口名 1.0.0以上版本   ref  object 必填  服务发现 服务对象实现引用 1.0.0以上版本   version version string 可选 0.0.0 服务发现 服务版本，建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级 1.0.0以上版本   group group string 可选  服务发现 服务分组，当一个接口有多个实现，可以用分组区分 1.0.7以上版本   path \u0026lt;path\u0026gt; string 可选 缺省为接口名 服务发现 服务路径 (注意：1.0不支持自定义路径，总是使用接口名，如果有1.0调2.0，配置服务路径可能不兼容) 1.0.12以上版本   delay delay int 可选 0 性能调优 延迟注册服务时间(毫秒) ，设为-1时，表示延迟到Spring容器初始化完成时暴露服务 1.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Admin Functions","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/functions/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c28ef5882adb3dc5391c61c493eb96f1","permalink":"/docs/v2.7/admin/ops/functions/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/functions/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"How to become a Dubbo committer","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/become-a-committer_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"72672935beaa37fcb1549a6980d603c6","permalink":"/docs/contribution-guidelines/contributor/become-a-committer_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/become-a-committer_dev/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Nacos registry center for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Nacos Registry Center","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/nacos/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d93d75b467c46e00f635876662dc7c86","permalink":"/docs/v2.7/user/references/registry/nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/nacos/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Nacos 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Nacos 注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/nacos/","lvl3":203,"lvl4":"docs","lvl5":null,"objectID":"d93d75b467c46e00f635876662dc7c86","permalink":"/zh/docs/v2.7/user/references/registry/nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/registry/nacos/","summary":"Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 dubbo-registry-nacos 则是 Dubbo 融合 Nacos 注册中心的实现。\n预备工作 当您将 dubbo-registry-nacos 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 Nacos 快速入门。建议使用 Nacos 1.0.0 及以上的版本。\n快速上手 Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。\n增加 Maven 依赖 首先，您需要将 dubbo-registry-nacos 的 Maven 依赖添加到您的项目 pom.xml 文件中，并且强烈地推荐您使用 Dubbo 2.6.5：\n\u0026lt;dependencies\u0026gt; ... \u0026lt;!-- Dubbo Nacos registry dependency --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-registry-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Keep latest Nacos client version --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[0.6.1,)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Dubbo dependency --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Dubbo Preface","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Preface","lvl1":"docs","lvl2":"/docs/v2.7/user/preface/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4bddd28813230fab25afb56163d957d0","permalink":"/docs/v2.7/user/preface/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/preface/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Config preflight check in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Preflight Check","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/preflight-check/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d0bdce0f5001c7e2e452b891d49c5a30","permalink":"/docs/v2.7/user/examples/preflight-check/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/preflight-check/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Protocol Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/protocol/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d50cdb9251d3c6b83f3b7f4f79dcb5b2","permalink":"/docs/v2.7/dev/impls/protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/protocol/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Erlang quick start","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Quick Start","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/erlang/quick-start/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"6dc31d2435de73dab40fde7a34e8957d","permalink":"/docs/v2.7/user/languages/erlang/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/erlang/quick-start/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Basic requirements of Dubbo","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Requirements","lvl1":"docs","lvl2":"/docs/v2.7/user/preface/requirements/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"50b6e9d17b835ae9a1dfc93594ef3ac0","permalink":"/docs/v2.7/user/preface/requirements/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/preface/requirements/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Configure Dubbo with XML","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"XML Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/xml/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e4335ddef931d33e9cb13053f7d219e9","permalink":"/docs/v2.7/user/configuration/xml/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/xml/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"XML schema configuration reference for dubbo","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Schema Configuration Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/xml/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"66ed8ce63d94319f1550fa1d800bc575","permalink":"/docs/v2.7/user/references/xml/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/xml/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"以 XML 配置的方式来配置你的 Dubbo 应用","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"XML 配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/xml/","lvl3":152,"lvl4":"docs","lvl5":null,"objectID":"e4335ddef931d33e9cb13053f7d219e9","permalink":"/zh/docs/v2.7/user/configuration/xml/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/xml/","summary":"有关 XML 的详细配置项，请参见：配置参考手册。如果不想使用 Spring 配置，而希望通过 API 的方式进行调用，请参见：API配置。想知道如何使用配置，请参见：快速启动。\n请在此查看文档描述的完整示例\nprovider.xml 示例 \u0026lt;beans xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;demo-provider\u0026#34;/\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20890\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;demoService\u0026#34; class=\u0026#34;org.apache.dubbo.samples.basic.impl.DemoServiceImpl\u0026#34;/\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.samples.basic.api.DemoService\u0026#34; ref=\u0026#34;demoService\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; consumer.xml示例 \u0026lt;beans xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;demo-consumer\u0026#34;/\u0026gt; \u0026lt;dubbo:registry group=\u0026#34;aaa\u0026#34; address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; check=\u0026#34;false\u0026#34; interface=\u0026#34;org.apache.dubbo.samples.basic.api.DemoService\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 所有标签都支持自定义参数，用于不同扩展点实现的特殊配置，如：\n\u0026lt;dubbo:protocol name=\u0026#34;jms\u0026#34;\u0026gt; \u0026lt;dubbo:parameter key=\u0026#34;queue\u0026#34; value=\u0026#34;your_queue\u0026#34; /\u0026gt; \u0026lt;/dubbo:protocol\u0026gt; 或： 1\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;jms\u0026#34; p:queue=\u0026#34;your_queue\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 配置之间的关系    标签 用途 解释     \u0026lt;dubbo:service/\u0026gt; 服务配置 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心   \u0026lt;dubbo:reference/\u0026gt; 2 引用配置 用于创建一个远程服务代理，一个引用可以指向多个注册中心   \u0026lt;dubbo:protocol/\u0026gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受   \u0026lt;dubbo:application/\u0026gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者   \u0026lt;dubbo:module/\u0026gt; 模块配置 用于配置当前模块信息，可选   \u0026lt;dubbo:registry/\u0026gt; 注册中心配置 用于配置连接注册中心相关信息   \u0026lt;dubbo:monitor/\u0026gt; 监控中心配置 用于配置连接监控中心相关信息，可选   \u0026lt;dubbo:provider/\u0026gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选   \u0026lt;dubbo:consumer/\u0026gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选   \u0026lt;dubbo:method/\u0026gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息   \u0026lt;dubbo:argument/\u0026gt; 参数配置 用于指定方法参数配置    不同粒度配置的覆盖关系 以 timeout 为例，下图显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Dubbo 的 XML Schema 配置参考手册","dir":"docs/v2.7/user/references/xml/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Schema 配置参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/xml/","lvl3":31,"lvl4":"docs","lvl5":null,"objectID":"66ed8ce63d94319f1550fa1d800bc575","permalink":"/zh/docs/v2.7/user/references/xml/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/xml/","summary":"这里以 XML Config 1 为准，列举所有配置项 2。其它配置方式，请参见相应转换关系：属性配置，注解配置，API 配置。\n所有配置项分为三大类，参见下表中的\u0026quot;作用\u0026quot; 一列。\n 服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。 服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。 性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。 所有配置最终都将转换为 URL 3 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数，参见配置项一览表中的 \u0026ldquo;对应URL参数\u0026rdquo; 列。    XML Schema: http://dubbo.apache.org/schema/dubbo/dubbo.xsd \u0026#x21a9;\u0026#xfe0e;\n 注意：只有 group，interface，version 是服务的匹配条件，三者决定是不是同一个服务，其它配置项均为调优和治理参数。 \u0026#x21a9;\u0026#xfe0e;\n URL 格式：protocol://username:password@host:port/path?key=value\u0026amp;key=value \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Zookeeper registry server for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Zookeeper Registry Server","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/zookeeper/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"191cbf003f1ef6e5f823d10ffb2750d3","permalink":"/docs/v2.7/user/references/registry/zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/zookeeper/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Zookeeper 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Zookeeper 注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/zookeeper/","lvl3":233,"lvl4":"docs","lvl5":null,"objectID":"191cbf003f1ef6e5f823d10ffb2750d3","permalink":"/zh/docs/v2.7/user/references/registry/zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/registry/zookeeper/","summary":"Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 1。\n流程说明：\n 服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。  支持以下功能：\n 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 \u0026lt;dubbo:registry check=\u0026quot;false\u0026quot; /\u0026gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 \u0026lt;dubbo:registry username=\u0026quot;admin\u0026quot; password=\u0026quot;1234\u0026quot; /\u0026gt; 设置 zookeeper 登录信息 可通过 \u0026lt;dubbo:registry group=\u0026quot;dubbo\u0026quot; /\u0026gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。 支持 * 号通配符 \u0026lt;dubbo:reference group=\u0026quot;*\u0026quot; version=\u0026quot;*\u0026quot; /\u0026gt;，可订阅服务的所有分组和所有版本的提供者  使用 在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Dubbo 入门","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"入门","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/preface/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4bddd28813230fab25afb56163d957d0","permalink":"/zh/docs/v2.7/user/preface/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/preface/","summary":"","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"协议扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/protocol/","lvl3":272,"lvl4":"docs","lvl5":null,"objectID":"d50cdb9251d3c6b83f3b7f4f79dcb5b2","permalink":"/zh/docs/v2.7/dev/impls/protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/dev/impls/protocol/","summary":"扩展说明 RPC 协议扩展，封装远程调用细节。\n契约：\n 当用户调用 refer() 所返回的 Invoker 对象的 invoke() 方法时，协议需相应执行同 URL 远端 export() 传入的 Invoker 对象的 invoke() 方法。 其中，refer() 返回的 Invoker 由协议实现，协议通常需要在此 Invoker 中发送远程请求，export() 传入的 Invoker 由框架实现并传入，协议不需要关心。  注意：\n 协议不关心业务接口的透明代理，以 Invoker 为中心，由外层将 Invoker 转换为业务接口。 协议不一定要是 TCP 网络通讯，比如通过共享文件，IPC 进程间通讯等。  扩展接口  org.apache.dubbo.rpc.Protocol org.apache.dubbo.rpc.Exporter org.apache.dubbo.rpc.Invoker  public interface Protocol { /** * 暴露远程服务：\u0026lt;br\u0026gt; * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();\u0026lt;br\u0026gt; * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。\u0026lt;br\u0026gt; * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。\u0026lt;br\u0026gt; * * @param \u0026lt;T\u0026gt; 服务的类型 * @param invoker 服务的执行体 * @return exporter 暴露服务的引用，用于取消暴露 * @throws RpcException 当暴露服务出错时抛出，比如端口已占用 */ \u0026lt;T\u0026gt; Exporter\u0026lt;T\u0026gt; export(Invoker\u0026lt;T\u0026gt; invoker) throws RpcException; /** * 引用远程服务：\u0026lt;br\u0026gt; * 1.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"在启动时检查依赖的服务是否可用","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"启动时检查","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/preflight-check/","lvl3":65,"lvl4":"docs","lvl5":null,"objectID":"d0bdce0f5001c7e2e452b891d49c5a30","permalink":"/zh/docs/v2.7/user/examples/preflight-check/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/preflight-check/","summary":"Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check=\u0026quot;true\u0026quot;。\n可以通过 check=\u0026quot;false\u0026quot; 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。\n另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check=\u0026quot;false\u0026quot;，总是会返回引用，当服务恢复时，能自动连上。\n示例 通过 spring 配置文件 关闭某个服务的启动时检查 (没有提供者时报错)：\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; check=\u0026#34;false\u0026#34; /\u0026gt; 关闭所有服务的启动时检查 (没有提供者时报错)：\n\u0026lt;dubbo:consumer check=\u0026#34;false\u0026#34; /\u0026gt; 关闭注册中心启动时检查 (注册订阅失败时报错)：\n\u0026lt;dubbo:registry check=\u0026#34;false\u0026#34; /\u0026gt; 通过 dubbo.properties dubbo.reference.com.foo.BarService.check=false dubbo.reference.check=false dubbo.consumer.check=false dubbo.registry.check=false 通过 -D 参数 java -Ddubbo.reference.com.foo.BarService.check=false java -Ddubbo.reference.check=false java -Ddubbo.consumer.check=false java -Ddubbo.registry.check=false 配置的含义 dubbo.reference.check=false，强制改变所有 reference 的 check 值，就算配置中有声明，也会被覆盖。\ndubbo.consumer.check=false，是设置 check 的缺省值，如果配置中有显式的声明，如：\u0026lt;dubbo:reference check=\u0026quot;true\u0026quot;/\u0026gt;，不会受影响。\ndubbo.registry.check=false，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"Erlang 快速开始","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"快速开始","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/erlang/quick-start/","lvl3":158,"lvl4":"docs","lvl5":null,"objectID":"6dc31d2435de73dab40fde7a34e8957d","permalink":"/zh/docs/v2.7/user/languages/erlang/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/languages/erlang/quick-start/","summary":"建议先使用 java 定义接口 jar，并使用 erlanalysis 工具解析java接口至Erlang lib\n导入依赖库 使用 Rebar 编译工具。 Add dubblerl to rebar.config with your project\n{deps, [ {dubboerl, {git, \u0026#34;https://github.com/apache/dubbo-erlang.git\u0026#34;, {branch, \u0026#34;master\u0026#34;}}} ]}. 使用 erlang.mk 编译工具 待补充\n导入接口库 Suppose the interface lib you exported is called dubbo_service.\n If you didn\u0026rsquo;t upload your lib to your git repository, It is recommended that you copy the dubbo_service lib into the project\u0026rsquo;s apps directory. If it is upload to your git repository, you can import like this:  {deps, [ {dubboerl, {git, \u0026#34;https://github.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何成为 Dubbo Committer","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/become-a-committer_dev/","lvl3":16,"lvl4":"docs","lvl5":null,"objectID":"72672935beaa37fcb1549a6980d603c6","permalink":"/zh/docs/contribution-guidelines/contributor/become-a-committer_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/become-a-committer_dev/","summary":"每个人都可以成为 Apache 项目的贡献者。作为一个贡献者只是意味着你对项目感兴趣并以某种方式做出贡献，从提出合理的问题（这些问题记录了项目并向开发人员提供反馈）到提供新的特性作为补丁。\n如果你成为对一个项目有价值的贡献者，你有可能被邀请成为一个 committer。committer 是 ASF（Apache软件基金会）中用来表示提交特定项目的人的术语。它给你带来对项目仓库和资源写的权限。\n在 Dubbo 社区，如果一个 committer 获得大量的优秀成绩，就可以被邀请加入项目管理委员会（PMC）。\n当您不熟悉ASF使用的开源的开发过程时，有时难以理解的一点，就是我们更重视社区而不是代码。一个强大而健康的社区将受到尊重，成为一个有趣和有益的地方。更重要的是，一个多元化和健康的社区可以长时间的持续支持代码，即使个别公司在这个领域来来往往，也是如此。\n更多详细信息可以在这里找到。\n我可以贡献什么？ 请参阅新的贡献者指南。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"本文介绍了服务路由的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":1700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务路由","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/router/","lvl3":1600,"lvl4":"docs","lvl5":null,"objectID":"68c2c6d20d5aaf3730c85ba09138cdc5","permalink":"/zh/docs/v2.7/dev/source/router/","publishdate":"0001-01-01T00:00:00Z","readingtime":8,"relpermalink":"/zh/docs/v2.7/dev/source/router/","summary":"1. 简介 上一篇文章分析了集群容错的第一部分 — 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。在详细分析服务路由的源码之前，先来介绍一下服务路由是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为条件路由 ConditionRouter、脚本路由 ScriptRouter 和标签路由 TagRouter。其中条件路由是我们最常使用的，标签路由是一个新的实现，暂时还未发布，该实现预计会在 2.7.x 版本中发布。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。\n2. 源码分析 条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：\nhost = 10.20.153.10 =\u0026gt; host = 10.20.153.11\n该条规则表示 IP 为 10.20.153.10 的服务消费者只可调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：\n[服务消费者匹配条件] =\u0026gt; [服务提供者匹配条件]\n如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。官方文档中对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。\n条件路由实现类 ConditionRouter 在进行工作前，需要先对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。下面，我们先从表达式解析过程看起。\n2.1 表达式解析 条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：\npublic ConditionRouter(URL url) { this.url = url; // 获取 priority 和 force 配置  this.priority = url.getParameter(Constants.PRIORITY_KEY, 0); this.force = url.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Apache 提交者注册流程","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/new-committer-guide_dev/","lvl3":213,"lvl4":"docs","lvl5":null,"objectID":"c1f4b41e085f4dadb02215fea3b4d2f4","permalink":"/zh/docs/contribution-guidelines/committer/new-committer-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/committer/new-committer-guide_dev/","summary":"一、Apache 提交者的产生 项目孵化初始化提交者 项目孵化阶段，在孵化项目提案中，会有初始化提交者列表这一选项。确认你是初始化提交者的一员。项目在 apache 孵化器社区投票通过后，提交者可以开始准备注册账户了。可以参看孵化器 wiki\n活跃的贡献者被选举为提交者 在后期的开发过程中，活跃的贡献者可以被选举为提交者。见如何成为 committer\n二、个人开发者提交 ICLA 1、选择 apache id 在apache 提交者列表页查看已经注册过的 apache id，\n2、个人提交者授权协议（ICLA）： 下载ICLA 模板，查找可用的 id。将 icla.pdf 个人信息填写正确后打印,签名、扫描、并当做附件发送邮件给秘书 secretary@apache.org，秘书会帮忙创建 apache 用户 id。同时会创建一个 your_id@apache.org 的邮箱，可以在apache 提交者列表页查看查找用户是否已经创建。\n3、导师帮助提交用户id创建请求 导师将帮助提交 apache 账户创建请求给 root 邮件组，会有人帮助建立 id。一般需要2天时间账户会建立，请等待并在apache 提交者列表页查看查找用户是否已经创建。\n三、加入apache开发者组  登陆 Apache 账户工具，在登陆页面点击\u0026quot;忘记密码\u0026quot;设置始化密码，会有一封密码重置邮件发送到 forward 邮箱(在孵化项目提案中提交的开发者邮件) 关于 apache 邮箱：apache.org 邮箱并没有自己的邮件内容存储服务器。它需要借用其他邮件提供商的邮件内容存储、分发功能。在很多投票环节是建议使用 apache 邮箱的。 这里就有一个问题，怎么在其它邮箱里面配置 apache.org 邮箱转发功能：  收件箱：收取发送到 apache.org 的邮件。这个在第一步配置好 Apache 账户工具的 forward 邮箱就可以用 forward 邮箱收取邮件了 发件箱：将发出的邮件显示发件邮箱为 apache.org 邮箱。请参考：设置 apache 邮箱指南和gmail 邮箱设置方式。 其他邮箱服务的设置方式不方便找到，gmail 的最方便，建议换成 gmail 邮箱(不是广告)。   修改编辑页面的 homepage url，apache 提交者列表页中你的账户能加主页链接。 修改编辑页面的 github 账户(username)，提交确认后两个小时内会有邮件邀请你加入 github.","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"从源码开始构建 Dubbo","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"源码构建","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/build/","lvl3":114,"lvl4":"docs","lvl5":null,"objectID":"1d019c7b9259a751ab469ea16cda57c8","permalink":"/zh/docs/v2.7/dev/build/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/build/","summary":"代码签出 通过以下的这个命令签出最新的项目源码 1：\ngit clone https://github.com/apache/dubbo.git dubbo 分支 我们使用 master 作为主干版本的开发，使用分支作为维护版本。可以通过 https://github.com/apache/dubbo/tags 来查看所有版本的标签。\n构建 Dubbo 使用 maven 作为构建工具。\n要求\n Java 1.5 以上的版本 Maven 2.2.1 或者以上的版本  构建之前需要配置以下的 MAVEN_OPTS\nexport MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=512m 使用以下命令做一次构建\nmvn clean install 可以通过以下的构建命令来跳过单元测试\nmvn install -Dmaven.test.skip 构建源代码 jar 包 通过以下命令以构建 Dubbo 的源代码 jar 包\nmvn clean source:jar install -Dmaven.test.skip 并且修改你的样例项目中的 dubbo 依赖为本地仓库的 SANPSHOT 版本，然后使用远程 debug 来调试 dubbo。\nIDE 支持 使用以下命令来生成 IDE 的工程\nIntellij Idea mvn idea:idea eclipse mvn eclipse:eclipse 在 eclipse 中导入","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"管理控制台安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/admin-console/","lvl3":30,"lvl4":"docs","lvl5":null,"objectID":"f48f0cb8fe59983b07673f0fee44fe94","permalink":"/zh/docs/v2.7/admin/install/admin-console/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/admin-console/","summary":"目前版本的管理控制台正在开发中，已经完成了服务查询和服务治理的功能，采用前后端分离的模式，具体的安装和使用步骤如下：\n安装:\ngit clone https://github.com/apache/dubbo-admin.git /var/tmp/dubbo-admin cd /var/tmp/dubbo-admin mvn clean package 配置 1:\n配置文件为： dubbo-admin-backend/src/main/resources/application.properties 主要的配置有： dubbo.registry.address=zookeeper://127.0.0.1:2181 启动:\nmvn --projects dubbo-admin-backend spring-boot:run 其他配置请访问 github 中的文档:\nhttps://github.com/apache/dubbo-admin 访问:\nhttp://127.0.0.1:8080   当前版本中未实现登录功能，会在后续版本加上 \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"管理控制台运维","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/functions/","lvl3":8,"lvl4":"docs","lvl5":null,"objectID":"c28ef5882adb3dc5391c61c493eb96f1","permalink":"/zh/docs/v2.7/admin/ops/functions/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/functions/","summary":"搜索页面 当你需要管理 Dubbo 的服务时，首先要搜索到这个服务，然后打开它的管理页面\n服务提供者页面 服务消费者页面 添加路由规则页面 添加动态配置页面 ","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"本文介绍了网站应用的演进","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"背景","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/preface/background/","lvl3":9,"lvl4":"docs","lvl5":null,"objectID":"4119c14632ed40134afb7bd0ae619802","permalink":"/zh/docs/v2.7/user/preface/background/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/preface/background/","summary":"随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。\n单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。\n流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"本文介绍了 Dubbo 要解决的需求","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"需求","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/preface/requirements/","lvl3":22,"lvl4":"docs","lvl5":null,"objectID":"50b6e9d17b835ae9a1dfc93594ef3ac0","permalink":"/zh/docs/v2.7/user/preface/requirements/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/preface/requirements/","summary":"在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。\n当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。\n当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。\n接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。\n以上是 Dubbo 最基本的几个需求。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"魔鬼在细节","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/code-detail/","lvl3":60,"lvl4":"docs","lvl5":null,"objectID":"54c57c2435d742959cefeb668147b267","permalink":"/zh/docs/v2.7/dev/principals/code-detail/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/code-detail/","summary":"http://javatar.iteye.com/blog/1056664\n 最近一直担心如果 Dubbo 分布式服务框架维护人员增多或变更，会出现质量的下降的问题， 我在想，有没有什么规则是需要大家共同遵守的。根据平时写代码时的一习惯，总结了以下在写代码过程中，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的， 大家经常说，魔鬼在细节中，确实如此。\n防止空指针和下标越界 这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。\n保证线程安全性和可见性 对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。\n尽早失败和前置断言 尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。\n分离可靠操作和不可靠操作 这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。\n异常防御，但不忽略异常 这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。\n缩小可变域和尽量 final 如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。\n降低修改时的误解性，不埋雷 前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。\n提高代码的可测性 这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。","text":null,"weight":1},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"CLA Signing Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"014b613ea7c32c5f96309722ba01909b","permalink":"/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"CLA 签署向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","lvl3":41,"lvl4":"docs","lvl5":null,"objectID":"014b613ea7c32c5f96309722ba01909b","permalink":"/zh/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/cla-signing-guide_dev/","summary":"以下情况，需要您签署 Apache ICLA：\n 在 Dubbo 被捐赠给 Apache 之前，您已经为 Dubbo 作出了很多贡献，并且您以前没有签署过 Alibaba-CLA。 您已经为 Dubbo 作出了很多贡献，并且您被邀请成为 Dubbo 提交者，且之前没有签署过 Alibaba-CLA 或者 Apache ICLA。  步骤  下载这篇 pdf 文档 编辑该文档，在必要的空格处填上适当的内容 打印 在打印好的文件上签字 扫描 发送一封邮件到secretary@apache.org，并抄送给private@dubbo.apache.org：  邮件标题为“ICLA submission” 请在邮件正文附上您的github账号链接 请记得将您的ICLA文档放入邮件的附件里    空格填写必要说明  Mailing address：首选英文格式的公司地址 preferred apache id(s)：如果您被邀请成为一名提交者，那么需要您填写一个apache账号，否则，可以不填 notify project：Dubbo（意思就是Dubbo就是通知您签署ICLA的项目）  ","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Guidelines for dubbo committer","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Committer Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"32c9bb7d08e17a318203d526119ce861","permalink":"/docs/contribution-guidelines/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo Committer 指南","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Committer 指南","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"32c9bb7d08e17a318203d526119ce861","permalink":"/zh/docs/contribution-guidelines/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/contribution-guidelines/committer/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The Configuration Design","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/configuration/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"84934c3567b4385040c6a79d5d67ea58","permalink":"/docs/v2.7/dev/principals/configuration/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/configuration/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Consumer configurations in erlang","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Consumer Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/erlang/reference/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d9f36a53b4036c5244d647a8d992c675","permalink":"/docs/v2.7/user/languages/erlang/reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/erlang/reference/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Install Demo Provider","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/provider-demo/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c3481172f36dc8d24c3e7e849009c469","permalink":"/docs/v2.7/admin/install/provider-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/provider-demo/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo frame design","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Framework Design","lvl1":"docs","lvl2":"/docs/v2.7/dev/design/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1d745077efb9b4941d90865c6ab584d2","permalink":"/docs/v2.7/dev/design/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/design/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 管理控制台介绍","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/introduction/","lvl3":85,"lvl4":"docs","lvl5":null,"objectID":"8f46dfc462ab38916484e3d995f663eb","permalink":"/zh/docs/v2.7/admin/ops/introduction/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/introduction/","summary":"目前的管理控制台已经发布 0.1 版本，结构上采取了前后端分离的方式，前端使用 Vue 和 Vuetify 分别作为 Javascript 框架和UI框架，后端采用 Spring Boot 框架。既可以按照标准的 Maven 方式进行打包，部署，也可以采用前后端分离的部署方式，方便开发，功能上，目前具备了服务查询，服务治理(包括 Dubbo 2.7 中新增的治理规则)以及服务测试三部分内容。\nMaven方式部署  安装  git clone https://github.com/apache/dubbo-admin.git cd dubbo-admin mvn clean package cd dubbo-admin-distribution/target java -jar dubbo-admin-0.1.jar  访问  http://localhost:8080\n前后端分离部署  前端  cd dubbo-admin-ui npm install npm run dev  后端  cd dubbo-admin-server mvn clean package cd target java -jar dubbo-admin-server-0.1.jar  访问  http://localhost:8081\n 前后端分离模式下，前端的修改可以实时生效  配置: 1 配置文件为：","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Fault tolerance strategy in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Fault Tolerance Strategy","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/fault-tolerent-strategy/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d4968fe42d1e245198f480526d1e3327","permalink":"/docs/v2.7/user/examples/fault-tolerent-strategy/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/fault-tolerent-strategy/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Filter Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/filter/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"83fc6d73174ffcfd3e12da90082579f6","permalink":"/docs/v2.7/dev/impls/filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/filter/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Guide for install dubbo","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Installation Guide","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"43dea29ca60c0766f4a51b373df0dd3a","permalink":"/docs/v2.7/admin/install/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Admin Introductions","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/introduction/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8f46dfc462ab38916484e3d995f663eb","permalink":"/docs/v2.7/admin/ops/introduction/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/introduction/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Multicast registry for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Multicast Registry","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/multicast/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"3dcaa806143731956210219b481f6ba8","permalink":"/docs/v2.7/user/references/registry/multicast/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/multicast/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Multicast 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Multicast 注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/multicast/","lvl3":45,"lvl4":"docs","lvl5":null,"objectID":"3dcaa806143731956210219b481f6ba8","permalink":"/zh/docs/v2.7/user/references/registry/multicast/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/registry/multicast/","summary":"Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。\n提供方启动时广播自己的地址 消费方启动时广播订阅请求 提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者 消费方收到提供方地址时，连接该地址进行 RPC 调用。  组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段: 224.0.0.0 - 239.255.255.255\n配置 \u0026lt;dubbo:registry address=\u0026#34;multicast://224.5.6.7:1234\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:registry protocol=\u0026#34;multicast\u0026#34; address=\u0026#34;224.5.6.7:1234\u0026#34; /\u0026gt; 为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息; 当服务者和消费者运行在同一台机器上，消费者同样需要声明unicast=false，否则消费者无法收到消息，导致No provider available for the service异常：\n\u0026lt;dubbo:application name=\u0026#34;demo-consumer\u0026#34;\u0026gt; \u0026lt;dubbo:parameter key=\u0026#34;unicast\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/dubbo:application\u0026gt; 或\n\u0026lt;dubbo:consumer\u0026gt; \u0026lt;dubbo:parameter key=\u0026#34;unicast\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/dubbo:consumer\u0026gt; ","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"New Contributor Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"3ae6ac82483618876eaaa5562e38053d","permalink":"/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Configure Dubbo with properties","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Properties Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/properties/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"171baf1830dfb1dfee0588fc27c7797f","permalink":"/docs/v2.7/user/configuration/properties/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/properties/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"References documentation for dubbo protocols","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Protocol References","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"eae1aecdd464205e1c95bc1c04bb33bd","permalink":"/docs/v2.7/user/references/protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Quick start to use Dubbo","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Quick start","lvl1":"docs","lvl2":"/docs/v2.7/user/quick-start/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"56c1f4334bf2d4caba18c4250bf1a8ed","permalink":"/docs/v2.7/user/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/quick-start/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Release Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/release-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c97fe7b2713a56e3936e4004b355fca0","permalink":"/docs/contribution-guidelines/committer/release-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/release-guide_dev/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"References documentation for rest protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"rest protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/rest/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"2692b0ed9225bdfe354ed9ea9b695deb","permalink":"/docs/v2.7/user/references/protocol/rest/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/rest/","summary":"","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"rest:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"rest 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/rest/","lvl3":930,"lvl4":"docs","lvl5":null,"objectID":"2692b0ed9225bdfe354ed9ea9b695deb","permalink":"/zh/docs/v2.7/user/references/protocol/rest/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/zh/docs/v2.7/user/references/protocol/rest/","summary":"基于标准的Java REST API——JAX-RS 2.0（Java API for RESTful Web Services的简写）实现的REST调用支持\n快速入门 在dubbo中开发一个REST风格的服务会比较简单，下面以一个注册用户的简单服务为例说明。\n这个服务要实现的功能是提供如下URL（注：这个URL不是完全符合REST的风格，但是更简单实用）：\nhttp://localhost:8080/users/register 而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册。\n首先，开发服务的接口：\npublic interface UserService { void registerUser(User user); } 然后，开发服务的实现：\n@Path(\u0026#34;/users\u0026#34;) public class UserServiceImpl implements UserService { @POST @Path(\u0026#34;/register\u0026#34;) @Consumes({MediaType.APPLICATION_JSON}) public void registerUser(User user) { // save the user...  } } 上面的实现非常简单，但是由于该 REST 服务是要发布到指定 URL 上，供任意语言的客户端甚至浏览器来访问，所以这里额外添加了几个 JAX-RS 的标准 annotation 来做相关的配置。\n@Path(\u0026quot;/users\u0026quot;)：指定访问UserService的URL相对路径是/users，即http://localhost:8080/users\n@Path(\u0026quot;/register\u0026quot;)：指定访问registerUser()方法的URL相对路径是/register，再结合上一个@Path为UserService指定的路径，则调用UserService.register()的完整路径为http://localhost:8080/users/register\n@POST：指定访问registerUser()用HTTP POST方法\n@Consumes({MediaType.APPLICATION_JSON})：指定registerUser()接收JSON格式的数据。REST框架会自动将JSON数据反序列化为User对象\n最后，在spring配置文件中添加此服务，即完成所有服务开发工作：\n\u0026lt;!-- 用rest协议在8080端口暴露服务 --\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;rest\u0026#34; port=\u0026#34;8080\u0026#34;/\u0026gt; \u0026lt;!-- 声明需要暴露的服务接口 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;xxx.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"本文介绍了自适应拓展的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":2300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"SPI 自适应拓展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/adaptive-extension/","lvl3":2234,"lvl4":"docs","lvl5":null,"objectID":"b0674383775851268c3a8f5ec650e9a7","permalink":"/zh/docs/v2.7/dev/source/adaptive-extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":11,"relpermalink":"/zh/docs/v2.7/dev/source/adaptive-extension/","summary":"1.原理 在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个示例进行演示。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：\npublic interface WheelMaker { Wheel makeWheel(URL url); } WheelMaker 接口的自适应实现类如下：\npublic class AdaptiveWheelMaker implements WheelMaker { public Wheel makeWheel(URL url) { if (url == null) { throw new IllegalArgumentException(\u0026#34;url == null\u0026#34;); } // 1.从 URL 中获取 WheelMaker 名称  String wheelMakerName = url.getParameter(\u0026#34;Wheel.maker\u0026#34;); if (wheelMakerName == null) { throw new IllegalArgumentException(\u0026#34;wheelMakerName == null\u0026#34;); } // 2.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo 2.7 中的动态配置中心","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"动态配置中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/config-center/","lvl3":166,"lvl4":"docs","lvl5":null,"objectID":"63a9d61b7adb07aa7d67c823def2d877","permalink":"/zh/docs/v2.7/user/configuration/config-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/config-center/","summary":"配置中心（v2.7.0）在 Dubbo 中承担两个职责：\n 外部化配置。启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。 服务治理。服务治理规则的存储与通知。  启用动态配置，以 Zookeeper 为例，可查看 动态配置配置项详解\n\u0026lt;dubbo:config-center address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; 或者\ndubbo.config-center.address=zookeeper://127.0.0.1:2181 或者\nConfigCenterConfig configCenter = new ConfigCenterConfig(); configCenter.setAddress(\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;);  为了兼容 2.6.x 版本配置，在使用 Zookeeper 作为注册中心，且没有显示配置配置中心的情况下，Dubbo 框架会默认将此 Zookeeper 用作配置中心，但将只作服务治理用途。\n 外部化配置 外部化配置目的之一是实现配置的集中式管理，这部分业界已经有很多成熟的专业配置系统如 Apollo, Nacos 等，Dubbo 所做的主要是保证能配合这些系统正常工作。\n外部化配置和其他本地配置在内容和格式上并无区别，可以简单理解为 dubbo.properties 的外部化存储，配置中心更适合将一些公共配置如注册中心、元数据中心配置等抽取以便做集中管理。\n# 将注册中心地址、元数据中心地址等配置集中管理，可以做到统一环境、减少开发侧感知。 dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.registry.simplified=true dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 dubbo.application.qos.port=33333   优先级\n外部化配置默认较本地配置有更高的优先级，因此这里配置的内容会覆盖本地配置值，关于 各配置形式间的覆盖关系 有单独一章说明，你也可通过以下选项调整配置中心的优先级：\n-Ddubbo.config-center.highest-priority=false   作用域\n外部化配置有全局和应用两个级别，全局配置是所有应用共享的，应用级配置是由每个应用自己维护且只对自身可见的。当前已支持的扩展实现有Zookeeper、Apollo。\n  Zookeeper \u0026lt;dubbo:config-center address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; 默认所有的配置都存储在 /dubbo/config 节点，具体节点结构图如下：","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"协议参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/","lvl3":3,"lvl4":"docs","lvl5":null,"objectID":"eae1aecdd464205e1c95bc1c04bb33bd","permalink":"/zh/docs/v2.7/user/references/protocol/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/","summary":"推荐使用 Dubbo 协议。各协议的性能情况，请参见：性能测试报告","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":1300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何准备 Apache Release","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/release-guide_dev/","lvl3":1209,"lvl4":"docs","lvl5":null,"objectID":"c97fe7b2713a56e3936e4004b355fca0","permalink":"/zh/docs/contribution-guidelines/committer/release-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/zh/docs/contribution-guidelines/committer/release-guide_dev/","summary":"理解 Apache 发布的内容和流程 总的来说，Source Release 是 Apache 关注的重点，也是发布的必须内容；而 Binary Release 是可选项，Dubbo 可以选择是否发布二进制包到 Apache 仓库或者发布到 Maven 中央仓库。\n请参考以下链接，找到更多关于 ASF 的发布指南:\n Apache Release Guide Apache Release Policy Maven Release Info  本地构建环境准备 主要包括签名工具、Maven 仓库认证相关准备\n安装GPG 详细文档请参见这里, Mac OS 下配置如下\n$ brew install gpg $ gpg --version #检查版本，应该为2.x 用gpg生成key 根据提示，生成 key\n$ gpg --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo 相关的安装手册","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"安装手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/","lvl3":77,"lvl4":"docs","lvl5":null,"objectID":"43dea29ca60c0766f4a51b373df0dd3a","permalink":"/zh/docs/v2.7/admin/install/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/","summary":"你可以只运行 Demo Provider 和 Demo Consumer，它们缺省配置为通过 Multicast 1 注册中心广播互相发现，建议在不同机器上运行，如果在同一机器上，需设置 unicast=false：即： multicast://224.5.6.7:1234?unicast=false，否则发给消费者的单播消息可能被提供者抢占，两个消费者在同一台机器也一样，只有 multicast 注册中心有此问题。\n你也可以运行多个 Demo Provider 和 Demo Consumer，来验证软负载均衡，Demo Consumer 可以直接启动多个实例，而多个 Demo Provider 因有端口冲突，可在不同机器上运行，或者修改 Demo Provider 安装目录下 conf/dubbo.properties 配置中的 dubbo.protocol.port 的值。\n你也可以增加运行 Simple Monitor 监控中心，它缺省配置为通过 Multicast 注册中心广播发现 Provider 和 Consumer，并展示出它们的依赖关系，以及它们之间调用的次数和时间。\n你也可以将 Multicast 注册中心换成 Zookeeper 注册中心，安装 Zookeeper Registry 后，修改 Demo Proivder，Demo Consumer，Simple Monitor 三者安装目录下的 conf/dubbo.properties，将 dubbo.registry.address 的值改为 zookeeper://127.0.0.1:2181，同理，如果换成 Redis Registry，值改为 redis://127.0.0.1:6379，如果换成 Simple Registry，值改为 dubbo://127.0.0.1:9090\n推荐使用 Zookeeper 注册中心\n  注意：multicast 地址不能配成 127.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"以属性配置的方式来配置你的 Dubbo 应用","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"属性配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/properties/","lvl3":83,"lvl4":"docs","lvl5":null,"objectID":"171baf1830dfb1dfee0588fc27c7797f","permalink":"/zh/docs/v2.7/user/configuration/properties/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/properties/","summary":"如果你的应用足够简单，例如，不需要多注册中心或多协议，并且需要在spring容器中共享配置，那么，我们可以直接使用 dubbo.properties 作为默认配置。\nDubbo 可以自动加载 classpath 根目录下的 dubbo.properties，但是你同样可以使用 JVM 参数来指定路径：-Ddubbo.properties.file=xxx.properties。\n映射规则 可以将 xml 的 tag 名和属性名组合起来，用 ‘.’ 分隔。每行一个属性。\n dubbo.application.name=foo 相当于 \u0026lt;dubbo:application name=\u0026quot;foo\u0026quot; /\u0026gt; dubbo.registry.address=10.20.153.10:9090 相当于 \u0026lt;dubbo:registry address=\u0026quot;10.20.153.10:9090\u0026quot; /\u0026gt;   如果在 xml 配置中有超过一个的 tag，那么你可以使用 ‘id’ 进行区分。如果你不指定 id，它将作用于所有 tag。\n dubbo.protocol.rmi.port=1099 相当于 \u0026lt;dubbo:protocol id=\u0026quot;rmi\u0026quot; name=\u0026quot;rmi\u0026quot; port=\u0026quot;1099\u0026quot; /\u0026gt;  dubbo.registry.china.address=10.20.153.10:9090 相当于 \u0026lt;dubbo:registry id=\u0026quot;china\u0026quot; address=\u0026quot;10.20.153.10:9090\u0026quot; /\u0026gt;  如下，是一个典型的 dubbo.properties 配置样例。\ndubbo.application.name=foo dubbo.application.owner=bar dubbo.registry.address=10.20.153.10:9090 重写与优先级 优先级从高到低：\n JVM -D 参数：当你部署或者启动应用时，它可以轻易地重写配置，比如，改变 dubbo 协议端口； XML：XML 中的当前配置会重写 dubbo.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"快速开始使用 Dubbo","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"快速开始","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/quick-start/","lvl3":232,"lvl4":"docs","lvl5":null,"objectID":"56c1f4334bf2d4caba18c4250bf1a8ed","permalink":"/zh/docs/v2.7/user/quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/quick-start/","summary":"Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展 进行加载。\n如果不想使用 Spring 配置，可以通过 API 的方式 进行调用。\n服务提供者 完整安装步骤，请参见：示例提供者安装\n定义服务接口 DemoService.java 1：\npackage org.apache.dubbo.demo; public interface DemoService { String sayHello(String name); } 在服务提供方实现接口 DemoServiceImpl.java 2：\npackage org.apache.dubbo.demo.provider; import org.apache.dubbo.demo.DemoService; public class DemoServiceImpl implements DemoService { public String sayHello(String name) { return \u0026#34;Hello \u0026#34; + name; } } 用 Spring 配置声明暴露服务 provider.xml：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"新贡献者向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","lvl3":82,"lvl4":"docs","lvl5":null,"objectID":"3ae6ac82483618876eaaa5562e38053d","permalink":"/zh/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/new-contributor-guide_dev/","summary":"这篇向导旨在给正在准备向 Dubbo 提交贡献的新手提供指导。\n邮件列表描述 邮件列表是 Dubbo 官方推荐的讨论方式，所有与 Dubbo 相关的内容都可以在这里讨论，请点击 issue 了解更多关于邮件列表订阅的内容\n如需订阅如下邮件列表，请参考 邮件列表订阅向导\n dev@dubbo.apache.org：开发邮件列表，您在使用或者开发 Dubbo 的过程中遇到的任何问题，都可以在这里进行提问。 commits@dubbo.apache.org：所有的提交内容都会推送到这个邮件列表，如果您对 Dubbo 的进展感兴趣，可以订阅这个邮件列表。 issues@dubbo.apache.org：所有的 JIRA issues 和修改信息都会推送到这个邮件列表。Dubbo 社区已经决定使用 github issues 代替 JIRA issues，因此大部分 issues 将由 github issues 进行跟踪。JIRA issues 用于跟踪 ASF 相关问题。  报告问题 发送 pull request  参考pull request template中的检查列表 在您发送 pull request 之前，请同步您的 github 仓库和远程仓库，这会使您的 pull request 简单明了，具体操作请看如下所示步骤：  git remote add upstream git@github.com:apache/dubbo.git git fetch upstream git rebase upstream/master git checkout -b your_awesome_patch .","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Dubbo 框架设计概览","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"框架设计","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/design/","lvl3":323,"lvl4":"docs","lvl5":null,"objectID":"1d745077efb9b4941d90865c6ab584d2","permalink":"/zh/docs/v2.7/dev/design/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/dev/design/","summary":"整体设计 图例说明：\n 图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。 图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。 图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。 图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。  各层说明  config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool  关系说明  在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。 图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。 而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。 Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。 而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。 Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。  模块分包 模块说明：","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"在 erlang 中配置消费者","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"消费者配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/erlang/reference/","lvl3":21,"lvl4":"docs","lvl5":null,"objectID":"d9f36a53b4036c5244d647a8d992c675","permalink":"/zh/docs/v2.7/user/languages/erlang/reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/languages/erlang/reference/","summary":"基础配置 消费者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。\n{dubboerl,[ %% other config ... \t{consumer,[ {\u0026lt;\u0026lt;\u0026#34;interface fullname\u0026#34;\u0026gt;\u0026gt;,[Option]}, %% eg: \t{\u0026lt;\u0026lt;\u0026#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator\u0026#34;\u0026gt;\u0026gt;,[]}, ]} ]} Option 配置项待添加中。","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"示例提供者安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/provider-demo/","lvl3":16,"lvl4":"docs","lvl5":null,"objectID":"c3481172f36dc8d24c3e7e849009c469","permalink":"/zh/docs/v2.7/admin/install/provider-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/provider-demo/","summary":"安装：\ngit clone https://github.com/apache/dubbo.git cd dubbo/dubbo-demo/dubbo-demo-xml 运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application 如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=true 配置：\nresources/spring/dubbo-provider.xml 修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如： \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; ","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中自动加载环境变量","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"自动加载环境变量","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/environment-variables/","lvl3":61,"lvl4":"docs","lvl5":null,"objectID":"b8596afdd809567f6b90faa664c761bd","permalink":"/zh/docs/v2.7/user/configuration/environment-variables/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/environment-variables/","summary":"从 2.7.3 版本开始，Dubbo 会自动从约定 key 中读取配置，并将配置以 Key-Value 的形式写入到URL中。\n支持的 key 有以下两个：\n  dubbo.labels，指定一些列配置到 URL 中的键值对，通常通过 JVM -D 或系统环境变量指定。\n增加以下配置：\n# JVM -Ddubbo.labels = \u0026#34;tag1=value1; tag2=value2\u0026#34; # 环境变量 DUBBO_LABELS = \u0026#34;tag1=value1; tag2=value2\u0026#34; 最终生成的 URL 会包含 tag1、tag2 两个 key: dubbo://xxx?tag1=value1\u0026amp;tag2=value2\n  dubbo.env.keys，指定环境变量 key 值，Dubbo 会尝试从环境变量加载每个 key\n# JVM -Ddubbo.env.keys = \u0026#34;DUBBO_TAG1, DUBBO_TAG2\u0026#34; # 环境变量 DUBBO_ENV_KEYS = \u0026#34;DUBBO_TAG1, DUBBO_TAG2\u0026#34; 最终生成的 URL 会包含 DUBBO_TAG1、DUBBO_TAG2 两个 key: dubbo://xxx?DUBBO_TAG1=value1\u0026amp;DUBBO_TAG2=value2\n  ","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"调用拦截扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/filter/","lvl3":137,"lvl4":"docs","lvl5":null,"objectID":"83fc6d73174ffcfd3e12da90082579f6","permalink":"/zh/docs/v2.7/dev/impls/filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/filter/","summary":"扩展说明 服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。\n约定：\n 用户自定义 filter 默认在内置 filter 之后。 特殊值 default，表示缺省扩展点插入的位置。比如：filter=\u0026quot;xxx,default,yyy\u0026quot;，表示 xxx 在缺省 filter 之前，yyy 在缺省 filter 之后。 特殊符号 -，表示剔除。比如：filter=\u0026quot;-foo1\u0026quot;，剔除添加缺省扩展点 foo1。比如：filter=\u0026quot;-default\u0026quot;，剔除添加所有缺省扩展点。 provider 和 service 同时配置的 filter 时，累加所有 filter，而不是覆盖。比如：\u0026lt;dubbo:provider filter=\u0026quot;xxx,yyy\u0026quot;/\u0026gt; 和 \u0026lt;dubbo:service filter=\u0026quot;aaa,bbb\u0026quot; /\u0026gt;，则 xxx,yyy,aaa,bbb 均会生效。如果要覆盖，需配置：\u0026lt;dubbo:service filter=\u0026quot;-xxx,-yyy,aaa,bbb\u0026quot; /\u0026gt;  扩展接口 org.apache.dubbo.rpc.Filter\n扩展配置 \u0026lt;!-- 消费方调用过程拦截 --\u0026gt; \u0026lt;dubbo:reference filter=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 消费方调用过程缺省拦截器，将拦截所有reference --\u0026gt; \u0026lt;dubbo:consumer filter=\u0026#34;xxx,yyy\u0026#34;/\u0026gt; \u0026lt;!-- 提供方调用过程拦截 --\u0026gt; \u0026lt;dubbo:service filter=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 提供方调用过程缺省拦截器，将拦截所有service --\u0026gt; \u0026lt;dubbo:provider filter=\u0026#34;xxx,yyy\u0026#34;/\u0026gt; 已知扩展  org.apache.dubbo.rpc.filter.EchoFilter org.apache.dubbo.rpc.filter.GenericFilter org.apache.dubbo.rpc.filter.GenericImplFilter org.apache.dubbo.rpc.filter.TokenFilter org.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"配置设计","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/configuration/","lvl3":201,"lvl4":"docs","lvl5":null,"objectID":"84934c3567b4385040c6a79d5d67ea58","permalink":"/zh/docs/v2.7/dev/principals/configuration/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/configuration/","summary":"http://javatar.iteye.com/blog/949527\n Dubbo 现在的设计是完全无侵入，也就是使用者只依赖于配置契约。经过多个版本的发展，为了满足各种需求场景，配置越来越多。为了保持兼容，配置只增不减，里面潜伏着各种风格，约定，规则。新版本也将配置做了一次调整，将想到的一些记在这，备忘。\n配置分类 首先，配置的用途是有多种的，大致可以分为：\n环境配置，比如：连接数，超时等配置。 描述配置，比如：服务接口描述，服务版本等。 扩展配置，比如：协议扩展，策略扩展等。  配置格式 通常环境配置，用 properties 配置会比较方便，因为都是一些离散的简单值，用 key-value 配置可以减少配置的学习成本。\n而描述配置，通常信息比较多，甚至有层次关系，用 xml 配置会比较方便，因为树结构的配置表现力更强。如果非常复杂，也可以考自定义 DSL 做为配置。有时候这类配置也可以用 Annotation 代替， 因为这些配置和业务逻辑相关，放在代码里也是合理的。\n另外扩展配置，可能不尽相同。如果只是策略接口实现类替换，可以考虑 properties 等结构。如果有复杂的生命周期管理，可能需要 XML 等配置。有时候扩展会通过注册接口的方式提供。\n配置加载 对于环境配置，在 java 世界里，比较常规的做法，是在 classpath 下约定一个以项目为名称的 properties 配置，比如：log4j.properties，velocity.properties等。产品在初始化时，自动从 classpath 下加载该配置。我们平台的很多项目也使用类似策略，如：dubbo.properties，comsat.xml 等。这样有它的优势，就是基于约定，简化了用户对配置加载过程的干预。但同样有它的缺点，当 classpath 存在同样的配置时，可能误加载，以及在 ClassLoader 隔离时，可能找不到配置，并且，当用户希望将配置放到统一的目录时，不太方便。\n而对于描述配置，因为要参与业务逻辑，通常会嵌到应用的生命周期管理中。现在使用 spring 的项目越来越多，直接使用 spring 配置的比较普遍，而且 spring 允许自定义 schema，配置简化后很方便。当然，也有它的缺点，就是强依赖 spring，可以提编程接口做了配套方案。\n在 Dubbo 既存在描述配置也有环境配置。一部分用 spring 的 schema 做配置加载，一部分从 classpath 扫描 properties 做配置加载。在新版本中做了一个优先级约定，统一以 spring 的 schema 驱动配置加载，dubbo.properties作为配置补充。\n同时，在 Spring 的场景下，除了使用 schema 外，还支持完全以 application.","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"集群调用失败时，Dubbo 提供的容错方案","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"集群容错","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/fault-tolerent-strategy/","lvl3":92,"lvl4":"docs","lvl5":null,"objectID":"d4968fe42d1e245198f480526d1e3327","permalink":"/zh/docs/v2.7/user/examples/fault-tolerent-strategy/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/fault-tolerent-strategy/","summary":"在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。\n各节点关系：\n 这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息 Directory 代表多个 Invoker，可以把它看成 List\u0026lt;Invoker\u0026gt; ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更 Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个 Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等 LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选  集群容错模式 可以自行扩展集群容错策略，参见：集群扩展\nFailover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=\u0026quot;2\u0026quot; 来设置重试次数(不含第一次)。\n重试次数配置如下：\n\u0026lt;dubbo:service retries=\u0026#34;2\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:reference retries=\u0026#34;2\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:reference\u0026gt; \u0026lt;dubbo:method name=\u0026#34;findFoo\u0026#34; retries=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt;  提示 该配置为缺省配置  Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。","text":null,"weight":2},{"authors":null,"date":-62135596800,"description":"Configure Dubbo with API","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"API Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/api/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4ece50342f0767c0486196201acacdc8","permalink":"/docs/v2.7/user/configuration/api/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/api/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"以API 配置的方式来配置你的 Dubbo 应用","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"API 配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/api/","lvl3":194,"lvl4":"docs","lvl5":null,"objectID":"4ece50342f0767c0486196201acacdc8","permalink":"/zh/docs/v2.7/user/configuration/api/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/api/","summary":"API 属性与配置项一对一，各属性含义，请参见：配置参考手册，比如：ApplicationConfig.setName(\u0026quot;xxx\u0026quot;) 对应 \u0026lt;dubbo:application name=\u0026quot;xxx\u0026quot; /\u0026gt; 1\n服务提供者 import org.apache.dubbo.rpc.config.ApplicationConfig; import org.apache.dubbo.rpc.config.RegistryConfig; import org.apache.dubbo.rpc.config.ProviderConfig; import org.apache.dubbo.rpc.config.ServiceConfig; import com.xxx.XxxService; import com.xxx.XxxServiceImpl; // 服务实现 XxxService xxxService = new XxxServiceImpl(); // 当前应用配置 ApplicationConfig application = new ApplicationConfig(); application.setName(\u0026#34;xxx\u0026#34;); // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setAddress(\u0026#34;10.20.130.230:9090\u0026#34;); registry.setUsername(\u0026#34;aaa\u0026#34;); registry.setPassword(\u0026#34;bbb\u0026#34;); // 服务提供者协议配置 ProtocolConfig protocol = new ProtocolConfig(); protocol.setName(\u0026#34;dubbo\u0026#34;); protocol.setPort(12345); protocol.setThreads(200); // 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，以及开启服务端口  // 服务提供者暴露服务配置 ServiceConfig\u0026lt;XxxService\u0026gt; service = new ServiceConfig\u0026lt;XxxService\u0026gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏 service.setApplication(application); service.setRegistry(registry); // 多个注册中心可以用setRegistries() service.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo Architecture","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Architecture","lvl1":"docs","lvl2":"/docs/v2.7/user/preface/architecture/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1bc6df295416e114a85dd7cae84cea43","permalink":"/docs/v2.7/user/preface/architecture/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/preface/architecture/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Install Demo Consumer","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/consumer-demo/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f33304df74f0a735ba1e03d01ad06398","permalink":"/docs/v2.7/admin/install/consumer-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/consumer-demo/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo dependencies","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dependencies","lvl1":"docs","lvl2":"/docs/v2.7/user/dependencies/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"71831b461a88bd93909ef1b58ca744b3","permalink":"/docs/v2.7/user/dependencies/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/dependencies/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":" \"Fool-proof\" Design","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/dummy/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"22a69034fe5f223dfc1d3ae9fcc4f4c0","permalink":"/docs/v2.7/dev/principals/dummy/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/dummy/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"References documentation for http protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"http protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/http/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7c7ebd8951a675906a0cfc2ebb1bad4b","permalink":"/docs/v2.7/user/references/protocol/http/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/http/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"http:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"http 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/http/","lvl3":75,"lvl4":"docs","lvl5":null,"objectID":"7c7ebd8951a675906a0cfc2ebb1bad4b","permalink":"/zh/docs/v2.7/user/references/protocol/http/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/http/","summary":"基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现\n提示 2.3.0 以上版本支持  特性  连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：表单序列化 适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。 适用场景：需同时给应用程序和浏览器 JS 使用的服务。  约束  参数及返回值需符合 Bean 规范  配置 配置协议：\n\u0026lt;dubbo:protocol name=\u0026#34;http\u0026#34; port=\u0026#34;8080\u0026#34; /\u0026gt; 配置 Jetty Server (默认)：\n\u0026lt;dubbo:protocol ... server=\u0026#34;jetty\u0026#34; /\u0026gt; 配置 Servlet Bridge Server (推荐使用)：\n\u0026lt;dubbo:protocol ... server=\u0026#34;servlet\u0026#34; /\u0026gt; 配置 DispatcherServlet：\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dubbo\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.apache.dubbo.remoting.http.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dubbo\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 注意，如果使用 servlet 派发请求：\n 协议的端口 \u0026lt;dubbo:protocol port=\u0026quot;8080\u0026quot; /\u0026gt; 必须与 servlet 容器的端口相同， 协议的上下文路径 \u0026lt;dubbo:protocol contextpath=\u0026quot;foo\u0026quot; /\u0026gt; 必须与 servlet 应用的上下文路径相同。  ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"InvokerListener Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/invoker-listener/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"cea6e7114bb0124140f2484114ae2bd0","permalink":"/docs/v2.7/dev/impls/invoker-listener/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/invoker-listener/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Label an Issue","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e74813424f208b44fa15095711138fef","permalink":"/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Load Balance in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Load Balance","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/loadbalance/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a56289a268d75e46d15b529b841c8812","permalink":"/docs/v2.7/user/examples/loadbalance/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/loadbalance/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Mailing List Subscription Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1ce93cc5e129f0d79e964af7bb985caa","permalink":"/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Protocol configurations in erlang","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Provider Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/erlang/service/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"45e4c1c6a4738b2cd900513dfe286ba2","permalink":"/docs/v2.7/user/languages/erlang/service/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/erlang/service/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Redis registry server for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Redis Registry Server","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/redis/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"2cc7dc0b02057982aa5ff487a187bcae","permalink":"/docs/v2.7/user/references/registry/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/redis/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Redis 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Redis 注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/redis/","lvl3":169,"lvl4":"docs","lvl5":null,"objectID":"2cc7dc0b02057982aa5ff487a187bcae","permalink":"/zh/docs/v2.7/user/references/registry/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/registry/redis/","summary":"基于 Redis 1 实现的注册中心。\n提示 从 2.1.0 版本开始支持。\nRedis 过期数据通过心跳的方式检测脏数据，服务器时间必须同步，并且对服务器有一定压力，否则过期检测会不准确\n 使用 Redis 的 Key/Map 结构存储数据结构：\n 主 Key 为服务名和类型 Map 中的 Key 为 URL 地址 Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除 [^3]  使用 Redis 的 Publish/Subscribe 事件通知数据变更：\n 通过事件的值区分事件类型：register, unregister, subscribe, unsubscribe 普通消费者直接订阅指定服务提供者的 Key，只会收到指定服务的 register, unregister 事件 监控中心通过 psubscribe 功能订阅 /dubbo/*，会收到所有服务的所有变更事件  调用过程：\n服务提供方启动时，向 Key:/dubbo/com.foo.BarService/providers 下，添加当前提供者的地址 并向 Channel:/dubbo/com.foo.BarService/providers 发送 register 事件 服务消费方启动时，从 Channel:/dubbo/com.foo.BarService/providers 订阅 register 和 unregister 事件 并向 Key:/dubbo/com.foo.BarService/consumers 下，添加当前消费者的地址 服务消费方收到 register 和 unregister 事件后，从 Key:/dubbo/com.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Registry server references for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Registry Server References","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"dbde19022956537fe1d1ac8e50ea35bf","permalink":"/docs/v2.7/user/references/registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Search And Service Detail","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/search/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"5ae124bb8df6a56c1774e7e1f1257f14","permalink":"/docs/v2.7/admin/ops/search/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/search/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"How Dubbo SPI works","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"SPI Loading","lvl1":"docs","lvl2":"/docs/v2.7/dev/spi/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"cb20ac483f94b09003078a7abc83f40e","permalink":"/docs/v2.7/dev/spi/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/spi/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Test","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/test/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"38e4ba774c877b57ce39868fc5645097","permalink":"/docs/v2.7/admin/ops/test/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/test/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Website Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/website-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"93c9066e30b71c454d92645f58531763","permalink":"/docs/contribution-guidelines/committer/website-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/website-guide_dev/","summary":"","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo 依赖基本介绍","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"依赖","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/dependencies/","lvl3":140,"lvl4":"docs","lvl5":null,"objectID":"71831b461a88bd93909ef1b58ca744b3","permalink":"/zh/docs/v2.7/user/dependencies/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/dependencies/","summary":"必须依赖 JDK 1.6+ 1\n缺省依赖 通过 mvn dependency:tree \u0026gt; dep.log 命令分析，Dubbo 缺省依赖以下三方库：\n[INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile [INFO] | +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile [INFO] | +- org.javassist:javassist:jar:3.21.0-GA:compile [INFO] | \\- org.jboss.netty:netty:jar:3.2.5.Final:compile 这里所有依赖都是换照 Dubbo 缺省配置选的，这些缺省值是基于稳定性和性能考虑的。\n javassist.jar 2: 如果 \u0026lt;dubbo:provider proxy=\u0026quot;jdk\u0026quot; /\u0026gt; 或 \u0026lt;dubbo:consumer proxy=\u0026quot;jdk\u0026quot; /\u0026gt;，以及 \u0026lt;dubbo:application compiler=\u0026quot;jdk\u0026quot; /\u0026gt;，则不需要。 spring-context.jar 3: 如果用 ServiceConfig 和 ReferenceConfig 的 API 调用，则不需要。 netty.jar 4: 如果 \u0026lt;dubbo:protocol server=\u0026quot;mina\u0026quot;/\u0026gt; 或 \u0026lt;dubbo:protocol server=\u0026quot;grizzly\u0026quot;/\u0026gt;，则换成 mina.jar 或 grizzly.jar。如果 \u0026lt;protocol name=\u0026quot;rmi\u0026quot;/\u0026gt;，则不需要。  可选依赖 以下依赖，在主动配置使用相应实现策略时用到，需自行加入依赖。\n netty-all 4.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"引用监听扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/invoker-listener/","lvl3":72,"lvl4":"docs","lvl5":null,"objectID":"cea6e7114bb0124140f2484114ae2bd0","permalink":"/zh/docs/v2.7/dev/impls/invoker-listener/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/invoker-listener/","summary":"扩展说明 当有服务引用时，触发该事件。\n扩展接口 org.apache.dubbo.rpc.InvokerListener\n扩展配置 \u0026lt;!-- 引用服务监听 --\u0026gt; \u0026lt;dubbo:reference listener=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 引用服务缺省监听器 --\u0026gt; \u0026lt;dubbo:consumer listener=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展 org.apache.dubbo.rpc.listener.DeprecatedInvokerListener\n扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxInvokerListener.java (实现InvokerListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.InvokerListener (纯文本文件，内容为：xxx=com.xxx.XxxInvokerListener) XxxInvokerListener.java：\npackage com.xxx; import org.apache.dubbo.rpc.InvokerListener; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxInvokerListener implements InvokerListener { public void referred(Invoker\u0026lt;?\u0026gt; invoker) throws RpcException { // ...  } public void destroyed(Invoker\u0026lt;?\u0026gt; invoker) throws RpcException { // ...  } } META-INF/dubbo/org.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo 中的扩展点加载机制","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"扩展点加载","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/spi/","lvl3":455,"lvl4":"docs","lvl5":null,"objectID":"cb20ac483f94b09003078a7abc83f40e","permalink":"/zh/docs/v2.7/dev/spi/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/dev/spi/","summary":"扩展点配置 来源： Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。\nDubbo 改进了 JDK 标准的 SPI 的以下问题：\n JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。 如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。 增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。  约定： 在扩展类的 jar 包内 1，放置扩展点配置文件 META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。\n示例： 以扩展 Dubbo 的协议为例，在协议的实现 jar 包内放置文本文件：META-INF/dubbo/org.apache.dubbo.rpc.Protocol，内容为：\nxxx=com.alibaba.xxx.XxxProtocol 实现类内容 2：\npackage com.alibaba.xxx; import org.apache.dubbo.rpc.Protocol; public class XxxProtocol implements Protocol { // .","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"在 erlang 中配置服务提供者","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"提供者配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/erlang/service/","lvl3":57,"lvl4":"docs","lvl5":null,"objectID":"45e4c1c6a4738b2cd900513dfe286ba2","permalink":"/zh/docs/v2.7/user/languages/erlang/service/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/languages/erlang/service/","summary":"基本配置 提供者配置项需要添加到 sys.config 文件 dubboerl 应用配置项里。\n{dubboerl,[ %% other config ... \t{provider,[ {module_implements,interface_module,interface_fullname,[Options]}, %% eg: \t{userOperator_impl,userOperator,\u0026lt;\u0026lt;\u0026#34;org.apache.dubbo.erlang.sample.service.facade.UserOperator\u0026#34;\u0026gt;\u0026gt;,[Option]} ]} ]}    ConfigName Type DefaultValue Remarks     module_implements atom() - The service implements module name   interface_module atom() - Interface module name is transfer form java jar   interface_fullname binary() - Interface full name is the java class name    Option is to be added.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"本文介绍了 Dubbo 服务导出的过程和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":4800,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务导出","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/export-service/","lvl3":4706,"lvl4":"docs","lvl5":null,"objectID":"80b6b1375eaef6eabf0a1e4ab007f7ae","permalink":"/zh/docs/v2.7/dev/source/export-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":23,"relpermalink":"/zh/docs/v2.7/dev/source/export-service/","summary":"1.简介 本篇文章，我们来研究一下 Dubbo 导出服务的过程。Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析。\n2.源码分析 服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：\npublic void onApplicationEvent(ContextRefreshedEvent event) { // 是否有延迟导出 \u0026amp;\u0026amp; 是否已导出 \u0026amp;\u0026amp; 是不是已被取消导出  if (isDelay() \u0026amp;\u0026amp; !isExported() \u0026amp;\u0026amp; !isUnexported()) { // 导出服务  export(); } } 这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，这个需要大家注意一下。下面我们来看一下这个方法的逻辑。\n// -☆- ServiceBean private boolean isDelay() { // 获取 delay  Integer delay = getDelay(); ProviderConfig provider = getProvider(); if (delay == null \u0026amp;\u0026amp; provider !","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务查询和详情展示","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/search/","lvl3":10,"lvl4":"docs","lvl5":null,"objectID":"5ae124bb8df6a56c1774e7e1f1257f14","permalink":"/zh/docs/v2.7/admin/ops/search/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/search/","summary":"服务查询是 Dubbo OPS 最基本的功能，目前支持服务，应用和 IP 三个维度的查询，并且服务和应用支持模糊查询和自动提示:\n其中详情页展示了服务提供者，消费者等信息，元数据信息需要在 Dubbo 2.7 及之后的版本才会展示:","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务测试","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/test/","lvl3":1,"lvl4":"docs","lvl5":null,"objectID":"38e4ba774c877b57ce39868fc5645097","permalink":"/zh/docs/v2.7/admin/ops/test/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/test/","summary":"请参考这篇博客","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo 架构","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"架构","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/preface/architecture/","lvl3":58,"lvl4":"docs","lvl5":null,"objectID":"1bc6df295416e114a85dd7cae84cea43","permalink":"/zh/docs/v2.7/user/preface/architecture/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/preface/architecture/","summary":"节点角色说明    节点 角色说明     Provider 暴露服务的服务提供方   Consumer 调用远程服务的服务消费方   Registry 服务注册与发现的注册中心   Monitor 统计服务的调用次数和调用时间的监控中心   Container 服务运行容器    调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。  Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。\n连通性  注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者  健壮性  监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复  伸缩性  注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者  升级性 当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：\n节点角色说明    节点 角色说明     Deployer  自动部署服务的本地代理   Repository 仓库用于存储服务应用发布包   Scheduler 调度中心基于访问压力自动增减服务提供者   Admin 统一管理控制台   Registry 服务注册与发现的注册中心   Monitor 统计服务的调用次数和调用时间的监控中心    ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"注册中心参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/","lvl3":3,"lvl4":"docs","lvl5":null,"objectID":"dbde19022956537fe1d1ac8e50ea35bf","permalink":"/zh/docs/v2.7/user/references/registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/registry/","summary":"推荐使用 Zookeeper 注册中心","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"示例消费者安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/consumer-demo/","lvl3":22,"lvl4":"docs","lvl5":null,"objectID":"f33304df74f0a735ba1e03d01ad06398","permalink":"/zh/docs/v2.7/admin/install/consumer-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/consumer-demo/","summary":"安装:\ngit clone https://github.com/apache/dubbo.git cd dubbo/dubbo-demo/dubbo-demo-xml 运行 dubbo-demo-xml-consumer 中的 org.apache.dubbo.demo.consumer.Application 请确保先启动 Provider，如果使用 Intellij Idea 请加上 -Djava.net.preferIPv4Stack=true\n配置:\nresources/spring/dubbo-consumer.xml 修改其中的dubbo:registry，替换成Provider提供的注册中心地址, 如： \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"网站向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/website-guide_dev/","lvl3":10,"lvl4":"docs","lvl5":null,"objectID":"93c9066e30b71c454d92645f58531763","permalink":"/zh/docs/contribution-guidelines/committer/website-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/committer/website-guide_dev/","summary":" Apache Dubbo 的网站仓库是 https://github.com/apache/dubbo-website 网站构建完毕后，它会被自动发布到 dubbo.apache.org，您也可以通过 https://selfserve.apache.org 手动触发（需要使用 Apache 账号登陆）  ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Dubbo 提供的集群负载均衡策略","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"负载均衡","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/loadbalance/","lvl3":62,"lvl4":"docs","lvl5":null,"objectID":"a56289a268d75e46d15b529b841c8812","permalink":"/zh/docs/v2.7/user/examples/loadbalance/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/loadbalance/","summary":"在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。\n可以自行扩展负载均衡策略，参见：负载均衡扩展\n负载均衡策略 Random LoadBalance  随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。  RoundRobin LoadBalance  轮询，按公约后的权重设置轮询比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。  LeastActive LoadBalance  最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。  ConsistentHash LoadBalance  一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 算法参见：http://en.wikipedia.org/wiki/Consistent_hashing 缺省只对第一个参数 Hash，如果要修改，请配置 \u0026lt;dubbo:parameter key=\u0026quot;hash.arguments\u0026quot; value=\u0026quot;0,1\u0026quot; /\u0026gt; 缺省用 160 份虚拟节点，如果要修改，请配置 \u0026lt;dubbo:parameter key=\u0026quot;hash.nodes\u0026quot; value=\u0026quot;320\u0026quot; /\u0026gt;  配置 服务端服务级别 \u0026lt;dubbo:service interface=\u0026#34;...\u0026#34; loadbalance=\u0026#34;roundrobin\u0026#34; /\u0026gt; 客户端服务级别 \u0026lt;dubbo:reference interface=\u0026#34;...\u0026#34; loadbalance=\u0026#34;roundrobin\u0026#34; /\u0026gt; 服务端方法级别 \u0026lt;dubbo:service interface=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;...\u0026#34; loadbalance=\u0026#34;roundrobin\u0026#34;/\u0026gt; \u0026lt;/dubbo:service\u0026gt; 客户端方法级别 \u0026lt;dubbo:reference interface=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;...\u0026#34; loadbalance=\u0026#34;roundrobin\u0026#34;/\u0026gt; \u0026lt;/dubbo:reference\u0026gt; ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"邮件列表订阅向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","lvl3":202,"lvl4":"docs","lvl5":null,"objectID":"1ce93cc5e129f0d79e964af7bb985caa","permalink":"/zh/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/mailing-list-subscription-guide_dev/","summary":"Apache incubator 的 Dubbo 开发者邮件列表（dev@dubbo.apache.org）已经建立，请随时订阅并参考[^1]获取更多细节。\n你也可以直接查看历史邮件\n下面是一个关于 Dubbo 邮件列表订阅的简短指南：\n 发一封邮件到 dev-subscribe@dubbo.apache.org，其内容和标题均可为空。随后，您会收到一封邮件，其内容如下：  from: dev-help@dubbo.apache.org reply-to: dev-sc.xxxxxxx.xxxxxxxx-hello=example.com@dubbo.apache.org to: hello@example.com date: Sat, Feb 24, 2018 at 3:12 PM subject: confirm subscribe to dev@dubbo.apache.org mailed-by: apache.org Hi! This is the ezmlm program. I\u0026#39;m managing the dev@dubbo.apache.org mailing list. I\u0026#39;m working for my owner, who can be reached at dev-owner@dubbo.apache.org. To confirm that you would like hello@example.com added to the dev mailing list, please send a short reply to this address: dev-sc.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"给问题打标签","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","lvl3":30,"lvl4":"docs","lvl5":null,"objectID":"e74813424f208b44fa15095711138fef","permalink":"/zh/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/committer/label-an-issue-guide_dev/","summary":"如果您正在处理一个问题，请记得给这个问题标记一个或者多个您认为有意义的标签。有了标签，其他开发人员就会很轻松地识别出问题，以便对其进行分类并跟踪进度。\n对于需要编码和发版修复的 issues 和 pull requests，需要您将其标记为 milestone。\n一些常用的标签：\n 请求帮助  help wanted good first issue   优先级  priority/blocker priority/high priority/low priority/normal   状态  status/need-triage status/DO-NOT-MERGE status/READY-TO-MERGE status/invalid status/wontfix   类型  type/bug type/documentation type/enhancement type/feature    ","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"防痴呆设计","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/dummy/","lvl3":583,"lvl4":"docs","lvl5":null,"objectID":"22a69034fe5f223dfc1d3ae9fcc4f4c0","permalink":"/zh/docs/v2.7/dev/principals/dummy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/dev/principals/dummy/","summary":"http://javatar.iteye.com/blog/804187\n 最近有点痴呆，因为解决了太多的痴呆问题。服务框架实施面越来越广，已有 50 多个项目在使用，每天都要去帮应用查问题，来来回回，发现大部分都是配置错误，或者重复的文件或类，或者网络不通等，所以准备在新版本中加入防痴呆设计。估且这么叫吧，可能很简单，但对排错速度还是有点帮助，希望能抛砖引玉，也希望大家多给力，想出更多的防范措施共享出来。\n检查重复的jar包 最痴呆的问题，就是有多个版本的相同jar包，会出现新版本的 A 类，调用了旧版本的 B 类，而且和JVM加载顺序有关，问题带有偶然性，误导性，遇到这种莫名其妙的问题，最头疼，所以，第一条，先把它防住，在每个 jar 包中挑一个一定会加载的类，加上重复类检查，给个示例：\nstatic { Duplicate.checkDuplicate(Xxx.class); } 检查重复工具类：\npublic final class Duplicate { private Duplicate() {} public static void checkDuplicate(Class cls) { checkDuplicate(cls.getName().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + \u0026#34;.class\u0026#34;); } public static void checkDuplicate(String path) { try { // 在ClassPath搜文件  Enumeration urls = Thread.currentThread().getContextClassLoader().getResources(path); Set files = new HashSet(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); if (url != null) { String file = url.","text":null,"weight":3},{"authors":null,"date":-62135596800,"description":"Configure Dubbo with annotation","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Annotation Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/annotation/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"fce8b5cc1f9fcf94e8ed764827bc72d9","permalink":"/docs/v2.7/user/configuration/annotation/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/annotation/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"API Docs\u0026Test","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/apidocs/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"654b91e20ae37bf2c0f01a5f18ece175","permalink":"/docs/v2.7/admin/ops/apidocs/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/apidocs/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"API文档\u0026测试","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/apidocs/","lvl3":135,"lvl4":"docs","lvl5":null,"objectID":"654b91e20ae37bf2c0f01a5f18ece175","permalink":"/zh/docs/v2.7/admin/ops/apidocs/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/apidocs/","summary":"dubbo api docs dubbo 接口文档、测试工具,根据注解生成文档,并提供测试功能.\n增加一些注解就能生成类似swagger的文档, 不会把非web的dubbo项目变为web项目.\n相关仓库  dubbo-spi-extensions \\分支: 2.7.x\\dubbo-api-docs: Dubbo-Api-Docs 相关注解,解析注解 dubbo-admin: Dubbo-Api-Docs 文档展示,测试功能  如何使用?  dubbo项目的方法参数中加上 dubbo api docs 注解  dubbo提供者项目引入 dubbo-api-docs-core 如果dubbo的接口和参数是一个单独的jar包项目,引入dubbo-api-docs-annotations 在提供者项目的项目启动类(标注了@SpringBootApplication的类)或者配制类(标注了@Configuration的类)中增加注解 @EnableDubboApiDocs 以启用Dubbo Api Docs功能  为避免增加生产环境中的资源占用, 建议单独创建一个配制类用于启用Dubbo Api Docs, 并配合 @Profile(\u0026ldquo;dev\u0026rdquo;) 注解使用 当然, Dubbo Api Docs 仅在项目启动时多消耗了点CPU资源, 并使用了一点点内存用于缓存, 将来会考虑将缓存中的内容放到元数据中心.      当前版本: 同Dubbo版本号 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-api-docs-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-api-docs-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  下载 dubbo-admin 下载地址","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"install Zookeeper Configuration Center","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/zookeeper/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"5c572adc506a2bd0aa5e89a25fe5ef60","permalink":"/docs/v2.7/admin/install/zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/zookeeper/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Software Donation Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/software-donation-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"fd4b325fa2f034074ecd8bcaebbaf0ac","permalink":"/docs/contribution-guidelines/contributor/software-donation-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/software-donation-guide_dev/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"ExporterListener Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/exporter-listener/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7ebdf7432ea3833f5c03000c7bb75252","permalink":"/docs/v2.7/dev/impls/exporter-listener/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/exporter-listener/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Talk About Expansion Of Extension And Incremental Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/expansibility/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"525ef9d7cd49f18e9cb8a6eb1f76747f","permalink":"/docs/v2.7/dev/principals/expansibility/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/expansibility/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Governance And Configuration Management","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/governance/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"fcd76db42d12487f111d444786f70f55","permalink":"/docs/v2.7/admin/ops/governance/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/governance/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"References documentation for hessian protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"hessian protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/hessian/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e006b942d518b3bb2149585fb7cbdb6d","permalink":"/docs/v2.7/user/references/protocol/hessian/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/hessian/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"hessian:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"hessian 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/hessian/","lvl3":109,"lvl4":"docs","lvl5":null,"objectID":"e006b942d518b3bb2149585fb7cbdb6d","permalink":"/zh/docs/v2.7/user/references/protocol/hessian/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/hessian/","summary":"Hessian 1 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。\nDubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：\n 提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用 或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。  特性  连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：Hessian二进制序列化 适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。 适用场景：页面传输，文件传输，或与原生hessian服务互操作  依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.caucho\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hessian\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 约束  参数及返回值需实现 Serializable 接口 参数及返回值不能自定义实现 List, Map, Number, Date, Calendar 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。  配置 定义 hessian 协议：","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Dubbo implementation details","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Implementation details","lvl1":"docs","lvl2":"/docs/v2.7/dev/implementation/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"39c95a1f40c8091cf34d1fd90ed8f80e","permalink":"/docs/v2.7/dev/implementation/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/implementation/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Dubbo maturity report","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Maturity","lvl1":"docs","lvl2":"/docs/v2.7/user/maturity/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ad30e8d0a981eb49d61d4ef8e6970cca","permalink":"/docs/v2.7/user/maturity/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/maturity/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Protocol configurations in erlang","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Protocol Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/erlang/serialization/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7a2404c427251267644902cba8ab2a73","permalink":"/docs/v2.7/user/languages/erlang/serialization/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/erlang/serialization/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Redis 注册中心安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/redis/","lvl3":64,"lvl4":"docs","lvl5":null,"objectID":"36b629d716b6dd06a5e73af71c3c3e5e","permalink":"/zh/docs/v2.7/admin/install/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/redis/","summary":"Redis 1 使用方式参见: Redis 注册中心参考手册。\n只需搭一个原生的 Redis 服务器，并将快速启动中 Provider 和 Consumer 里的 conf/dubbo.properties 中的 dubbo.registry.address 的值改为 redis://127.0.0.1:6379 即可使用。\nRedis 注册中心集群 2 采用在客户端同时写入多个服务器，读取单个服务器的策略实现。\n安装:\nwget http://redis.googlecode.com/files/redis-2.4.8.tar.gz tar xzf redis-2.4.8.tar.gz cd redis-2.4.8 make 配置:\nvi redis.conf 启动:\nnohup ./src/redis-server redis.conf \u0026amp; 停止:\nkillall redis-server  命令行 3:  ./src/redis-cli hgetall /dubbo/com.foo.BarService/providers 或者：\ntelnet 127.0.0.1 6379 hgetall /dubbo/com.foo.BarService/providers   Redis 是一个高效的 KV 存储服务器，参见：http://redis.io/topics/quickstart \u0026#x21a9;\u0026#xfe0e;\n 2.1.0 以上版本支持 \u0026#x21a9;\u0026#xfe0e;\n 参见: http://redis.io/commands \u0026#x21a9;\u0026#xfe0e;","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"References documentation for redis protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"redis protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/redis/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a900dde4775a70588564dedba5925d8e","permalink":"/docs/v2.7/user/references/protocol/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/redis/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"redis:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"redis 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/redis/","lvl3":76,"lvl4":"docs","lvl5":null,"objectID":"a900dde4775a70588564dedba5925d8e","permalink":"/zh/docs/v2.7/user/references/protocol/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/redis/","summary":"基于 Redis 1 实现的 RPC 协议。\n提示 2.3.0 以上版本支持  注册 redis 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;redis://10.20.153.11/com.foo.BarService?category=providers\u0026amp;dynamic=false\u0026amp;application=foo\u0026amp;group=member\u0026amp;loadbalance=consistenthash\u0026#34;)); 在客户端引用 在客户端使用 2：\n\u0026lt;dubbo:reference id=\u0026#34;store\u0026#34; interface=\u0026#34;java.util.Map\u0026#34; group=\u0026#34;member\u0026#34; /\u0026gt; 或者，点对点直连：\n\u0026lt;dubbo:reference id=\u0026#34;store\u0026#34; interface=\u0026#34;java.util.Map\u0026#34; url=\u0026#34;redis://10.20.153.10:6379\u0026#34; /\u0026gt; 也可以使用自定义接口：\n\u0026lt;dubbo:reference id=\u0026#34;store\u0026#34; interface=\u0026#34;com.foo.StoreService\u0026#34; url=\u0026#34;redis://10.20.153.10:6379\u0026#34; /\u0026gt; 方法名建议和 redis 的标准方法名相同，即：get(key), set(key, value), delete(key)。\n如果方法名和 redis 的标准方法名不相同，则需要配置映射关系 3：\n\u0026lt;dubbo:reference id=\u0026#34;cache\u0026#34; interface=\u0026#34;com.foo.CacheService\u0026#34; url=\u0026#34;redis://10.20.153.10:6379\u0026#34; p:set=\u0026#34;putFoo\u0026#34; p:get=\u0026#34;getFoo\u0026#34; p:delete=\u0026#34;removeFoo\u0026#34; /\u0026gt;   Redis 是一个高效的 KV 存储服务器 \u0026#x21a9;\u0026#xfe0e;\n 不需要感知 Redis 的地址 \u0026#x21a9;\u0026#xfe0e;","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Install Redis Register Center","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/redis/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"36b629d716b6dd06a5e73af71c3c3e5e","permalink":"/docs/v2.7/admin/install/redis/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/redis/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Reporting Security Issues","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f9215185758e03e1e167bdd7bf01f12b","permalink":"/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Simple registry server for dubbo","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Simple Registry Server","lvl1":"docs","lvl2":"/docs/v2.7/user/references/registry/simple/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1c2c61ee7f944f750d8f4581b19fa4d0","permalink":"/docs/v2.7/user/references/registry/simple/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/registry/simple/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Simple 注册中心参考手册","dir":"docs/v2.7/user/references/registry/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Simple 注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/registry/simple/","lvl3":85,"lvl4":"docs","lvl5":null,"objectID":"1c2c61ee7f944f750d8f4581b19fa4d0","permalink":"/zh/docs/v2.7/user/references/registry/simple/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/registry/simple/","summary":"Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。\n配置 将 Simple 注册中心暴露成 Dubbo 服务：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;!-- 当前应用信息配置 --\u0026gt; \u0026lt;dubbo:application name=\u0026#34;simple-registry\u0026#34; /\u0026gt; \u0026lt;!-- 暴露服务协议配置 --\u0026gt; \u0026lt;dubbo:protocol port=\u0026#34;9090\u0026#34; /\u0026gt; \u0026lt;!-- 暴露服务配置 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.registry.RegistryService\u0026#34; ref=\u0026#34;registryService\u0026#34; registry=\u0026#34;N/A\u0026#34; ondisconnect=\u0026#34;disconnect\u0026#34; callbacks=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;subscribe\u0026#34;\u0026gt;\u0026lt;dubbo:argument index=\u0026#34;1\u0026#34; callback=\u0026#34;true\u0026#34; /\u0026gt;\u0026lt;/dubbo:method\u0026gt; \u0026lt;dubbo:method name=\u0026#34;unsubscribe\u0026#34;\u0026gt;\u0026lt;dubbo:argument index=\u0026#34;1\u0026#34; callback=\u0026#34;false\u0026#34; /\u0026gt;\u0026lt;/dubbo:method\u0026gt; \u0026lt;/dubbo:service\u0026gt; \u0026lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --\u0026gt; \u0026lt;bean id=\u0026#34;registryService\u0026#34; class=\u0026#34;org.apache.dubbo.registry.simple.SimpleRegistryService\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 引用 Simple Registry 服务：\n\u0026lt;dubbo:registry address=\u0026#34;127.0.0.1:9090\u0026#34; /\u0026gt; 或者：\n\u0026lt;dubbo:service interface=\u0026#34;org.","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Config thread pool model in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Thread Model","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/thread-model/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"bb72f01cbfe08e7985025def1e458677","permalink":"/docs/v2.7/user/examples/thread-model/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/thread-model/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"References documentation for thrift protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"thrift protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/thrift/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ded5acce109b97962616130f36835feb","permalink":"/docs/v2.7/user/references/protocol/thrift/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/thrift/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"thrift:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"thrift 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/thrift/","lvl3":62,"lvl4":"docs","lvl5":null,"objectID":"ded5acce109b97962616130f36835feb","permalink":"/zh/docs/v2.7/user/references/protocol/thrift/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/thrift/","summary":"当前 dubbo 支持的 thrift 协议是对 thrift 原生协议 1 的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。\n提示 2.3.0 以上版本支持  使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码，后续版本中会在这方面做一些增强。\n依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.thrift\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;libthrift\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置 所有服务共用一个端口 2：\n\u0026lt;dubbo:protocol name=\u0026#34;thrift\u0026#34; port=\u0026#34;3030\u0026#34; /\u0026gt; 使用 可以参考 dubbo 项目中的示例代码\n常见问题  Thrift 不支持 null 值，即：不能在协议中传递 null 值    Thrift 是 Facebook 捐给 Apache 的一个 RPC 框架 \u0026#x21a9;\u0026#xfe0e;\n 与原生Thrift不兼容 \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"First glance at dubbo","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Usage","lvl1":"docs","lvl2":"/docs/v2.7/user/preface/usage/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"19bf999255fd979227c762cc65caa573","permalink":"/docs/v2.7/user/preface/usage/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/preface/usage/","summary":"","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Zookeeper 注册中心安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/zookeeper/","lvl3":115,"lvl4":"docs","lvl5":null,"objectID":"5c572adc506a2bd0aa5e89a25fe5ef60","permalink":"/zh/docs/v2.7/admin/install/zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/zookeeper/","summary":"建议使用 dubbo-2.3.3 以上版本的 zookeeper 1 注册中心客户端。\nDubbo 未对 Zookeeper 服务器端做任何侵入修改，只需安装原生的 Zookeeper 服务器即可，所有注册中心逻辑适配都在调用 Zookeeper 客户端时完成。\n安装:\nwget http://archive.apache.org/dist/zookeeper/zookeeper-3.3.3/zookeeper-3.3.3.tar.gz tar zxvf zookeeper-3.3.3.tar.gz cd zookeeper-3.3.3 cp conf/zoo_sample.cfg conf/zoo.cfg 配置:\nvi conf/zoo.cfg 如果不需要集群，zoo.cfg 的内容如下 2：\ntickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 如果需要集群，zoo.cfg 的内容如下 3：\ntickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/dubbo/zookeeper-3.3.3/data clientPort=2181 server.1=10.20.153.10:2555:3555 server.2=10.20.153.11:2555:3555 并在 data 目录 4 下放置 myid 文件：\nmkdir data vi myid myid 指明自己的 id，对应上面 zoo.cfg 中 server. 后的数字，第一台的内容为 1，第二台的内容为 2，内容如下：\n1 启动:\n./bin/zkServer.sh start 停止:","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"报告安全问题","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","lvl3":27,"lvl4":"docs","lvl5":null,"objectID":"f9215185758e03e1e167bdd7bf01f12b","permalink":"/zh/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/reporting-security-issues_dev/","summary":"Apache Software Foundation 在消除其软件项目中的安全性问题方面采取严格的立场。Apache Dubbo 对与其功能和特性有关的问题非常敏感并很快提出。\n报告漏洞 如果您对 Dubbo 的安全性有担心，或者发现漏洞或潜在威胁，请发送电子邮件至 security@dubbo.apache.org 与 Apache Dubbo 安全团队联系。在邮件中，指定问题或潜在威胁的描述。还敦促您推荐重现和复制问题的方法。Dubbo 社区会在评估和分析调查结果之后与您联系。\n请先注意在安全电子邮件中报告安全问题，然后再在公共领域公开该问题。\n漏洞处理 漏洞处理过程的概述是：\n 报告者将漏洞秘密报告给 Apache。 相应项目的安全团队与报告者私下合作来解决漏洞。 制作了包含该修复程序的有关 Apache 产品的新版本。 该漏洞已公开宣布。  有关此过程的详细说明，请参见此处","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Dubbo 代码中的一些实现细节","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"实现细节","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/implementation/","lvl3":671,"lvl4":"docs","lvl5":null,"objectID":"39c95a1f40c8091cf34d1fd90ed8f80e","permalink":"/zh/docs/v2.7/dev/implementation/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/zh/docs/v2.7/dev/implementation/","summary":"初始化过程细节 解析服务 基于 dubbo.jar 内的 META-INF/spring.handlers 配置，Spring 在遇到 dubbo 名称空间时，会回调 DubboNamespaceHandler。\n所有 dubbo 的标签，都统一用 DubboBeanDefinitionParser 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。\n在 ServiceConfig.export() 或 ReferenceConfig.get() 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。\n然后将 URL 传给 协议扩展点，基于扩展点的 扩展点自适应机制，根据 URL 的协议头，进行不同协议的服务暴露或引用。\n暴露服务 1. 只暴露服务端口： 在没有注册中心，直接暴露提供者的情况下 1，ServiceConfig 解析出的 URL 的格式为： dubbo://service-host/com.foo.FooService?version=1.0.0。\n基于扩展点自适应机制，通过 URL 的 dubbo:// 协议头识别，直接调用 DubboProtocol的 export() 方法，打开服务端口。\n2. 向注册中心暴露服务： 在有注册中心，需要注册提供者地址的情况下 2，ServiceConfig 解析出的 URL 的格式为: registry://registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode(\u0026quot;dubbo://service-host/com.foo.FooService?version=1.0.0\u0026quot;)，\n基于扩展点自适应机制，通过 URL 的 registry:// 协议头识别，就会调用 RegistryProtocol 的 export() 方法，将 export 参数中的提供者 URL，先注册到注册中心。","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"在 erlang 中配置序列化方式","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"序列化配置项","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/erlang/serialization/","lvl3":29,"lvl4":"docs","lvl5":null,"objectID":"7a2404c427251267644902cba8ab2a73","permalink":"/zh/docs/v2.7/user/languages/erlang/serialization/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/languages/erlang/serialization/","summary":"当前该库只实现了 dubbo:// 通讯协议。\n序列化方式实现了 hessian 和 json 两种方式。\n配置样例 序列化配置需要添加到 sys.config 文件 dubboerl 应用配置项里。\n{dubboerl,[ %% other config ... \t{protocol,hessian} ]}    ConfigName Type DefaultValue Remarks     protocol atom() hessian hessian,json    ","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"介绍 Dubbo 各个功能、策略的成熟度","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"成熟度","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/maturity/","lvl3":380,"lvl4":"docs","lvl5":null,"objectID":"ad30e8d0a981eb49d61d4ef8e6970cca","permalink":"/zh/docs/v2.7/user/maturity/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/maturity/","summary":"功能成熟度    Feature Maturity Strength Problem Advise User     并发控制 Tested 并发控制  试用    连接控制 Tested 连接数控制  试用    直连提供者 Tested 点对点直连服务提供方，用于测试  测试环境使用 Alibaba   分组聚合 Tested 分组聚合返回值，用于菜单聚合等服务 特殊场景使用 可用于生产环境    参数验证 Tested 参数验证，JSR303验证框架集成 对性能有影响 试用 LaiWang   结果缓存 Tested 结果缓存，用于加速请求  试用    泛化引用 Stable 泛化调用，无需业务接口类进行远程调用，用于测试平台，开放网关桥接等  可用于生产环境 Alibaba   泛化实现 Stable 泛化实现，无需业务接口类实现任意接口，用于Mock平台  可用于生产环境 Alibaba   回声测试 Tested 回声测试  试用    隐式传参 Stable 附加参数  可用于生产环境    异步调用 Tested 不可靠异步调用  试用    本地调用 Tested 本地调用  试用    参数回调 Tested 参数回调 特殊场景使用 试用 Registry   事件通知 Tested 事件通知，在远程调用执行前后触发  试用    本地存根 Stable 在客户端执行部分逻辑  可用于生产环境 Alibaba   本地伪装 Stable 伪造返回结果，可在失败时执行，或直接执行，用于服务降级 需注册中心支持 可用于生产环境 Alibaba   延迟暴露 Stable 延迟暴露服务，用于等待应用加载warmup数据，或等待spring加载完成  可用于生产环境 Alibaba   延迟连接 Tested 延迟建立连接，调用时建立  试用 Registry   粘滞连接 Tested 粘滞连接，总是向同一个提供方发起请求，除非此提供方挂掉，再切换到另一台  试用 Registry   令牌验证 Tested 令牌验证，用于服务授权 需注册中心支持 试用    路由规则 Tested 动态决定调用关系 需注册中心支持 试用    配置规则 Tested 动态下发配置，实现功能的开关 需注册中心支持 试用    访问日志 Tested 访问日志，用于记录调用信息 本地存储，影响性能，受磁盘大小限制 试用    分布式事务 Research JTA/XA三阶段提交事务 不稳定 不可用     策略成熟度    Feature Maturity Strength Problem Advise User     Zookeeper注册中心 Stable 支持基于网络的集群方式，有广泛周边开源产品，建议使用dubbo-2.","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"软件捐献向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/software-donation-guide_dev/","lvl3":524,"lvl4":"docs","lvl5":null,"objectID":"fd4b325fa2f034074ecd8bcaebbaf0ac","permalink":"/zh/docs/contribution-guidelines/contributor/software-donation-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/contribution-guidelines/contributor/software-donation-guide_dev/","summary":"在您阅读这篇指南之前，请确保您已经向PMC确认了实际需要的 SGA。\n如果您向 Apache Dubbo 捐赠了大量的代码或文档，则需要在合并代码或者文档之前签署软件授权书。\n操作步骤  下载这篇pdf文档 打印下载好的文档 按要求填充表格（请看下边示例） 请您的领导在上边签字 扫描 将扫描好的文档以邮件的方式发送给secretary@apache.org，并抄送给private@dubbo.apache.org  示例 下边是一个文本示例，原始文本可以在这里找到\nLicense Agreement This License Agreement is entered into as of the _12th_ day of ___April____, __2018__ by ___ABC Software Co., Ltd.____ (\u0026#34;Licensor\u0026#34;), in favor of The Apache Software Foundation, a Delaware nonstock membership corporation (the \u0026#34;Foundation\u0026#34;). WHEREAS, Licensor owns or has sufficient rights to contribute the software source code and other related intellectual property as itemized on Exhibit A (\u0026#34;Software\u0026#34;) under the terms of this agreement to the Foundation for use within Foundation software development projects (\u0026#34;Projects\u0026#34;).","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"暴露监听扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/exporter-listener/","lvl3":72,"lvl4":"docs","lvl5":null,"objectID":"7ebdf7432ea3833f5c03000c7bb75252","permalink":"/zh/docs/v2.7/dev/impls/exporter-listener/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/exporter-listener/","summary":"扩展说明 当有服务暴露时，触发该事件。\n扩展接口 org.apache.dubbo.rpc.ExporterListener\n扩展配置 \u0026lt;!-- 暴露服务监听 --\u0026gt; \u0026lt;dubbo:service listener=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 暴露服务缺省监听器 --\u0026gt; \u0026lt;dubbo:provider listener=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展 org.apache.dubbo.registry.directory.RegistryExporterListener\n扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxExporterListener.java (实现ExporterListener接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ExporterListener (纯文本文件，内容为：xxx=com.xxx.XxxExporterListener) XxxExporterListener.java：\npackage com.xxx; import org.apache.dubbo.rpc.ExporterListener; import org.apache.dubbo.rpc.Exporter; import org.apache.dubbo.rpc.RpcException; public class XxxExporterListener implements ExporterListener { public void exported(Exporter\u0026lt;?\u0026gt; exporter) throws RpcException { // ...  } public void unexported(Exporter\u0026lt;?\u0026gt; exporter) throws RpcException { // ...  } } META-INF/dubbo/org.","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"本文介绍了 Dubbo 服务引用的过程和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":2900,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务引用","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/refer-service/","lvl3":2878,"lvl4":"docs","lvl5":null,"objectID":"996bf59b63526403c043914dd98dd1ad","permalink":"/zh/docs/v2.7/dev/source/refer-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":14,"relpermalink":"/zh/docs/v2.7/dev/source/refer-service/","summary":"1. 简介 上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。\n2.服务引用原理 Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 \u0026lt;dubbo:reference\u0026gt; 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直连方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。\n以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。\n3.源码分析 服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：\npublic Object getObject() throws Exception { return get(); } public synchronized T get() { if (destroyed) { throw new IllegalStateException(\u0026#34;Already destroyed!","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务治理和配置管理","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/governance/","lvl3":45,"lvl4":"docs","lvl5":null,"objectID":"fcd76db42d12487f111d444786f70f55","permalink":"/zh/docs/v2.7/admin/ops/governance/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/governance/","summary":"服务治理 服务治理主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，主要有以下几个功能：\n应用级别的服务治理 在 Dubbo 2.6 及更早版本中，所有的服务治理规则都只针对服务粒度，如果要把某条规则作用到应用粒度上，需要为应用下的所有服务配合相同的规则，变更，删除的时候也需要对应的操作，这样的操作很不友好，因此 Dubbo 2.7 版本中增加了应用粒度的服务治理操作，对于条件路由(包括黑白名单)，动态配置(包括权重，负载均衡)都可以做应用级别的配置：\n上图是条件路由的配置，可以按照应用名，服务名两个维度来填写，也可以按照这两个维度来查询。\n标签路由 标签路由是 Dubbo 2.7 引入的新功能，配置以应用作为维度，给不同的服务器打上不同名字的标签，配置如下图所示：\n调用的时候，客户端可以通过setAttachment的方式，来设置不同的标签名称，比如本例中，setAttachment(tag1)，客户端的选址范围就在如图所示的三台机器中，可以通过这种方式来实现流量隔离，灰度发布等功能。\n条件路由 条件路由是 Dubbo 一直以来就有的功能，目前可以配置服务和应用两个维度，条件路由为 yaml 格式，具体的规则体以及各种适用场景，请参考这里\n黑白名单 黑白名单是条件路由的一部分，规则存储和条件路由放在一起，为了方便配置所以单独拿出来，同样可以通过服务和应用两个维度，指定黑名单和白名单:\n动态配置 动态配置是和路由规则平行的另一类服务治理治理功能，主要作用是在不重启服务的情况下，动态改变调用行为，从Dubbo2.7版本开始，支持服务和应用两个维度的配置，采用yaml格式，界面如下：\n具体的规则体说明请参考这里\n权重调节 权重调节是动态配置的子功能，主要作用是改变服务端的权重，更大的权重会有更大的几率被客户端选中作为服务提供者，从而达到流量分配的目的：\n负载均衡 负载均衡也是动态配置的子功能，主要作用是调整客户端的选址逻辑，目前可选的负载均衡策略有随机，轮训和最小活跃，关于各个策略的解释请参考这里\n配置管理 配置管理也是配合Dubbo2.7新增的功能，在Dubbo2.7中，增加了全局和应用维度的配置，分别在全局和应用范围内生效，其中应用配置也可以指定该应用中的服务级别的配置，可以在控制台中查看，修改配置规则，默认展示全局维度的配置。\n  全局配置：\n全局配置里可以指定注册中心，元数据中心的地址，服务端和客户端的超时时间等，这些配置在全局内生效。除了配置写入，也可以用来查看。如果使用zookeeper作为注册中心和元数据中心，还可以看到配置文件所在位置的目录结构。\n  应用， 服务配置\n应用级别的配置可以为应用或者应用内的服务指定配置，在服务维度上，需要区分提供者和消费者。dubbo.reference.{serviceName}表示作为该服务消费者的配置，dubbo.provider.{servcieName}表示作为该服务提供者的配置。其中注册中心和元数据中心的地址，只能在全局配置中指定，这也是Dubbo2.7中推荐的使用方式。\n  优先级： 服务配置 \u0026gt; 应用配置 \u0026gt; 全局配置\n  ","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"以注解配置的方式来配置你的 Dubbo 应用","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"注解配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/annotation/","lvl3":115,"lvl4":"docs","lvl5":null,"objectID":"fce8b5cc1f9fcf94e8ed764827bc72d9","permalink":"/zh/docs/v2.7/user/configuration/annotation/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/annotation/","summary":"提示 需要 2.6.3 及以上版本支持。 点此查看 完整示例  服务提供方 Service注解暴露服务 @Service public class AnnotationServiceImpl implements AnnotationService { @Override public String sayHello(String name) { return \u0026#34;annotation: hello, \u0026#34; + name; } } 增加应用共享配置 # dubbo-provider.properties dubbo.application.name=annotation-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.name=dubbo dubbo.protocol.port=20880 指定Spring扫描路径 @Configuration @EnableDubbo(scanBasePackages = \u0026#34;org.apache.dubbo.samples.simple.annotation.impl\u0026#34;) @PropertySource(\u0026#34;classpath:/spring/dubbo-provider.properties\u0026#34;) static public class ProviderConfiguration { } 服务消费方 Reference注解引用服务 @Component(\u0026#34;annotationAction\u0026#34;) public class AnnotationAction { @Reference private AnnotationService annotationService; public String doSayHello(String name) { return annotationService.sayHello(name); } } 增加应用共享配置 # dubbo-consumer.","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"Dubbo 的简单实用入门","dir":"docs/v2.7/user/preface/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"用法","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/preface/usage/","lvl3":62,"lvl4":"docs","lvl5":null,"objectID":"19bf999255fd979227c762cc65caa573","permalink":"/zh/docs/v2.7/user/preface/usage/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/preface/usage/","summary":"本地服务 Spring 配置 local.xml:\n\u0026lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /\u0026gt; \u0026lt;bean id=“xxxAction” class=“com.xxx.XxxAction”\u0026gt; \u0026lt;property name=“xxxService” ref=“xxxService” /\u0026gt; \u0026lt;/bean\u0026gt; 远程服务 Spring 配置 在本地服务的基础上，只需做简单配置，即可完成远程化：\n 将上面的 local.xml 配置拆分成两份，将服务定义部分放在服务提供方 remote-provider.xml，将服务引用部分放在服务消费方 remote-consumer.xml。 并在提供方增加暴露服务配置 \u0026lt;dubbo:service\u0026gt;，在消费方增加引用服务配置 \u0026lt;dubbo:reference\u0026gt;。  remote-provider.xml:\n\u0026lt;!-- 和本地服务一样实现远程服务 --\u0026gt; \u0026lt;bean id=“xxxService” class=“com.xxx.XxxServiceImpl” /\u0026gt; \u0026lt;!-- 增加暴露远程服务配置 --\u0026gt; \u0026lt;dubbo:service interface=“com.xxx.XxxService” ref=“xxxService” /\u0026gt; remote-consumer.xml:\n\u0026lt;!-- 增加引用远程服务配置 --\u0026gt; \u0026lt;dubbo:reference id=“xxxService” interface=“com.xxx.XxxService” /\u0026gt; \u0026lt;!-- 和本地服务一样使用远程服务 --\u0026gt; \u0026lt;bean id=“xxxAction” class=“com.xxx.XxxAction”\u0026gt; \u0026lt;property name=“xxxService” ref=“xxxService” /\u0026gt; \u0026lt;/bean\u0026gt; ","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"配置 Dubbo 中的线程模型","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"线程模型","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/thread-model/","lvl3":50,"lvl4":"docs","lvl5":null,"objectID":"bb72f01cbfe08e7985025def1e458677","permalink":"/zh/docs/v2.7/user/examples/thread-model/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/thread-model/","summary":"如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。\n但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。\n如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。\n因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; dispatcher=\u0026#34;all\u0026#34; threadpool=\u0026#34;fixed\u0026#34; threads=\u0026#34;100\u0026#34; /\u0026gt; Dispatcher\n all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。 direct 所有消息都不派发到线程池，全部在 IO 线程上直接执行。 message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 execution 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。 connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。  ThreadPool\n fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省) cached 缓存线程池，空闲一分钟自动删除，需要时重建。 limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。 eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)  ","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"谈谈扩充式扩展与增量式扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/expansibility/","lvl3":91,"lvl4":"docs","lvl5":null,"objectID":"525ef9d7cd49f18e9cb8a6eb1f76747f","permalink":"/zh/docs/v2.7/dev/principals/expansibility/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/expansibility/","summary":"http://javatar.iteye.com/blog/690845\n 我们平台的产品越来越多，产品的功能也越来越多。平台的产品为了适应各 BU 和部门以及产品线的需求，势必会将很多不相干的功能凑在一起，客户可以选择性的使用。为了兼容更多的需求，每个产品，每个框架，都在不停的扩展，而我们经常会选择一些扩展的扩展方式，也就是将新旧功能扩展成一个通用实现。我想讨论是，有些情况下也可以考虑增量式的扩展方式，也就是保留原功能的简单性，新功能独立实现。我最近一直做分布式服务框架的开发，就拿我们项目中的问题开涮吧。\n比如：远程调用框架，肯定少不了序列化功能，功能很简单，就是把流转成对象，对象转成流。但因有些地方可能会使用 osgi，这样序列化时，IO 所在的 ClassLoader 可能和业务方的 ClassLoader 是隔离的。需要将流转换成 byte[] 数组，然后传给业务方的 ClassLoader 进行序列化。为了适应 osgi 需求，把原来非 osgi 与 osgi 的场景扩展了一下，这样，不管是不是 osgi 环境，都先将流转成 byte[] 数组，拷贝一次。然而，大部分场景都用不上 osgi，却为 osgi 付出了代价。而如果采用增量式扩展方式，非 osgi 的代码原封不动，再加一个 osgi 的实现，要用 osgi 的时候，直接依赖 osgi 实现即可。\n再比如：最开始，远程服务都是基于接口方法，进行透明化调用的。这样，扩展接口就是， invoke(Method method, Object[] args)，后来，有了无接口调用的需求，就是没有接口方法也能调用，并将 POJO 对象都转换成 Map 表示。因为 Method 对象是不能直接 new 出来的，我们不自觉选了一个扩展式扩展，把扩展接口改成了 invoke(String methodName, String[] parameterTypes, String returnTypes, Object[] args)，导致不管是不是无接口调用，都得把 parameterTypes 从 Class[] 转成 String[]。如果选用增量式扩展，应该是保持原有接口不变，增加一个 GeneralService 接口，里面有一个通用的 invoke() 方法，和其它正常业务上的接口一样的调用方式，扩展接口也不用变，只是 GeneralServiceImpl 的 invoke() 实现会将收到的调用转给目标接口，这样就能将新功能增量到旧功能上，并保持原来结构的简单性。","text":null,"weight":4},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Cluster Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/cluster/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f6f2738a49a60a2974c7d23cca3c9dff","permalink":"/docs/v2.7/dev/impls/cluster/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/cluster/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Learn about dubbo configuration","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Configuration","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a40a9a41ef31a10857dcb86362b84aae","permalink":"/docs/v2.7/user/configuration/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo design principals collections","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Design Principals","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d0c90adc96d31acf740c2f38078c3e7b","permalink":"/docs/v2.7/dev/principals/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Extension Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"411fef6b2bbee39fde28ae2279d1796a","permalink":"/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Specify explicit target in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Explicit Target","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/explicit-target/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"019690c57b641bd4079147c928e8d16c","permalink":"/docs/v2.7/user/examples/explicit-target/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/explicit-target/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Extension Points To Reconstruct","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/extension/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"53afa63b5d7460e0b0fdb2a07dc0236e","permalink":"/docs/v2.7/dev/principals/extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/extension/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"grpc:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"gRPC 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/grpc/","lvl3":48,"lvl4":"docs","lvl5":null,"objectID":"2efbff57308f50fb41069535cc6d0cb9","permalink":"/zh/docs/v2.7/user/references/protocol/grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/grpc/","summary":"Dubbo 自 2.7.5 版本开始支持 gRPC 协议，对于计划使用 HTTP/2 通信，或者想利用 gRPC 带来的 Stream、反压、Reactive 编程等能力的开发者来说， 都可以考虑启用 gRPC 协议。\n支持 gRPC 的好处  为期望使用 gRPC 协议的用户带来服务治理能力，方便接入 Dubbo 体系 用户可以使用 Dubbo 风格的，基于接口的编程风格来定义和使用远程服务  如何在 Dubbo 中使用 gRPC 大概需要以下步骤：\n 使用 IDL 定义服务 配置 compiler 插件，本地预编译 配置暴露/引用 Dubbo 服务  具体可参见以下示例\n除了原生 StreamObserver 接口类型之外，Dubbo 还支持 RxJava、Reactor 编程风格的 API","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Loading process for dubbo configuration","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Configuration Loading Process","lvl1":"docs","lvl2":"/docs/v2.7/user/configuration/configuration-load-process/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"18eed20c7ee4127ec93830039b3c04e0","permalink":"/docs/v2.7/user/configuration/configuration-load-process/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/configuration/configuration-load-process/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"References documentation for memcached protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"memcached protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/memcached/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1434fffc976ec15990c5105c50f14711","permalink":"/docs/v2.7/user/references/protocol/memcached/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/memcached/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"memcached:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"memcached 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/memcached/","lvl3":76,"lvl4":"docs","lvl5":null,"objectID":"1434fffc976ec15990c5105c50f14711","permalink":"/zh/docs/v2.7/user/references/protocol/memcached/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/memcached/","summary":"基于 memcached 1 实现的 RPC 协议。\n提示 2.3.0 以上版本支持  注册 memcached 服务的地址 RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;memcached://10.20.153.11/com.foo.BarService?category=providers\u0026amp;dynamic=false\u0026amp;application=foo\u0026amp;group=member\u0026amp;loadbalance=consistenthash\u0026#34;)); 在客户端引用 在客户端使用 2：\n\u0026lt;dubbo:reference id=\u0026#34;cache\u0026#34; interface=\u0026#34;java.util.Map\u0026#34; group=\u0026#34;member\u0026#34; /\u0026gt; 或者，点对点直连：\n\u0026lt;dubbo:reference id=\u0026#34;cache\u0026#34; interface=\u0026#34;java.util.Map\u0026#34; url=\u0026#34;memcached://10.20.153.10:11211\u0026#34; /\u0026gt; 也可以使用自定义接口：\n\u0026lt;dubbo:reference id=\u0026#34;cache\u0026#34; interface=\u0026#34;com.foo.CacheService\u0026#34; url=\u0026#34;memcached://10.20.153.10:11211\u0026#34; /\u0026gt; 方法名建议和 memcached 的标准方法名相同，即：get(key), set(key, value), delete(key)。\n如果方法名和 memcached 的标准方法名不相同，则需要配置映射关系 3：\n\u0026lt;dubbo:reference id=\u0026#34;cache\u0026#34; interface=\u0026#34;com.foo.CacheService\u0026#34; url=\u0026#34;memcached://10.20.153.10:11211\u0026#34; p:set=\u0026#34;putFoo\u0026#34; p:get=\u0026#34;getFoo\u0026#34; p:delete=\u0026#34;removeFoo\u0026#34; /\u0026gt;   Memcached 是一个高效的 KV 缓存服务器 \u0026#x21a9;\u0026#xfe0e;\n 不需要感知 Memcached 的地址 \u0026#x21a9;\u0026#xfe0e;","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"References documentation for dubbo metadata","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Metadata Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/metadata/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"444ae7d6595320970602ea176af7e1d1","permalink":"/docs/v2.7/user/references/metadata/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/metadata/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Install Simple monitor center","lvl1":"docs","lvl2":"/docs/v2.7/admin/install/monitor-center/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"81ee023d69b60bdd0c1f79a47ed36d4c","permalink":"/docs/v2.7/admin/install/monitor-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/install/monitor-center/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Apache Official Dubbo Page Maintenance","lvl1":"docs","lvl2":"/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4103effd0f4e539389a094f45368c0aa","permalink":"/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Tracking with Pinpoint","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/pinpoint/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"16a66575811fa97007126567d30cc8b1","permalink":"/docs/v2.7/admin/ops/pinpoint/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/pinpoint/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"References documentation for rmi protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"rmi protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/rmi/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"9dda729f6faeae52266080b1c82061e5","permalink":"/docs/v2.7/user/references/protocol/rmi/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/rmi/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"rmi:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"rmi 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/rmi/","lvl3":143,"lvl4":"docs","lvl5":null,"objectID":"9dda729f6faeae52266080b1c82061e5","permalink":"/zh/docs/v2.7/user/references/protocol/rmi/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/rmi/","summary":"RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。\n注意：如果正在使用 RMI 提供服务给外部访问 1，同时应用里依赖了老的 common-collections 包 2 的情况下，存在反序列化安全风险 3。\n特性  连接个数：多连接 连接方式：短连接 传输协议：TCP 传输方式：同步传输 序列化：Java 标准二进制序列化 适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。 适用场景：常规远程服务方法调用，与原生RMI服务互操作  约束  参数及返回值需实现 Serializable 接口 dubbo 配置中的超时时间对 RMI 无效，需使用 java 启动参数设置：-Dsun.rmi.transport.tcp.responseTimeout=3000，参见下面的 RMI 配置  dubbo.properties 配置 dubbo.service.protocol=rmi RMI配置 java -Dsun.rmi.transport.tcp.responseTimeout=3000 更多 RMI 优化参数请查看 JDK 文档\n接口 如果服务接口继承了 java.rmi.Remote 接口，可以和原生 RMI 互操作，即：\n 提供者用 Dubbo 的 RMI 协议暴露服务，消费者直接用标准 RMI 接口调用， 或者提供方用标准 RMI 暴露服务，消费方用 Dubbo 的 RMI 协议调用。  如果服务接口没有继承 java.","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/install/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Simple 监控中心安装","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/install/monitor-center/","lvl3":1,"lvl4":"docs","lvl5":null,"objectID":"81ee023d69b60bdd0c1f79a47ed36d4c","permalink":"/zh/docs/v2.7/admin/install/monitor-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/install/monitor-center/","summary":"不再单独提供监控中心，功能会整合到运维控制台，基于Metrics提供更丰富，实时的信息展示，敬请期待","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Tracing Dubbo service with Apache Skywalking","lvl1":"docs","lvl2":"/docs/v2.7/admin/ops/skywalking/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1d57c1713897c14c9610d3d92492a333","permalink":"/docs/v2.7/admin/ops/skywalking/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/ops/skywalking/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Existing SPI extension implementations in dubbo","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"SPI Extension Implementations","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"132f3441217b7d2100deb6ced16b6cd9","permalink":"/docs/v2.7/dev/impls/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo 中已经实现的扩展","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"SPI 扩展实现","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/","lvl3":4,"lvl4":"docs","lvl5":null,"objectID":"132f3441217b7d2100deb6ced16b6cd9","permalink":"/zh/docs/v2.7/dev/impls/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/","summary":"SPI 扩展接口仅用于系统集成，或 Contributor 扩展功能插件。","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"References documentation for webservice protocol","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"webservice protocol","lvl1":"docs","lvl2":"/docs/v2.7/user/references/protocol/webservice/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d8c9b3425f6b5080b0d07cb01d33da64","permalink":"/docs/v2.7/user/references/protocol/webservice/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/protocol/webservice/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"webservice:// 协议参考手册","dir":"docs/v2.7/user/references/protocol/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"webservice 协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/protocol/webservice/","lvl3":144,"lvl4":"docs","lvl5":null,"objectID":"d8c9b3425f6b5080b0d07cb01d33da64","permalink":"/zh/docs/v2.7/user/references/protocol/webservice/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/protocol/webservice/","summary":"基于 WebService 的远程调用协议，基于 Apache CXF 1 的 frontend-simple 和 transports-http 实现。\n提示 2.3.0 以上版本支持  可以和原生 WebService 服务互操作，即：\n 提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用， 或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。  依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.cxf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cxf-rt-frontend-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.cxf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cxf-rt-transports-http\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 特性  连接个数：多连接 连接方式：短连接 传输协议：HTTP 传输方式：同步传输 序列化：SOAP 文本序列化 适用场景：系统集成，跨语言调用  约束  参数及返回值需实现 Serializable 接口 参数尽量使用基本类型和 POJO  配置 配置协议：\n\u0026lt;dubbo:protocol name=\u0026#34;webservice\u0026#34; port=\u0026#34;8080\u0026#34; server=\u0026#34;jetty\u0026#34; /\u0026gt; 配置默认协议：","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用 Apache Skywalking 做分布式跟踪","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/skywalking/","lvl3":213,"lvl4":"docs","lvl5":null,"objectID":"1d57c1713897c14c9610d3d92492a333","permalink":"/zh/docs/v2.7/admin/ops/skywalking/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/admin/ops/skywalking/","summary":"Apache Skywalking 简介 Apache Skywalking 专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。Apache Skywalking 通过加载探针的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。Apache Skywalking 目前支持多种语言，其中包括 Java，.Net Core，Node.js 和 Go 语言。\n目前 Skywalking 已经支持从 6 个可视化维度剖析分布式系统的运行情况。总览视图是应用和组件的全局视图，其中包括组件和应用数量，应用的告警波动，慢服务列表以及应用吞吐量；拓扑图从应用依赖关系出发，展现整个应用的拓扑关系；应用视图则是从单个应用的角度，展现应用的上下游关系，TopN 的服务和服务器，JVM 的相关信息以及对应的主机信息。服务视图关注单个服务入口的运行情况以及此服务的上下游依赖关系，依赖度，帮助用户针对单个服务的优化和监控；调用链展现了调用的单次请求经过的所有埋点以及每个埋点的执行时长；告警视图根据配置阈值针对应用、服务器、服务进行实时告警。\nDubbo 与 Apache Skywalking 编写 Dubbo 示例程序 Dubbo 实例程序已上传到 Github 仓库中。方便大家下载使用。\nAPI 工程 服务接口：\npackage org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); } Dubbo 服务提供工程 package org.apache.skywalking.demo.provider; @Service(version = \u0026#34;${demo.service.version}\u0026#34;, application = \u0026#34;${dubbo.application.id}\u0026#34;, protocol = \u0026#34;${dubbo.protocol.id}\u0026#34;, registry = \u0026#34;${dubbo.registry.id}\u0026#34;, timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/admin/ops/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用 Pinpoint 做分布式跟踪","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/ops/pinpoint/","lvl3":595,"lvl4":"docs","lvl5":null,"objectID":"16a66575811fa97007126567d30cc8b1","permalink":"/zh/docs/v2.7/admin/ops/pinpoint/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/admin/ops/pinpoint/","summary":"在使用 Dubbo 进行服务化或者整合应用后，假设某个服务后台日志显示有异常，这个服务又被多个应用调用的情况下，我们通常很难判断是哪个应用调用的，问题的起因是什么，因此我们需要一套分布式跟踪系统来快速定位问题，Pinpoint 可以帮助我们快速定位问题（当然，解决方案也不止这一种）。\n什么是 Pinpoint  摘自 Pinpoint 学习笔记\n Pinpoint 是一个开源的 APM (Application Performance Management/应用性能管理)工具，用于基于java的大规模分布式系统。\n仿照 Google Dapper，Pinpoint 通过跟踪分布式应用之间的调用来提供解决方案，以帮助分析系统的总体结构和内部模块之间如何相互联系。\n 注：对于各个模块之间的通讯英文原文中用的是transaction一词，但是我觉得如果翻译为\u0026quot;事务\u0026quot;容易引起误解，所以替换为\u0026quot;交互\u0026quot;或者\u0026quot;调用\u0026quot;这种比较直白的字眼。\n 在使用上力图简单高效：\n 安装 agent，不需要修改哪怕一行代码 最小化性能损失  服务器地图(ServerMap) 通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。\n实时活动线程图表(Realtime Active Thread Chart) 实时监控应用内部的活动线程。\n请求/应答分布图表(Request/Response Scatter Chart) 长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看更多的详细信息。\n调用栈(CallStack) 在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。\n巡查(Inspector) 查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。\n支持模块  JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo 服务元数据参考手册","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"元数据参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/metadata/","lvl3":519,"lvl4":"docs","lvl5":null,"objectID":"444ae7d6595320970602ea176af7e1d1","permalink":"/zh/docs/v2.7/user/references/metadata/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/user/references/metadata/","summary":"背景 dubbo provider中的服务配置项有接近30个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是provider自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以key-value形式持久化存储。 dubbo consumer中的配置项也有20+个配置项。在注册中心之中，服务消费者列表中只需要关注application，version，group，ip，dubbo版本等少量配置，其他配置也可以以key-value形式持久化存储。 这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如zookeeper)的网络开销增大，性能降低。\n除了上述配置项的存储之外，dubbo服务元数据信息也需要被存储下来。元数据信息包括服务接口，及接口的方法信息。这些信息将被用于服务mock，服务测试。\n目标 需要将注册中心原来的数据信息和元数据信息保存到独立的key-value的存储中，这个key-value可以是DB，redis或者其他持久化存储。核心代码中支持了zookeeper，redis(推荐)的默认支持。\nprovider存储内容的格式，参见：org.apache.dubbo.metadata.definition.model.FullServiceDefinition。是该类型gson化之后的存储。 Consumer存储内容，为Map格式。从Consumer端注册到注册中心的URL中的获取参数信息。即通过URL.getParameterMap()获取到的Map，进行gson化之后进行存储。\n详细的内容，可以参考下面的sample输出。\n配置 默认的元数据存储，额外支持以下几个特性：\n 失败重试 每天定时重刷  失败重试 失败重试可以通过retrytimes （重试次数,默认100），retryperiod（重试周期，默认3000ms）进行设置。\n定时刷新 默认开启，可以通过设置cycleReport=false进行关闭。\n完整的配置项： dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.username=xxx ##非必须 dubbo.metadata-report.password=xxx ##非必须 dubbo.metadata-report.retry-times=30 ##非必须,default值100 dubbo.metadata-report.retry-period=5000 ##非必须,default值3000 dubbo.metadata-report.cycle-report=false ##非必须,default值true  如果元数据地址(dubbo.metadata-report.address)也不进行配置，整个元数据的写入不会生效，但是不影响程序运行。\n 接下来看几个sample的配置。无论哪种配置方式，都需要引入maven依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-metadata-report-zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 如果需要使用redis，可以引入对应的redis的依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-metadata-report-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  完整的sample，查看sample-2.7\n 方式一：在配置中心配置 参考sample：dubbo-samples-metadata-report/dubbo-samples-metadata-report-configcenter 工程。\n配置中心配置 配置中心的配置，可以参考configcenter的文档。配置的内容如下：\ndubbo.registry.address=zookeeper://127.0.0.1:2181 ### 注意驼峰式风格 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 ###元数据存储的地址 在sample中，使用了Zookeeper作为配置中心。启动本地zookeeper服务之后，直接运行：org.apache.dubbo.samples.metadatareport.configcenter.ZKTools 就可以完成写入。 如果配置中心使用了nacos，apollo，这些产品本身支持ops配置。\n应用配置 ###dubbo.properties dubbo.config-center.address=zookeeper://127.0.0.1:2181 ... 完成上述两步之后，注册中心地址、元数据地址将从配置中心进行获取。现在可以依次运行Provider类和Consumer类，会在console中得到对应的输出或者直接通过zookeeper的cli查看。","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/committer/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"官方 Dubbo 主页的维护","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","lvl3":60,"lvl4":"docs","lvl5":null,"objectID":"4103effd0f4e539389a094f45368c0aa","permalink":"/zh/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/committer/apache-dubbo-page_dev/","summary":"Apache 有一个官方的网站，用来维护所有的孵化项目的信息。每一个孵化项目在这个网站下都有一个信息页。 Dubbo 的信息页地址是 https://incubator.apache.org/projects/dubbo.html。\n当项目发生比较大的变化，比如新的 committer 的加入，新的 PMC 的当选，或是新版本的 Release 等，都需要将这些更新信息维护到这个页面。\n这个官方网站的项目地址是https://svn.apache.org/repos/asf/incubator/public/trunk。\n维护这个页面的方法如下：\n1.安装 SVN。若是 Mac OS X 系统或是 Linux 系统，则自带了 SVN。若是 Windows 系统，则请首先自行安装 SVN。\n2.用 SVN 将这个项目 checkout 下来 。\n3.修改 content/projects/dubbo.xml 文件，并保存。\n4.安装 ANT。执行 trunk 目录下的 build.sh 或者 build.bat 脚本构建项目。\n5.构建完成后，可以用浏览器打开 target/site/projects/dubbo.html 文件，预览修改是否生效。\n6.用 SVN 的 commit 命令将 dubbo.xml 文件提交到服务器，并且不要提交 dubbo.html 文件（因为服务器端会定时自动构建）。 此过程会要求输入Apache id和密码。\n参考:\n http://incubator.apache.org/guides/website.html https://svn.apache.org/repos/asf/incubator/public/trunk/README.txt  ","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"扩展 Dubbo 向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","lvl3":59,"lvl4":"docs","lvl5":null,"objectID":"411fef6b2bbee39fde28ae2279d1796a","permalink":"/zh/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/dubbo-extension-guide_dev/","summary":"Dubbo 使用微内核+插件的设计模式。内核只负责组装插件，Dubbo 的功能都是由扩展点（插件）实现，这就意味着 Dubbo 的所有功能都可以被用户定制的扩展所替代。\nDubbo 生态系统 我们建议您将扩展加入到 Dubbo 生态系统。使用这种模式，可以使 Dubbo 的核心仓库更干净，并且可以减少维护工作。更少的代码也可以提高核心仓库的构建速度。\n依赖 要实现您自己的 Dubbo 扩展，通常只需依赖 API jar 就可以满足您的需求。例如：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-serialization-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Src指导 通常，要实现特殊的扩展，只需要参考开发者指南，实现Dubbo必要的接口和合适的扩展即可。除此之外，还有一些其它的事项需要注意：\n 良好的测试，您需要编写单元测试和冒烟测试以消除潜在的 bug。 没有警告，如有不可避免的警告，请使用 @SuppressWarnings 阻止它，但是请不要乱用。 README。添加必要的自述以说明如何使用扩展，以及需要注意的事项。 许可证：请确保使用Apache License 2.0。  通知社区  提交您的代码到 github。 加入邮件列表（建议）。点击这里查看如何加入邮件列表。 发送一封邮件到 dev@incubator.dubbo.apache.org 通知社区。 通常，发送邮件之后，社区会对您的扩展进行讨论，dubbo 组的管理员会联系您转移您的项目到 dubbo 生态系统。  转移项目到dubbo生态系统  dubbo 组的管理员会请您将您的项目的所有者转让给 dubbo。 dubbo 组的管理员会在 dubbo 组下新建一个项目并邀请您加入到这个项目。 一旦您接受邀请，您可以将您的项目转移到 dubbo 组下的新项目里。 dubbo 组的成员会对您的项目进行代码审查。随后，您可以对这些代码进行改进。  ","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"扩展点重构","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/extension/","lvl3":241,"lvl4":"docs","lvl5":null,"objectID":"53afa63b5d7460e0b0fdb2a07dc0236e","permalink":"/zh/docs/v2.7/dev/principals/extension/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/dev/principals/extension/","summary":"http://javatar.iteye.com/blog/1041832\n 随着服务化的推广，网站对Dubbo服务框架的需求逐渐增多，Dubbo 的现有开发人员能实现的需求有限，很多需求都被 delay，而网站的同学也希望参与进来，加上领域的推动，所以平台计划将部分项目对公司内部开放，让大家一起来实现，Dubbo 为试点项目之一。\n既然要开放，那 Dubbo 就要留一些扩展点，让参与者尽量黑盒扩展，而不是白盒的修改代码，否则分支，质量，合并，冲突都会很难管理。\n先看一下 Dubbo 现有的设计：\n这里面虽然有部分扩展接口，但并不能很好的协作，而且扩展点的加载和配置都没有统一处理，所以下面对它进行重构。\n第一步，微核心，插件式，平等对待第三方 即然要扩展，扩展点的加载方式，首先要统一，微核心+插件式，是比较能达到 OCP 原则的思路。\n由一个插件生命周期管理容器，构成微核心，核心不包括任何功能，这样可以确保所有功能都能被替换，并且，框架作者能做到的功能，扩展者也一定要能做到，以保证平等对待第三方，所以，框架自身的功能也要用插件的方式实现，不能有任何硬编码。\n通常微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。考虑 Dubbo 的适用面，不想强依赖 Spring 等 IoC 容器。自已造一个小的 IoC 容器，也觉得有点过度设计，所以打算采用最简单的 Factory 方式管理插件。\n最终决定采用的是 JDK 标准的 SPI 扩展机制，参见：java.util.ServiceLoader ，也就是扩展者在 jar 包的 META-INF/services/ 目录下放置与接口同名的文本文件，内容为接口实现类名，多个实现类名用换行符分隔。比如，需要扩展 Dubbo 的协议，只需在 xxx.jar 中放置文件：META-INF/services/org.apache.dubbo.rpc.Protocol，内容为 com.alibaba.xxx.XxxProtocol。Dubbo 通过 ServiceLoader 扫描到所有 Protocol 实现。\n并约定所有插件，都必须标注：@Extension(\u0026quot;name\u0026quot;)，作为加载后的标识性名称，用于配置选择。\n第二步，每个扩展点只封装一个变化因子，最大化复用 每个扩展点的实现者，往往都只是关心一件事，现在的扩展点，并没有完全分离。比如：Failover, Route, LoadBalance, Directory 没有完全分开，全由 RoutingInvokerGroup 写死了。\n再比如，协议扩展，扩展者可能只是想替换序列化方式，或者只替换传输方式，并且 Remoting 和 Http 也能复用序列化等实现。这样，需为传输方式，客户端实现，服务器端实现，协议头解析，数据序列化，都留出不同扩展点。\n拆分后，设计如下：\n第三步，全管道式设计，框架自身逻辑，均使用截面拦截实现 现在很多的逻辑，都是放在基类中实现，然后通过模板方法回调子类的实现，包括：local, mock, generic, echo, token, accesslog, monitor, count, limit 等等，可以全部拆分使用 Filter 实现，每个功能都是调用链上的一环。 比如：(基类模板方法)","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"本文介绍了服务调用过程的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":5800,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务调用过程","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/service-invoking-process/","lvl3":5730,"lvl4":"docs","lvl5":null,"objectID":"2604002749f9b95f9e7789af2d1707cc","permalink":"/zh/docs/v2.7/dev/source/service-invoking-process/","publishdate":"0001-01-01T00:00:00Z","readingtime":27,"relpermalink":"/zh/docs/v2.7/dev/source/service-invoking-process/","summary":"1. 简介 在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。\n2. 源码分析 在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。\n首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。\n2.1 服务调用方式 Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。\n本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：\n/** * Arthas 反编译步骤： * 1. 启动 Arthas * java -jar arthas-boot.jar * * 2. 输入编号选择进程 * Arthas 启动后，会打印 Java 应用进程列表，如下： * [1]: 11232 org.jetbrains.jps.cmdline.Launcher * [2]: 22370 org.jetbrains.jps.cmdline.Launcher * [3]: 22371 com.","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo 中点对点的直连方式","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"直连提供者","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/explicit-target/","lvl3":58,"lvl4":"docs","lvl5":null,"objectID":"019690c57b641bd4079147c928e8d16c","permalink":"/zh/docs/v2.7/user/examples/explicit-target/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/explicit-target/","summary":"在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直连方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。\n通过 XML 配置 如果是线上需求需要点对点，可在 \u0026lt;dubbo:reference\u0026gt; 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：\n\u0026lt;dubbo:reference id=\u0026#34;xxxService\u0026#34; interface=\u0026#34;com.alibaba.xxx.XxxService\u0026#34; url=\u0026#34;dubbo://localhost:20890\u0026#34; /\u0026gt;  提示 1.0.6 及以上版本支持  通过 -D 参数指定 在 JVM 启动参数中加入-D参数映射服务地址，如：\njava -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890  提示 key 为服务名，value 为服务提供者 url，此配置优先级最高，1.0.15 及以上版本支持  通过文件映射 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 \u0026lt;dubbo:reference\u0026gt; 中的配置 [^3]，如：\njava -Ddubbo.resolve.file=xxx.properties 然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：\ncom.alibaba.xxx.XxxService=dubbo://localhost:20890  提示 1.0.15 及以上版本支持，2.0 以上版本自动加载 ${user.home}/dubbo-resolve.properties文件，不需要配置  注意 为了避免复杂化线上环境，不要在线上使用这个功能，只应在测试阶段使用。  ","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo 设计原则系列文章","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"设计原则","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/","lvl3":3,"lvl4":"docs","lvl5":null,"objectID":"d0c90adc96d31acf740c2f38078c3e7b","permalink":"/zh/docs/v2.7/dev/principals/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/","summary":"本章节的设计原则摘录自梁飞在 javaeye 上发表的系列文章。","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"以不同的方式来配置你的 Dubbo 应用","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a40a9a41ef31a10857dcb86362b84aae","permalink":"/zh/docs/v2.7/user/configuration/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/configuration/","summary":"","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Dubbo 中的配置加载流程介绍","dir":"docs/v2.7/user/configuration/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"配置加载流程","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/configuration/configuration-load-process/","lvl3":198,"lvl4":"docs","lvl5":null,"objectID":"18eed20c7ee4127ec93830039b3c04e0","permalink":"/zh/docs/v2.7/user/configuration/configuration-load-process/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/configuration/configuration-load-process/","summary":"此篇文档主要讲在应用启动阶段，Dubbo框架如何将所需要的配置采集起来（包括应用配置、注册中心配置、服务配置等），以完成服务的暴露和引用流程。\n根据驱动方式的不同（比如Spring或裸API编程）配置形式上肯定会有所差异，具体请参考XML配置、Annotation配置、API配置三篇文档。除了外围驱动方式上的差异，Dubbo的配置读取总体上遵循了以下几个原则：\n Dubbo 支持了多层级的配置，并按预定优先级自动实现配置间的覆盖，最终所有配置汇总到数据总线URL后驱动后续的服务暴露、引用等流程。 ApplicationConfig、ServiceConfig、ReferenceConfig 可以被理解成配置来源的一种，是直接面向用户编程的配置采集方式。 配置格式以 Properties 为主，在配置内容上遵循约定的 path-based 的命名规范  配置来源 首先，从Dubbo支持的配置来源说起，默认有四种配置来源：\n JVM System Properties，-D 参数 Externalized Configuration，外部化配置 ServiceConfig、ReferenceConfig 等编程接口采集的配置 本地配置文件 dubbo.properties  覆盖关系 下图展示了配置覆盖关系的优先级，从上到下优先级依次降低：\n点此查看外部化配置详情\n配置格式 目前Dubbo支持的所有配置都是.properties格式的，包括-D、Externalized Configuration等，.properties中的所有配置项遵循一种path-based的配置格式：\n# 应用级别 dubbo.{config-type}[.{config-id}].{config-item}={config-item-value} # 服务级别 dubbo.service.{interface-name}[.{method-name}].{config-item}={config-item-value} dubbo.reference.{interface-name}[.{method-name}].{config-item}={config-item-value} # 多配置项 dubbo.{config-type}s.{config-id}.{config-item}={config-item-value} 应用级别\ndubbo.application.name=demo-provider dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.protocol.port=-1 服务级别\ndubbo.service.org.apache.dubbo.samples.api.DemoService.timeout=5000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.timeout=6000 dubbo.reference.org.apache.dubbo.samples.api.DemoService.sayHello.timeout=7000 多配置项\ndubbo.registries.unit1.address=zookeeper://127.0.0.1:2181 dubbo.registries.unit2.address=zookeeper://127.0.0.1:2182 dubbo.protocols.dubbo.name=dubbo dubbo.protocols.dubbo.port=20880 dubbo.protocols.hessian.name=hessian dubbo.protocols.hessian.port=8089 扩展配置\ndubbo.application.parameters.item1=value1 dubbo.application.parameters.item2=value2 dubbo.registry.parameters.item3=value3 dubbo.reference.org.apache.dubbo.samples.api.DemoService.parameters.item4=value4 几种编程配置方式 接下来，我们看一下选择不同的开发方式时，对应到 ServiceConfig、ReferenceConfig 等编程接口采集的配置的变化。\nSpring XML  参见示例","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"集群扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/cluster/","lvl3":92,"lvl4":"docs","lvl5":null,"objectID":"f6f2738a49a60a2974c7d23cca3c9dff","permalink":"/zh/docs/v2.7/dev/impls/cluster/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/cluster/","summary":"扩展说明 当有多个服务提供方时，将多个服务提供方组织成一个集群，并伪装成一个提供方。\n扩展接口 org.apache.dubbo.rpc.cluster.Cluster\n扩展配置 \u0026lt;dubbo:protocol cluster=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值配置，如果\u0026lt;dubbo:protocol\u0026gt;没有配置cluster时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider cluster=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.rpc.cluster.support.FailoverCluster org.apache.dubbo.rpc.cluster.support.FailfastCluster org.apache.dubbo.rpc.cluster.support.FailsafeCluster org.apache.dubbo.rpc.cluster.support.FailbackCluster org.apache.dubbo.rpc.cluster.support.ForkingCluster org.apache.dubbo.rpc.cluster.support.AvailableCluster  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxCluster.java (实现Cluster接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Cluster (纯文本文件，内容为：xxx=com.xxx.XxxCluster) XxxCluster.java：\npackage com.xxx; import org.apache.dubbo.rpc.cluster.Cluster; import org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker; import org.apache.dubbo.rpc.cluster.Directory; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.Result; import org.apache.dubbo.rpc.RpcException; public class XxxCluster implements Cluster { public \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; merge(Directory\u0026lt;T\u0026gt; directory) throws RpcException { return new AbstractClusterInvoker\u0026lt;T\u0026gt;(directory) { public Result doInvoke(Invocation invocation, List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, LoadBalance loadbalance) throws RpcException { // .","text":null,"weight":5},{"authors":null,"date":-62135596800,"description":"Learn about Dubbo by examples","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Examples","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"36d6cdbf9c7eaaac07227ac7bab1e230","permalink":"/docs/v2.7/user/examples/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/","summary":"","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Some In The Design Of The Basic Common Sense","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/general-knowledge/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"3553ebf11d30d89ebba81ae661c4dcdc","permalink":"/docs/v2.7/dev/principals/general-knowledge/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/general-knowledge/","summary":"","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"Dubbo public agreement","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Public Agreement","lvl1":"docs","lvl2":"/docs/v2.7/dev/contract/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"780d902b967a6f3896e4e32ec8cefed7","permalink":"/docs/v2.7/dev/contract/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/contract/","summary":"","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Router Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/router/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4dd4705efb11b13a091b11d147adf5ec","permalink":"/docs/v2.7/dev/impls/router/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/router/","summary":"","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"Config subscribe only in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Subscribe Only","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/subscribe-only/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"892275ca9fa0599c2008d7a02df87dd9","permalink":"/docs/v2.7/user/examples/subscribe-only/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/subscribe-only/","summary":"","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"一些设计上的基本常识","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/general-knowledge/","lvl3":184,"lvl4":"docs","lvl5":null,"objectID":"3553ebf11d30d89ebba81ae661c4dcdc","permalink":"/zh/docs/v2.7/dev/principals/general-knowledge/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/general-knowledge/","summary":"http://javatar.iteye.com/blog/706098\n 最近给团队新人讲了一些设计上的常识，可能会对其它的新人也有些帮助，把暂时想到的几条，先记在这里。\nAPI 与 SPI 分离 框架或组件通常有两类客户，一个是使用者，一个是扩展者。API (Application Programming Interface) 是给使用者用的，而 SPI (Service Provide Interface) 是给扩展者用的。在设计时，尽量把它们隔离开，而不要混在一起。也就是说，使用者是看不到扩展者写的实现的。\n比如：一个 Web 框架，它有一个 API 接口叫 Action，里面有个 execute() 方法，是给使用者用来写业务逻辑的。然后，Web 框架有一个 SPI 接口给扩展者控制输出方式，比如用 velocity 模板输出还是用 json 输出等。如果这个 Web 框架使用一个都继承 Action 的 VelocityAction 和一个 JsonAction 做为扩展方式，要用 velocity 模板输出的就继承 VelocityAction，要用 json 输出的就继承 JsonAction，这就是 API 和 SPI 没有分离的反面例子，SPI 接口混在了 API 接口中。\n合理的方式是，有一个单独的 Renderer 接口，有 VelocityRenderer 和 JsonRenderer 实现，Web 框架将 Action 的输出转交给 Renderer 接口做渲染输出。\n服务域/实体域/会话域分离 任何框架或组件，总会有核心领域模型，比如：Spring 的 Bean，Struts 的 Action，Dubbo 的 Service，Napoli 的 Queue 等等。这个核心领域模型及其组成部分称为实体域，它代表着我们要操作的目标本身。实体域通常是线程安全的，不管是通过不变类，同步状态，或复制的方式。","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"这里记录的是 Dubbo 公共契约，希望所有扩展点遵守。","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"公共契约","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/contract/","lvl3":17,"lvl4":"docs","lvl5":null,"objectID":"780d902b967a6f3896e4e32ec8cefed7","permalink":"/zh/docs/v2.7/dev/contract/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/contract/","summary":"URL  所有扩展点参数都包含 URL 参数，URL 作为上下文信息贯穿整个扩展点设计体系。 URL 采用标准格式：protocol://username:password@host:port/path?key=value\u0026amp;key=value  日志  如果不可恢复或需要报警，打印 ERROR 日志。 如果可恢复异常，或瞬时的状态不一致，打印 WARN 日志。 正常运行时的中间状态提示，打印 INFO 日志。  ","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"只订阅不注册","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"只订阅","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/subscribe-only/","lvl3":11,"lvl4":"docs","lvl5":null,"objectID":"892275ca9fa0599c2008d7a02df87dd9","permalink":"/zh/docs/v2.7/user/examples/subscribe-only/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/subscribe-only/","summary":"为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。\n可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。\n禁用注册配置\n\u0026lt;dubbo:registry address=\u0026#34;10.20.153.10:9090\u0026#34; register=\u0026#34;false\u0026#34; /\u0026gt; 或者\n\u0026lt;dubbo:registry address=\u0026#34;10.20.153.10:9090?register=false\u0026#34; /\u0026gt; ","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"本文介绍了服务目录的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":1800,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务目录","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/directory/","lvl3":1767,"lvl4":"docs","lvl5":null,"objectID":"8214e9f0ae009530b4ae93f00cdb2829","permalink":"/zh/docs/v2.7/dev/source/directory/","publishdate":"0001-01-01T00:00:00Z","readingtime":9,"relpermalink":"/zh/docs/v2.7/dev/source/directory/","summary":"1. 简介 本篇文章，将开始分析 Dubbo 集群容错方面的源码。集群容错源码包含四个部分，分别是服务目录 Directory、服务路由 Router、集群 Cluster 和负载均衡 LoadBalance。这几个部分的源码逻辑相对比较独立，我们将会分四篇文章进行分析。本篇文章作为集群容错的开篇文章，将和大家一起分析服务目录相关的源码。在进行深入分析之前，我们先来了解一下服务目录是什么。服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗？确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。\n关于服务目录这里就先介绍这些，大家先有个大致印象。接下来我们通过继承体系图来了解一下服务目录的家族成员都有哪些。\n2. 继承体系 服务目录目前内置的实现有两个，分别为 StaticDirectory 和 RegistryDirectory，它们均是 AbstractDirectory 的子类。AbstractDirectory 实现了 Directory 接口，这个接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们来看一下他们的继承体系图。\n如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等均继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表。\n3. 源码分析 本章将分析 AbstractDirectory 和它两个子类的源码。AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式。所以，接下来我们先来看一下 AbstractDirectory 的源码。\npublic List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; list(Invocation invocation) throws RpcException { if (destroyed) { throw new RpcException(\u0026#34;Directory already destroyed.","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"Dubbo 源代码分析系列","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 源代码分析","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/","lvl3":7,"lvl4":"docs","lvl5":null,"objectID":"098df4326ad3053eaed9236b1acf9978","permalink":"/zh/docs/v2.7/dev/source/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/source/","summary":"这篇文档的目标读者是对 dubbo 源码、设计有兴趣的，或者有意愿加入 dubbo 开发的人群。主要通过源代码的分析让读者对 Dubbo 有更深入的理解。","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"通过示例学习 Dubbo 的用法","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"用法示例","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/","lvl3":9,"lvl4":"docs","lvl5":null,"objectID":"36d6cdbf9c7eaaac07227ac7bab1e230","permalink":"/zh/docs/v2.7/user/examples/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/","summary":" Tips 想完整的运行起来，请参见：快速启动，这里只列出各种场景的配置方式。 以下示例全部使用基于 Spring 的 Xml配置作为参考，如果不想使用 Spring，而希望通过 API 的方式进行调用，请参见：API配置  ","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"路由扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/router/","lvl3":56,"lvl4":"docs","lvl5":null,"objectID":"4dd4705efb11b13a091b11d147adf5ec","permalink":"/zh/docs/v2.7/dev/impls/router/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/router/","summary":"扩展说明 从多个服务提供方中选择一个进行调用。\n扩展接口  org.apache.dubbo.rpc.cluster.RouterFactory org.apache.dubbo.rpc.cluster.Router  已知扩展  org.apache.dubbo.rpc.cluster.router.ScriptRouterFactory org.apache.dubbo.rpc.cluster.router.FileRouterFactory  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxRouterFactory.java (实现RouterFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.RouterFactory (纯文本文件，内容为：xxx=com.xxx.XxxRouterFactory) XxxRouterFactory.java：\npackage com.xxx; import org.apache.dubbo.rpc.cluster.RouterFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxRouterFactory implements RouterFactory { public \u0026lt;T\u0026gt; List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; select(List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, Invocation invocation) throws RpcException { // ...  } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory：\nxxx=com.xxx.XxxRouterFactory ","text":null,"weight":6},{"authors":null,"date":-62135596800,"description":"References documentation for dubbo API","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"API Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/api/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"bfe6650e8b84840e92eed7087783f9e1","permalink":"/docs/v2.7/user/references/api/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/api/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"Dubbo API 参考手册","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"API 参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/api/","lvl3":49,"lvl4":"docs","lvl5":null,"objectID":"bfe6650e8b84840e92eed7087783f9e1","permalink":"/zh/docs/v2.7/user/references/api/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/api/","summary":"Dubbo 的常规功能，都保持零侵入，但有些功能不得不用 API 侵入才能实现。\n提示 Dubbo 中除这里声明以外的接口或类，都是内部接口或扩展接口，普通用户请不要直接依赖，否则升级版本可能出现不兼容。  API 汇总如下：\n配置 API org.apache.dubbo.config.ServiceConfig org.apache.dubbo.config.ReferenceConfig org.apache.dubbo.config.ProtocolConfig org.apache.dubbo.config.RegistryConfig org.apache.dubbo.config.MonitorConfig org.apache.dubbo.config.ApplicationConfig org.apache.dubbo.config.ModuleConfig org.apache.dubbo.config.ProviderConfig org.apache.dubbo.config.ConsumerConfig org.apache.dubbo.config.MethodConfig org.apache.dubbo.config.ArgumentConfig 详细参见：API配置\n注解 API org.apache.dubbo.config.annotation.Service org.apache.dubbo.config.annotation.Reference 详细参见：注解配置\n模型 API org.apache.dubbo.common.URL org.apache.dubbo.rpc.RpcException 上下文 API org.apache.dubbo.rpc.RpcContext 详细参见：上下文信息 \u0026amp; 隐式传参 \u0026amp; 异步调用\n服务 API org.apache.dubbo.rpc.service.GenericService org.apache.dubbo.rpc.service.GenericException 详细参见：泛化引用 \u0026amp; 泛化实现\norg.apache.dubbo.rpc.service.EchoService 详细参见：回声测试","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"LoadBalance Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/load-balance/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1744b0ebc4f157978421c4e6a9c9e3b2","permalink":"/docs/v2.7/dev/impls/load-balance/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/load-balance/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"References documentation for all dubbo features","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"References","lvl1":"docs","lvl2":"/docs/v2.7/user/references/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"64e0d4f936b34501929a6b4bf0468634","permalink":"/docs/v2.7/user/references/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The Robustness Of The Design Implementation","lvl1":"docs","lvl2":"/docs/v2.7/dev/principals/robustness/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c742d3e47bc4eb9a0ebf0481cb2ecb82","permalink":"/docs/v2.7/dev/principals/robustness/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/principals/robustness/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Test Coverage Guide","lvl1":"docs","lvl2":"/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ebc5d097d9efaede3600d27c1411546a","permalink":"/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"Dubbo 参考手册","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"64e0d4f936b34501929a6b4bf0468634","permalink":"/zh/docs/v2.7/user/references/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/references/","summary":"","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/contribution-guidelines/contributor/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"测试覆盖率向导","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","lvl3":19,"lvl4":"docs","lvl5":null,"objectID":"ebc5d097d9efaede3600d27c1411546a","permalink":"/zh/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/contributor/test-coverage-guide_dev/","summary":"写单元测试的收益  单元测试能帮助每个人深入代码细节，了解代码的功能。 通过测试用例我们能发现bug，并提交代码的健壮性。 测试用例同时也是代码的demo用法。  单元测试用例的一些设计原则  应该精心设计好步骤，颗粒度和组合条件。 注意边界条件。 单元测试也应该好好设计，不要写无用的代码。 当你发现一个方法很难写单元测试时，如果可以确认这个方法是臭代码，那么就和开发者一起重构它。 Dubbo中用的mock框架是: mockito. 下面是一些开发向导:mockito tutorial,mockito refcard TDD（可选）：当你开始写一个新的功能时，你可以试着先写测试用例。  测试覆盖率设定值  在现阶段，Delta更改代码的测试覆盖设定值为：\u0026gt;＝60%，越高越好。 我们可以在这个页面中看到测试报告: https://codecov.io/gh/apache/dubbo  ","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"设计实现的健壮性","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/robustness/","lvl3":94,"lvl4":"docs","lvl5":null,"objectID":"c742d3e47bc4eb9a0ebf0481cb2ecb82","permalink":"/zh/docs/v2.7/dev/principals/robustness/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/robustness/","summary":"http://oldratlee.com/380/tech/java/robustness-of-implement.html\n Dubbo 作为远程服务暴露、调用和治理的解决方案，是应用运转的经络，其本身实现健壮性的重要程度是不言而喻的。\n这里列出一些 Dubbo 用到的原则和方法。\n日志 日志是发现问题、查看问题一个最常用的手段。日志质量往往被忽视，没有日志使用上的明确约定。重视 Log 的使用，提高 Log 的信息浓度。日志过多、过于混乱，会导致有用的信息被淹没。\n要有效利用这个工具要注意：\n严格约定WARN、ERROR级别记录的内容  WARN 表示可以恢复的问题，无需人工介入。 ERROR 表示需要人工介入问题。  有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度。\n日志中，尽量多的收集关键信息 哪些是关键信息呢？\n 出问题时的现场信息，即排查问题要用到的信息。如服务调用失败时，要给出使用 Dubbo 的版本、服务提供者的 IP、使用的是哪个注册中心；调用的是哪个服务、哪个方法等等。这些信息如果不给出，那么事后人工收集的，问题过后现场可能已经不能复原，加大排查问题的难度。 如果可能，给出问题的原因和解决方法。这让维护和问题解决变得简单，而不是寻求精通者（往往是实现者）的帮助。  同一个或是一类问题不要重复记录多次 同一个或是一类异常日志连续出现几十遍的情况，还是常常能看到的。人眼很容易漏掉淹没在其中不一样的重要日志信息。要尽量避免这种情况。在可以预见会出现的情况，有必要加一些逻辑来避免。\n如为一个问题准备一个标志，出问题后打日志后设置标志，避免重复打日志。问题恢复后清除标志。\n虽然有点麻烦，但是这样做保证日志信息浓度，让监控更有效。\n界限设置 资源是有限的，CPU、内存、IO 等等。不要因为外部的请求、数据不受限的而崩溃。\n线程池(ExectorService)的大小和饱和策略 Server 端用于处理请求的 ExectorService 设置上限。ExecutorService 的任务等待队列使用有限队列，避免资源耗尽。当任务等待队列饱和时，选择一个合适的饱和策略。这样保证平滑劣化。\n在 Dubbo 中，饱和策略是丢弃数据，等待结果也只是请求的超时。\n达到饱和时，说明已经达到服务提供方的负荷上限，要在饱和策略的操作中日志记录这个问题，以发出监控警报。记得注意不要重复多次记录哦。（注意，缺省的饱和策略不会有这些附加的操作。）根据警报的频率，已经决定扩容调整等等，避免系统问题被忽略。\n集合容量 如果确保进入集合的元素是可控的且是足够少，则可以放心使用。这是大部分的情况。如果不能保证，则使用有有界的集合。当到达界限时，选择一个合适的丢弃策略。\n容错-重试-恢复 高可用组件要容忍其依赖组件的失败。\nDubbo 的服务注册中心 目前服务注册中心使用了数据库来保存服务提供者和消费者的信息。注册中心集群不同注册中心也通过数据库来进行同步数据，以感知其它注册中心上提供者的变化。注册中心会在内存中保存一份提供者和消费者数据，数据库不可用时，注册中心独立对外提供服务以保证正常运转，只是拿不到其它注册中心的数据。当数据库恢复时，重试逻辑会将内存中修改的数据写回数据库，并拿到数据库中新数据。\n服务的消费者 服务消费者从注册中心拿到提供者列表后，会保存提供者列表到内存和磁盘文件中。这样注册中心宕机后消费者可以正常运转，甚至可以在注册中心宕机过程中重启消费者。消费者启动时，发现注册中心不可用，会读取保存在磁盘文件中提供者列表。重试逻辑保证注册中心恢复后，更新信息。\n重试延迟策略 上一点的子问题。Dubbo 中碰到有两个相关的场景。\n数据库上的活锁 注册中心会定时更新数据库一条记录的时间戳，这样集群中其它的注册中心感知它是存活。过期注册中心和它的相关数据 会被清除。数据库正常时，这个机制运行良好。但是数据库负荷高时，其上的每个操作都会很慢。这就出现：","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"负载均衡扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/load-balance/","lvl3":66,"lvl4":"docs","lvl5":null,"objectID":"1744b0ebc4f157978421c4e6a9c9e3b2","permalink":"/zh/docs/v2.7/dev/impls/load-balance/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/load-balance/","summary":"扩展说明 从多个服务提供方中选择一个进行调用\n扩展接口 org.apache.dubbo.rpc.cluster.LoadBalance\n扩展配置 \u0026lt;dubbo:protocol loadbalance=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置loadbalance时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider loadbalance=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxLoadBalance.java (实现LoadBalance接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance) XxxLoadBalance.java：\npackage com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; select(List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, Invocation invocation) throws RpcException { // ...  } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance：\nxxx=com.xxx.XxxLoadBalance ","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"本文介绍了集群的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":2000,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"集群","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/cluster/","lvl3":1928,"lvl4":"docs","lvl5":null,"objectID":"bc6b592d34613cc829b04d8c5b12a3e0","permalink":"/zh/docs/v2.7/dev/source/cluster/","publishdate":"0001-01-01T00:00:00Z","readingtime":10,"relpermalink":"/zh/docs/v2.7/dev/source/cluster/","summary":"1.简介 为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。\nDubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。每种集群实现类的用途不同，接下来会一一进行分析。\n2. 集群容错 在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。\n集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举 Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List\u0026lt;Invoker\u0026gt;。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删 Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当 FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。","text":null,"weight":7},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Merger Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/merger/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"058af5495534584d41fad8273b53455b","permalink":"/docs/v2.7/dev/impls/merger/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/merger/","summary":"","text":null,"weight":8},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"合并结果扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/merger/","lvl3":50,"lvl4":"docs","lvl5":null,"objectID":"058af5495534584d41fad8273b53455b","permalink":"/zh/docs/v2.7/dev/impls/merger/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/merger/","summary":"扩展说明 合并返回结果，用于分组聚合。\n扩展接口 org.apache.dubbo.rpc.cluster.Merger\n扩展配置 \u0026lt;dubbo:method merger=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.rpc.cluster.merger.ArrayMerger org.apache.dubbo.rpc.cluster.merger.ListMerger org.apache.dubbo.rpc.cluster.merger.SetMerger org.apache.dubbo.rpc.cluster.merger.MapMerger  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxMerger.java (实现Merger接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.Merger (纯文本文件，内容为：xxx=com.xxx.XxxMerger) XxxMerger.java：\npackage com.xxx; import org.apache.dubbo.rpc.cluster.Merger; public class XxxMerger\u0026lt;T\u0026gt; implements Merger\u0026lt;T\u0026gt; { public T merge(T... results) { // ...  } } META-INF/dubbo/org.apache.dubbo.rpc.cluster.Merger：\nxxx=com.xxx.XxxMerger ","text":null,"weight":8},{"authors":null,"date":-62135596800,"description":"本文介绍了集群的原理和实现细节","dir":"docs/v2.7/dev/source/","expirydate":-62135596800,"fuzzywordcount":2900,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"负载均衡","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/source/loadbalance/","lvl3":2809,"lvl4":"docs","lvl5":null,"objectID":"070c913a1cfe3fe003736b63076d3fe8","permalink":"/zh/docs/v2.7/dev/source/loadbalance/","publishdate":"0001-01-01T00:00:00Z","readingtime":14,"relpermalink":"/zh/docs/v2.7/dev/source/loadbalance/","summary":"1.简介 LoadBalance 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是可以接触到的，比如 Nginx。在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。这几个负载均衡算法代码不是很长，但是想看懂也不是很容易，需要大家对这几个算法的原理有一定了解才行。如果不是很了解，也没不用太担心。我们会在分析每个算法的源码之前，对算法原理进行简单的讲解，帮助大家建立初步的印象。\n本系列文章在编写之初是基于 Dubbo 2.6.4 的，近期，Dubbo 2.6.5 发布了，其中就有针对对负载均衡部分的优化。因此我们在分析完 2.6.4 版本后的源码后，会另外分析 2.6.5 更新的部分。其他的就不多说了，进入正题吧。\n2.源码分析 在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance 的逻辑。首先来看一下负载均衡的入口方法 select，如下：\n@Override public \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; select(List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, URL url, Invocation invocation) { if (invokers == null || invokers.isEmpty()) return null; // 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡  if (invokers.size() == 1) return invokers.get(0); // 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现  return doSelect(invokers, url, invocation); } protected abstract \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; doSelect(List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, URL url, Invocation invocation); select 方法的逻辑比较简单，首先会检测 invokers 集合的合法性，然后再检测 invokers 集合元素数量。如果只包含一个 Invoker，直接返回该 Inovker 即可。如果包含多个 Invoker，此时需要通过负载均衡算法选择一个 Invoker。具体的负载均衡算法由子类实现，接下来章节会对这些子类一一进行详细分析。","text":null,"weight":8},{"authors":null,"date":-62135596800,"description":"Config multiple protocols in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Multiple Protocols","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/multi-protocols/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4a430684cef86e52e292f33e9ea30ef2","permalink":"/docs/v2.7/user/examples/multi-protocols/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/multi-protocols/","summary":"","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Registry Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/registry/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1ba391545a5059e551112d4b9a32d7ab","permalink":"/docs/v2.7/dev/impls/registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/registry/","summary":"","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"Dubbo versioning contract","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Versions","lvl1":"docs","lvl2":"/docs/v2.7/dev/release/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a9cd8d6f9e9f75d6ceb46196845b5835","permalink":"/docs/v2.7/dev/release/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/release/","summary":"","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"在 Dubbbo 中配置多协议","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"多协议","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/multi-protocols/","lvl3":99,"lvl4":"docs","lvl5":null,"objectID":"4a430684cef86e52e292f33e9ea30ef2","permalink":"/zh/docs/v2.7/user/examples/multi-protocols/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/multi-protocols/","summary":"Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。\n不同服务不同协议 不同服务在性能上适用不同协议进行传输，比如大数据用短连接协议，小数据大并发用长连接协议\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;world\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;registry\u0026#34; address=\u0026#34;10.20.141.150:9090\u0026#34; username=\u0026#34;admin\u0026#34; password=\u0026#34;hello1234\u0026#34; /\u0026gt; \u0026lt;!-- 多协议配置 --\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20880\u0026#34; /\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;rmi\u0026#34; port=\u0026#34;1099\u0026#34; /\u0026gt; \u0026lt;!-- 使用dubbo协议暴露服务 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.alibaba.hello.api.HelloService\u0026#34; version=\u0026#34;1.0.0\u0026#34; ref=\u0026#34;helloService\u0026#34; protocol=\u0026#34;dubbo\u0026#34; /\u0026gt; \u0026lt;!-- 使用rmi协议暴露服务 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.alibaba.hello.api.DemoService\u0026#34; version=\u0026#34;1.0.0\u0026#34; ref=\u0026#34;demoService\u0026#34; protocol=\u0026#34;rmi\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 多协议暴露服务 需要与 http 客户端互操作\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;world\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;registry\u0026#34; address=\u0026#34;10.","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"注册中心扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/registry/","lvl3":355,"lvl4":"docs","lvl5":null,"objectID":"1ba391545a5059e551112d4b9a32d7ab","permalink":"/zh/docs/v2.7/dev/impls/registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/dev/impls/registry/","summary":"扩展说明 负责服务的注册与发现。\n扩展接口  org.apache.dubbo.registry.RegistryFactory org.apache.dubbo.registry.Registry  扩展配置 \u0026lt;!-- 定义注册中心 --\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;xxx1\u0026#34; address=\u0026#34;xxx://ip:port\u0026#34; /\u0026gt; \u0026lt;!-- 引用注册中心，如果没有配置registry属性，将在ApplicationContext中自动扫描registry配置 --\u0026gt; \u0026lt;dubbo:service registry=\u0026#34;xxx1\u0026#34; /\u0026gt; \u0026lt;!-- 引用注册中心缺省值，当\u0026lt;dubbo:service\u0026gt;没有配置registry属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider registry=\u0026#34;xxx1\u0026#34; /\u0026gt; 扩展契约 RegistryFactory.java：\npublic interface RegistryFactory { /** * 连接注册中心. * * 连接注册中心需处理契约：\u0026lt;br\u0026gt; * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。\u0026lt;br\u0026gt; * 2. 支持URL上的username:password权限认证。\u0026lt;br\u0026gt; * 3. 支持backup=10.20.153.10备选注册中心集群地址。\u0026lt;br\u0026gt; * 4. 支持file=registry.cache本地磁盘文件缓存。\u0026lt;br\u0026gt; * 5. 支持timeout=1000请求超时设置。\u0026lt;br\u0026gt; * 6. 支持session=60000会话超时或过期设置。\u0026lt;br\u0026gt; * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ Registry getRegistry(URL url); } RegistryService.","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"Dubbo 项目的版本管理","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"版本管理","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/release/","lvl3":70,"lvl4":"docs","lvl5":null,"objectID":"a9cd8d6f9e9f75d6ceb46196845b5835","permalink":"/zh/docs/v2.7/dev/release/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/release/","summary":"新功能的开发 和 稳定性的提高 对产品都很重要。但是添加新功能会影响稳定性，Dubbo 使用如下的版本开发模式来保障两者。\n2 个版本并行开发  BugFix 版本：低版本，比如 2.4.x。是 GA 版本，线上使用的版本，只会 BugFix，升级第三位版本号。 新功能版本：高版本，比如 2.5.x。加新功能的版本，会给对新功能有需求的应用试用。  2.5.x 的新功能基本稳定后，进入 2.5.x 试用阶段。找足够多的应用试用 2.5.x 版本。\n在 2.5.x 够稳定后：\n 2.5.x 成为 GA 版本，只 BugFix，推广使用此版本。如果版本可用，可以推进应用在期望的时间点内升级到 GA 版本。 2.4.x 不再开发，应用碰到 Bug 让直接升级。（这个称为“夕阳条款”） 从 2.5.x 拉成分支 2.6.0，作为新功能开发版本。  优势  保证 GA 版本是稳定的！因为：  只会作 BugFix 成为 GA 版本前有试用阶段   新功能可以在高版本中快速响应，并让应用能试用新功能。 不会版本过多，导致开发和维护成本剧增  用户要配合的职责 由于开发只会 BugFix GA 版本，所以用户需要积极跟进升级到 GA 版本，以 Fix 发现的问题。\n定期升级版本给用户带来了不安。这是一个假命题，说明如下：\n GA 经过一个试用阶段保持稳定。 GA 版本有 Bug 会火速 Fix 相对出问题才升级到 GA 版本（可能跨了多个版本）定期升级平摊风险（类似小步快跑）。经历过周期长的大项目的同学会有这样的经历，三方库版本长时间不升级，结果出了问题不得不升级到新版本（跨了多个版本）风险巨大。  ","text":null,"weight":9},{"authors":null,"date":-62135596800,"description":"升级到 2.7.x 的注意事项和兼容性问题总结","dir":"docs/v2.7/user/versions/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"升级与可能的兼容性问题总结","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/versions/version-270/","lvl3":249,"lvl4":"docs","lvl5":null,"objectID":"ceaf1976af441f7df9da624b1c6dc638","permalink":"/zh/docs/v2.7/user/versions/version-270/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/versions/version-270/","summary":"环境要求：需要Java 8及以上版本。\n2.7.0版本在改造的过程中遵循了一个原则，即保持与低版本的兼容性，因此从功能层面来说它是与2.6.x及更低版本完全兼容的，而接下来将要提到的兼容性问题主要是包重命名带来的。另外，虽然功能用法保持向后兼容，但参考本文能帮助您尽快用到2.7.0版本的新特性。\n升级步骤  升级pom到2.7.0（以all-in-one依赖为例）。  \u0026lt;properties\u0026gt; \u0026lt;dubbo.version\u0026gt;2.7.0\u0026lt;/dubbo.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-dependencies-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 如果升级依赖后出现API或SPI扩展相关的编译错误，请参考包兼容性问题\n此时重新部署应用，所有默认行为和2.6.x保持一致，如果要用到2.7的新特性，则需要继续做以下配置（可选）：\n 简化的URL 配置元数据中心 使用外部化配置 服务治理规则 使用异步API  下面我们就对这几部分的配置分别做详细说明。\n简化的URL \u0026lt;!-- simplified=\u0026#34;true\u0026#34;表示注册简化版的URL到Registry --\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34; simplified=\u0026#34;true\u0026#34;/\u0026gt; dubbo.registry.simplified=true 建议将此配置集中管理，参考外部化配置。\n URL简化只是剔除了一些纯粹的查询用的参数，并没有做大刀阔斧的服务发现模型改造，因此精简后的URL完全可以被2.6及以下版本的消费端实现服务发现与调用，同样2.7版本也可以发现和调用低版本的提供者。\n 配置元数据中心 \u0026lt;dubbo:metadata-report address=\u0026#34;redis://127.0.0.1:6379\u0026#34;/\u0026gt; dubbo.metadataReport.address=redis://127.0.0.1:6379 建议将此配置集中管理，参考外部化配置。 在此了解更多元数据中心设计目的与用途。\n使用外部化配置 需要在项目启动前，使用[最新版本Dubbo-OPS](https://github.com/apache/dubbo-ops)完成外部化配置迁移，理论上配置中心支持所有本地dubbo.properties所支持的配置项。 以XML开发形式为例，假设我们本地有如下配置：\n\u0026lt;dubbo:application name=\u0026#34;demo-provider\u0026#34;/\u0026gt; \u0026lt;dubbo:config-center address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34; simplified=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;dubbo:metadata-report address=\u0026#34;redis://127.","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Monitor Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/monitor/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d8a6b80ced934caa5c1109d38d7209fa","permalink":"/docs/v2.7/dev/impls/monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/monitor/","summary":"","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"Config multiple registries in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Multiple Registries","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/multi-registry/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"84fe66d1a399440d99a85b01e37fe793","permalink":"/docs/v2.7/user/examples/multi-registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/multi-registry/","summary":"","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"Learn about Dubbo including its main features and capabilities","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"User Documentation","lvl1":"docs","lvl2":"/docs/v2.7/user/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4334d25ca9c8ac3e7b18fa313cee3199","permalink":"/docs/v2.7/user/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/","summary":"","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中把同一个服务注册到多个注册中心上","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"多注册中心","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/multi-registry/","lvl3":172,"lvl4":"docs","lvl5":null,"objectID":"84fe66d1a399440d99a85b01e37fe793","permalink":"/zh/docs/v2.7/user/examples/multi-registry/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/multi-registry/","summary":"Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。另外，注册中心是支持自定义扩展的 1。\n多注册中心注册 比如：中文站有些服务来不及在青岛部署，只在杭州部署，而青岛的其它应用需要引用此服务，就可以将服务同时注册到两个注册中心。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;world\u0026#34; /\u0026gt; \u0026lt;!-- 多注册中心配置 --\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;hangzhouRegistry\u0026#34; address=\u0026#34;10.20.141.150:9090\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;qingdaoRegistry\u0026#34; address=\u0026#34;10.20.141.151:9010\u0026#34; default=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!-- 向多个注册中心注册 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.alibaba.hello.api.HelloService\u0026#34; version=\u0026#34;1.0.0\u0026#34; ref=\u0026#34;helloService\u0026#34; registry=\u0026#34;hangzhouRegistry,qingdaoRegistry\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 不同服务使用不同注册中心 比如：CRM 有些服务是专门为国际站设计的，有些服务是专门为中文站设计的。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;world\u0026#34; /\u0026gt; \u0026lt;!-- 多注册中心配置 --\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;chinaRegistry\u0026#34; address=\u0026#34;10.20.141.150:9090\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;intlRegistry\u0026#34; address=\u0026#34;10.20.154.177:9010\u0026#34; default=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"从低版本升级到 2.7.x 的注意事项和兼容性","dir":"docs/v2.7/user/versions/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"版本升级","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/versions/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"408bae5fb88592decef124b0057f508a","permalink":"/zh/docs/v2.7/user/versions/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/versions/","summary":"","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"学习如何使用 Dubbo，了解 Dubbo 的主要功能和特性","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"用户文档","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/","lvl3":7,"lvl4":"docs","lvl5":null,"objectID":"4334d25ca9c8ac3e7b18fa313cee3199","permalink":"/zh/docs/v2.7/user/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/","summary":"这篇文档详细讲解了 dubbo 的使用，基本涵盖 dubbo 的所有功能特性。如果你正依赖 dubbo 作为你业务工程的服务框架，这里可以作为你的参考手册。","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"监控中心扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/monitor/","lvl3":78,"lvl4":"docs","lvl5":null,"objectID":"d8a6b80ced934caa5c1109d38d7209fa","permalink":"/zh/docs/v2.7/dev/impls/monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/monitor/","summary":"扩展说明 负责服务调用次和调用时间的监控。\n扩展接口  org.apache.dubbo.monitor.MonitorFactory org.apache.dubbo.monitor.Monitor  扩展配置 \u0026lt;!-- 定义监控中心 --\u0026gt; \u0026lt;dubbo:monitor address=\u0026#34;xxx://ip:port\u0026#34; /\u0026gt; 已知扩展 org.apache.dubbo.monitor.support.dubbo.DubboMonitorFactory\n扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxMonitorFactoryjava (实现MonitorFactory接口) |-XxxMonitor.java (实现Monitor接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.monitor.MonitorFactory (纯文本文件，内容为：xxx=com.xxx.XxxMonitorFactory) XxxMonitorFactory.java：\npackage com.xxx; import org.apache.dubbo.monitor.MonitorFactory; import org.apache.dubbo.monitor.Monitor; import org.apache.dubbo.common.URL; public class XxxMonitorFactory implements MonitorFactory { public Monitor getMonitor(URL url) { return new XxxMonitor(url); } } XxxMonitor.java：\npackage com.xxx; import org.apache.dubbo.monitor.Monitor; public class XxxMonitor implements Monitor { public void count(URL statistics) { // .","text":null,"weight":10},{"authors":null,"date":-62135596800,"description":"Checklist before release","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Checklist","lvl1":"docs","lvl2":"/docs/v2.7/dev/checklist/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"58b59893ecf70fbb78d7df3821e396f6","permalink":"/docs/v2.7/dev/checklist/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/checklist/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"ExtensionFactory Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/extension-factory/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a51acfbb86525753caa3fdbad2c6102b","permalink":"/docs/v2.7/dev/impls/extension-factory/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/extension-factory/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"Telnet (new version) command usage in dubbo","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Qos Command Usage ","lvl1":"docs","lvl2":"/docs/v2.7/user/references/qos/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ccaf2dddd4a11009b3f54c2e089ab553","permalink":"/docs/v2.7/user/references/qos/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/qos/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"新版本 telnet 命令使用说明","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在线运维命令参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/qos/","lvl3":348,"lvl4":"docs","lvl5":null,"objectID":"ccaf2dddd4a11009b3f54c2e089ab553","permalink":"/zh/docs/v2.7/user/references/qos/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/qos/","summary":"dubbo 2.5.8 新版本增加了 QOS 模块，提供了新的 telnet 命令支持。\n端口 新版本的 telnet 端口 与 dubbo 协议的端口是不同的端口，默认为 22222，可通过配置文件dubbo.properties 修改:\ndubbo.application.qos.port=33333 或者通过设置 JVM 参数:\n-Ddubbo.application.qos.port=33333 安全 默认情况下，dubbo 接收任何主机发起的命令，可通过配置文件dubbo.properties 修改:\ndubbo.application.qos.accept.foreign.ip=false 或者通过设置 JVM 参数:\n-Ddubbo.application.qos.accept.foreign.ip=false 拒绝远端主机发出的命令，只允许服务本机执行\ntelnet 与 http 协议 telnet 模块现在同时支持 http 协议和 telnet 协议，方便各种情况的使用\n示例如下：\n➜ ~ telnet localhost 22222 Trying ::1... telnet: connect to address ::1: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. ████████▄ ███ █▄ ▀█████████▄ ▀█████████▄ ▄██████▄ ███ ▀███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ▄███▄▄▄██▀ ▄███▄▄▄██▀ ███ ███ ███ ███ ███ ███ ▀▀███▀▀▀██▄ ▀▀███▀▀▀██▄ ███ ███ ███ ███ ███ ███ ███ ██▄ ███ ██▄ ███ ███ ███ ▄███ ███ ███ ███ ███ ███ ███ ███ ███ ████████▀ ████████▀ ▄█████████▀ ▄█████████▀ ▀██████▀ dubbo\u0026gt;ls As Provider side: +----------------------------------+---+ | Provider Service Name |PUB| +----------------------------------+---+ |org.","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"Grouping service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Group","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/service-group/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c7f4b62a39c0ee72c8930f08b56bf02c","permalink":"/docs/v2.7/user/examples/service-group/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/service-group/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"Config static service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Static Service","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/static-service/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a5661115f5ce210548ecb13e8d449a78","permalink":"/docs/v2.7/user/examples/static-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/static-service/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"Telnet command reference in dubbo","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Telnet Command Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/telnet/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"a0c8e69a06ca2807ab383a3365c57451","permalink":"/docs/v2.7/user/references/telnet/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/telnet/","summary":"","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"通过 Telnet 命令进行服务治理","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Telnet 命令参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/telnet/","lvl3":219,"lvl4":"docs","lvl5":null,"objectID":"a0c8e69a06ca2807ab383a3365c57451","permalink":"/zh/docs/v2.7/user/references/telnet/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/references/telnet/","summary":"从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。\n使用 telnet localhost 20880 或者：\necho status | nc -i 1 localhost 20880 status命令所检查的资源也可以扩展，参见：扩展参考手册。\n命令 以下展示了 dubbo 内建的 telnet 命令的说明和用法，此外，telnet 命令还支持用户自行扩展，参见：Telnet 命令扩展。\nls ls: 显示服务列表 ls -l: 显示服务详细信息列表 ls XxxService: 显示服务的方法列表 ls -l XxxService: 显示服务的方法详细信息列表  ps ps: 显示服务端口列表 ps -l: 显示服务地址列表 ps 20880: 显示端口上的连接信息 ps -l 20880: 显示端口上的连接详细信息  cd cd XxxService: 改变缺省服务，当设置了缺省服务，凡是需要输入服务名作为参数的命令，都可以省略服务参数 cd /: 取消缺省服务  pwd pwd: 显示当前缺省服务\ntrace trace XxxService: 跟踪 1 次服务任意方法的调用情况 trace XxxService 10: 跟踪 10 次服务任意方法的调用情况 trace XxxService xxxMethod: 跟踪 1 次服务方法的调用情况 trace XxxService xxxMethod 10: 跟踪 10 次服务方法的调用情况  count count XxxService: 统计 1 次服务任意方法的调用情况 count XxxService 10: 统计 10 次服务任意方法的调用情况 count XxxService xxxMethod: 统计 1 次服务方法的调用情况 count XxxService xxxMethod 10: 统计 10 次服务方法的调用情况  invoke invoke XxxService.","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"扩展点加载扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/extension-factory/","lvl3":50,"lvl4":"docs","lvl5":null,"objectID":"a51acfbb86525753caa3fdbad2c6102b","permalink":"/zh/docs/v2.7/dev/impls/extension-factory/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/extension-factory/","summary":"扩展说明 扩展点本身的加载容器，可从不同容器加载扩展点。\n扩展接口 org.apache.dubbo.common.extension.ExtensionFactory\n扩展配置 \u0026lt;dubbo:application compiler=\u0026#34;jdk\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.common.extension.factory.SpiExtensionFactory org.apache.dubbo.config.spring.extension.SpringExtensionFactory  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxExtensionFactory.java (实现ExtensionFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.extension.ExtensionFactory (纯文本文件，内容为：xxx=com.xxx.XxxExtensionFactory) XxxExtensionFactory.java：\npackage com.xxx; import org.apache.dubbo.common.extension.ExtensionFactory; public class XxxExtensionFactory implements ExtensionFactory { public Object getExtension(Class\u0026lt;?\u0026gt; type, String name) { // ...  } } META-INF/dubbo/org.apache.dubbo.common.extension.ExtensionFactory：\nxxx=com.xxx.XxxExtensionFactory ","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"使用服务分组区分服务接口的不同实现","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务分组","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/service-group/","lvl3":32,"lvl4":"docs","lvl5":null,"objectID":"c7f4b62a39c0ee72c8930f08b56bf02c","permalink":"/zh/docs/v2.7/user/examples/service-group/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/service-group/","summary":"当一个接口有多种实现时，可以用 group 区分。\n服务 \u0026lt;dubbo:service group=\u0026#34;feedback\u0026#34; interface=\u0026#34;com.xxx.IndexService\u0026#34; /\u0026gt; \u0026lt;dubbo:service group=\u0026#34;member\u0026#34; interface=\u0026#34;com.xxx.IndexService\u0026#34; /\u0026gt; 引用 \u0026lt;dubbo:reference id=\u0026#34;feedbackIndexService\u0026#34; group=\u0026#34;feedback\u0026#34; interface=\u0026#34;com.xxx.IndexService\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;memberIndexService\u0026#34; group=\u0026#34;member\u0026#34; interface=\u0026#34;com.xxx.IndexService\u0026#34; /\u0026gt; 任意组：\n\u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; group=\u0026#34;*\u0026#34; /\u0026gt;  提示 2.2.0 以上版本支持，总是只调一个可用组的实现  ","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"版本发布前的检查列表","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"检查列表","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/checklist/","lvl3":44,"lvl4":"docs","lvl5":null,"objectID":"58b59893ecf70fbb78d7df3821e396f6","permalink":"/zh/docs/v2.7/dev/checklist/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/checklist/","summary":"发布前 checklist  jira ticket 过一遍 svn change list ticket 关联 code test code find bugs  修复时 checklist  修复代码前先建 ticket 修复代码前先写测试用例 需要伙伴检查 test code(正常流程/异常流程) 讲一遍逻辑 契约文档化 以上内容都写到ticket的评论上 代码注释写清楚，用中文无妨 每个版本要有 owner，确保 scope 和 check  Partner Check  Partner 以用户的方式运行一下功能 Partner 发现问题、添加测试（集成测试）直到不再复现；Owner 完成实现。（保证两方在Partner Check上的时间投入） Owner 向 Partner 讲述一遍实现。  ","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"将 Dubbo 服务标识为非动态管理模式","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"静态服务","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/static-service/","lvl3":24,"lvl4":"docs","lvl5":null,"objectID":"a5661115f5ce210548ecb13e8d449a78","permalink":"/zh/docs/v2.7/user/examples/static-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/static-service/","summary":"有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。\n\u0026lt;dubbo:registry address=\u0026#34;10.20.141.150:9090\u0026#34; dynamic=\u0026#34;false\u0026#34; /\u0026gt; 或者\n\u0026lt;dubbo:registry address=\u0026#34;10.20.141.150:9090?dynamic=false\u0026#34; /\u0026gt; 服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。\n如果是一个第三方服务提供者，比如 memcached，可以直接向注册中心写入提供者地址信息，消费者正常使用 1：\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;memcached://10.20.153.11/com.foo.BarService?category=providers\u0026amp;dynamic=false\u0026amp;application=foo\u0026#34;));   通常由脚本监控中心页面等调用 \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":11},{"authors":null,"date":-62135596800,"description":"Bade code small which should be avoided","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Bad Smell","lvl1":"docs","lvl2":"/docs/v2.7/dev/code-smell/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"eb18ae20f03e10ae5eb734fe8c294cfd","permalink":"/docs/v2.7/dev/code-smell/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/code-smell/","summary":"","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Dubbo coding convention","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Coding Convention","lvl1":"docs","lvl2":"/docs/v2.7/dev/coding/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e10f30bb6ac7a2a863dd77941a2612ac","permalink":"/docs/v2.7/dev/coding/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/coding/","summary":"","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Maven plugin reference in dubbo","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Maven Plugin Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/references/maven/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"5a47ce42f96e5cc40340359e8812e704","permalink":"/docs/v2.7/user/references/maven/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/references/maven/","summary":"","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Dubbo 的 Maven 插件","dir":"docs/v2.7/user/references/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Maven 插件参考手册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/references/maven/","lvl3":21,"lvl4":"docs","lvl5":null,"objectID":"5a47ce42f96e5cc40340359e8812e704","permalink":"/zh/docs/v2.7/user/references/maven/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/references/maven/","summary":"启动一个简易注册中心 以指定的 9099 端口启动一个简易注册中心 1：\nmvn dubbo:registry -Dport=9099 生成 demo 服务提供者应用 生成指定接口和版本的服务提供者应用：\nmvn dubbo:create -Dapplication=xxx -Dpackage=com.alibaba.xxx -Dservice=XxxService,YyyService -Dversion=1.0.0   如果端口不指定，默认端口为 9090 \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Config multiple versions for services in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Multiple Versions","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/multi-versions/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"27ef728bee11ebc9d75f36f1a24cb7dc","permalink":"/docs/v2.7/user/examples/multi-versions/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/multi-versions/","summary":"","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"ProxyFactory Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/proxy-factory/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"976640f9b139750c74cae4bf98fcc44f","permalink":"/docs/v2.7/dev/impls/proxy-factory/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/proxy-factory/","summary":"","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"动态代理扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/proxy-factory/","lvl3":78,"lvl4":"docs","lvl5":null,"objectID":"976640f9b139750c74cae4bf98fcc44f","permalink":"/zh/docs/v2.7/dev/impls/proxy-factory/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/proxy-factory/","summary":"扩展说明 将 Invoker 接口转换成业务接口。\n扩展接口 org.apache.dubbo.rpc.ProxyFactory\n扩展配置 \u0026lt;dubbo:protocol proxy=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值配置，当\u0026lt;dubbo:protocol\u0026gt;没有配置proxy属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider proxy=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.rpc.proxy.JdkProxyFactory org.apache.dubbo.rpc.proxy.JavassistProxyFactory  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxProxyFactory.java (实现ProxyFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.ProxyFactory (纯文本文件，内容为：xxx=com.xxx.XxxProxyFactory) XxxProxyFactory.java：\npackage com.xxx; import org.apache.dubbo.rpc.ProxyFactory; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.RpcException; public class XxxProxyFactory implements ProxyFactory { public \u0026lt;T\u0026gt; T getProxy(Invoker\u0026lt;T\u0026gt; invoker) throws RpcException { // ...  } public \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; getInvoker(T proxy, Class\u0026lt;T\u0026gt; type, URL url) throws RpcException { // .","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"这里记录的是 Dubbo 设计或实现不优雅的地方","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"坏味道","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/code-smell/","lvl3":310,"lvl4":"docs","lvl5":null,"objectID":"eb18ae20f03e10ae5eb734fe8c294cfd","permalink":"/zh/docs/v2.7/dev/code-smell/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/dev/code-smell/","summary":"URL 转换 1. 点对点暴露和引用服务 直接暴露服务：\nEXPORT(dubbo://provider-address/com.xxx.XxxService?version=1.0.0\u0026#34;) 点对点直连服务：\nREFER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 2. 通过注册中心暴露服务 向注册中心暴露服务：\nEXPORT(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo\u0026amp;export=ENCODE(dubbo://provider-address/com.xxx.XxxService?version=1.0.0)) 获取注册中心：\nurl.setProtocol(url.getParameter(\u0026#34;registry\u0026#34;, \u0026#34;dubbo\u0026#34;)) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) 注册服务地址：\nurl.getParameterAndDecoded(\u0026#34;export\u0026#34;)) REGISTER(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 3. 通过注册中心引用服务 从注册中心订阅服务：\nREFER(registry://registry-address/org.apache.dubbo.registry.RegistrySerevice?registry=dubbo\u0026amp;refer=ENCODE(version=1.0.0)) 获取注册中心：\nurl.setProtocol(url.getParameter(\u0026#34;registry\u0026#34;, \u0026#34;dubbo\u0026#34;)) GETREGISTRY(dubbo://registry-address/org.apache.dubbo.registry.RegistrySerevice) 订阅服务地址：\nurl.addParameters(url.getParameterAndDecoded(\u0026#34;refer\u0026#34;)) SUBSCRIBE(dubbo://registry-address/com.xxx.XxxService?version=1.0.0) 通知服务地址：\nurl.addParameters(url.getParameterAndDecoded(\u0026#34;refer\u0026#34;)) NOTIFY(dubbo://provider-address/com.xxx.XxxService?version=1.0.0) 4. 注册中心推送路由规则 注册中心路由规则推送：\nNOTIFY(route://registry-address/com.xxx.XxxService?router=script\u0026amp;type=js\u0026amp;rule=ENCODE(function{...})) 获取路由器：\nurl.setProtocol(url.getParameter(\u0026#34;router\u0026#34;, \u0026#34;script\u0026#34;)) GETROUTE(script://registry-address/com.xxx.XxxService?type=js\u0026amp;rule=ENCODE(function{...})) 5. 从文件加载路由规则 从文件加载路由规则：\nGETROUTE(file://path/file.js?router=script) 获取路由器：\nurl.setProtocol(url.getParameter(\u0026#34;router\u0026#34;, \u0026#34;script\u0026#34;)).addParameter(\u0026#34;type\u0026#34;, SUFFIX(file)).addParameter(\u0026#34;rule\u0026#34;, READ(file)) GETROUTE(script://path/file.js?type=js\u0026amp;rule=ENCODE(function{...})) 调用参数  path 服务路径 group 服务分组 version 服务版本 dubbo 使用的 dubbo 版本 token 验证令牌 timeout 调用超时  扩展点的加载 1. 自适应扩展点 ExtensionLoader 加载扩展点时，会检查扩展点的属性（通过set方法判断），如该属性是扩展点类型，则会注入扩展点对象。因为注入时不能确定使用哪个扩展点（在使用时确定），所以注入的是一个自适应扩展（一个代理）。自适应扩展点调用时，选取一个真正的扩展点，并代理到其上完成调用。Dubbo 是根据调用方法参数（上面有调用哪个扩展点的信息）来选取一个真正的扩展点。","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中为同一个服务配置多个版本","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"多版本","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/multi-versions/","lvl3":37,"lvl4":"docs","lvl5":null,"objectID":"27ef728bee11ebc9d75f36f1a24cb7dc","permalink":"/zh/docs/v2.7/user/examples/multi-versions/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/multi-versions/","summary":"当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。\n可以按照以下的步骤进行版本迁移：\n 在低压力时间段，先升级一半提供者为新版本 再将所有消费者升级为新版本 然后将剩下的一半提供者升级为新版本  老版本服务提供者配置：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; version=\u0026#34;1.0.0\u0026#34; /\u0026gt; 新版本服务提供者配置：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; version=\u0026#34;2.0.0\u0026#34; /\u0026gt; 老版本服务消费者配置：\n\u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; version=\u0026#34;1.0.0\u0026#34; /\u0026gt; 新版本服务消费者配置：\n\u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; version=\u0026#34;2.0.0\u0026#34; /\u0026gt; 如果不需要区分版本，可以按照以下的方式配置 [^1]：\n提示 2.2.0 以上版本支持  \u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; version=\u0026#34;*\u0026#34; /\u0026gt; ","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Dubbo 工程中的编码约定","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"编码约定","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/coding/","lvl3":134,"lvl4":"docs","lvl5":null,"objectID":"e10f30bb6ac7a2a863dd77941a2612ac","permalink":"/zh/docs/v2.7/dev/coding/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/coding/","summary":"代码风格 Dubbo 的源代码和 JavaDoc 遵循以下的规范：\n Code Conventions for the Java Programming Language How to Write Doc Comments for the Javadoc Tool  异常和日志  尽可能携带完整的上下文信息，比如出错原因，出错的机器地址，调用对方的地址，连的注册中心地址，使用 Dubbo 的版本等。 尽量将直接原因写在最前面，所有上下文信息，在原因后用键值对显示。 抛出异常的地方不用打印日志，由最终处理异常者决定打印日志的级别，吃掉异常必需打印日志。 打印 ERROR 日志表示需要报警，打印 WARN 日志表示可以自动恢复，打印 INFO 表示正常信息或完全不影响运行。 建议应用方在监控中心配置 ERROR 日志实时报警，WARN 日志每周汇总发送通知。 RpcException 是 Dubbo 对外的唯一异常类型，所有内部异常，如果要抛出给用户，必须转为 RpcException。 RpcException 不能有子类型，所有类型信息用 ErrorCode 标识，以便保持兼容。  配置和 URL  配置对象属性首字母小写，多个单词用驼峰命名 1。 配置属性全部用小写，多个单词用\u0026quot;-\u0026ldquo;号分隔 2。 URL参数全部用小写，多个单词用\u0026rdquo;.\u0026ldquo;号分隔 3。 尽可能用 URL 传参，不要自定义 Map 或其它上下文格式，配置信息也转成 URL 格式使用。 尽量减少 URL 嵌套，保持 URL 的简洁性。  单元和集成测试  单元测试统一用 JUnit 和 EasyMock，集成测试用 TestNG，数据库测试用 DBUnit。 保持单元测试用例的运行速度，不要将性能和大的集成用例放在单元测试中。 保持单元测试的每个用例都用 try.","text":null,"weight":12},{"authors":null,"date":-62135596800,"description":"Best practices of using dubbo","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Best practice","lvl1":"docs","lvl2":"/docs/v2.7/user/best-practice/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4870380d8979c1dbcb4c4bac57c2b54c","permalink":"/docs/v2.7/user/best-practice/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/best-practice/","summary":"","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Compiler Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/compiler/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c6525c8052a8cdd85ae42e12809aa07a","permalink":"/docs/v2.7/dev/impls/compiler/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/compiler/","summary":"","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Configuration Center Extensions","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/config-center/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ea8249f8df2ebc016f112938b80f749a","permalink":"/docs/v2.7/dev/impls/config-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/config-center/","summary":"","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"Group merger in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Group Merger","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/group-merger/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"5171ab609a7169eff4de0ec81d7e2599","permalink":"/docs/v2.7/user/examples/group-merger/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/group-merger/","summary":"","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"Dubbo compatibility test","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Compatibility Test","lvl1":"docs","lvl2":"/docs/v2.7/dev/tck/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1b0164d3f483d3e94da7867c8867dc61","permalink":"/docs/v2.7/dev/tck/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/tck/","summary":"","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"Dubbo 项目的技术兼容性测试","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"技术兼容性测试","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/tck/","lvl3":28,"lvl4":"docs","lvl5":null,"objectID":"1b0164d3f483d3e94da7867c8867dc61","permalink":"/zh/docs/v2.7/dev/tck/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/tck/","summary":"Dubbo 的协议，通讯，序列化，注册中心，负载均策等扩展点，都有多种可选策略，以应对不同应用场景，而我们的测试用例很分散，当用户自己需要加一种新的实现时，总是不确定能否满足扩展点的完整契约。\n所以，我们需要对核心扩展点写 TCK (Technology Compatibility Kit)，用户增加一种扩展实现，只需通过 TCK，即可确保与框架的其它部分兼容运行，可以有效提高整体健壮性，也方便第三方扩展者接入，加速开源社区的成熟。\n开源社区的行知同学已着手研究这一块，他的初步想法是借鉴 JBoss 的 CDI-TCK，做一个 Dubbo 的 TCK 基础框架，在此之上实现 Dubbo 的扩展点 TCK 用例。\n参见：http://docs.jboss.org/cdi/tck/reference/1.0.1-Final/html/introduction.html\n如果大家有兴趣，也可以一起研究，和行知一块讨论。\nProtocol TCK  TODO\n Registry TCK  TODO\n ","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"通过分组聚合按组合并返回结果","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"分组聚合","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/group-merger/","lvl3":61,"lvl4":"docs","lvl5":null,"objectID":"5171ab609a7169eff4de0ec81d7e2599","permalink":"/zh/docs/v2.7/user/examples/group-merger/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/group-merger/","summary":"按组合并返回结果，比如菜单服务，接口一样，但有多种实现，用group区分，现在消费方需从每种group中调用一次返回结果，合并结果返回，这样就可以实现聚合菜单项。\n相关代码可以参考 dubbo 项目中的示例\n配置 搜索所有分组\n\u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;*\u0026#34; merger=\u0026#34;true\u0026#34; /\u0026gt; 合并指定分组\n\u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;aaa,bbb\u0026#34; merger=\u0026#34;true\u0026#34; /\u0026gt; 指定方法合并结果，其它未指定的方法，将只调用一个 Group\n\u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;getMenuItems\u0026#34; merger=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 某个方法不合并结果，其它都合并结果\n\u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;*\u0026#34; merger=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;getMenuItems\u0026#34; merger=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 指定合并策略，缺省根据返回值类型自动匹配，如果同一类型有两个合并器时，需指定合并器的名称\n提示 参见：合并结果扩展  \u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;getMenuItems\u0026#34; merger=\u0026#34;mymerge\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 指定合并方法，将调用返回结果的指定方法进行合并，合并方法的参数类型必须是返回结果类型本身\n\u0026lt;dubbo:reference interface=\u0026#34;com.xxx.MenuService\u0026#34; group=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;getMenuItems\u0026#34; merger=\u0026#34;.addAll\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt;  提示 从 2.1.0 版本开始支持  ","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"分包, 粒度, 版本, 兼容性, 枚举, 序列化, 异常","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务化最佳实践","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/best-practice/","lvl3":85,"lvl4":"docs","lvl5":null,"objectID":"4870380d8979c1dbcb4c4bac57c2b54c","permalink":"/zh/docs/v2.7/user/best-practice/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/best-practice/","summary":"分包 建议将服务接口、服务模型、服务异常等均放在 API 包中，因为服务模型和异常也是 API 的一部分，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。\n如果需要，也可以考虑在 API 包中放置一份 Spring 的引用配置，这样使用方只需在 Spring 加载过程中引用此配置即可。配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。\n粒度 服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。\n服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。\n不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。\n版本 每个接口都应定义版本号，为后续不兼容升级提供可能，如： \u0026lt;dubbo:service interface=\u0026quot;com.xxx.XxxService\u0026quot; version=\u0026quot;1.0\u0026quot; /\u0026gt;。\n建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。\n当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。\n兼容性 服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。\n各协议的兼容性不同，参见：服务协议\n枚举值 如果是完备集，可以用 Enum，比如：ENABLE, DISABLE。\n如果是业务种类，以后明显会有类型增加，不建议用 Enum，可以用 String 代替。\n如果是在返回值中用了 Enum，并新增了 Enum 值，建议先升级服务消费方，这样服务提供方不会返回新值。\n如果是在传入参数中用了 Enum，并新增了 Enum 值，建议先升级服务提供方，这样服务消费方不会传入新值。\n序列化 服务参数及返回值建议使用 POJO 对象，即通过 setter, getter 方法表示属性的对象。\n服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。\n服务参数及返回值都必须是传值调用，而不能是传引用调用，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。\n异常 建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。\n如果担心性能问题，在必要时，可以通过 override 掉异常类的 fillInStackTrace() 方法为空方法，使其不拷贝栈信息。\n查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 try...catch，并且不能进行有效处理。\n服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"编译器扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/compiler/","lvl3":49,"lvl4":"docs","lvl5":null,"objectID":"c6525c8052a8cdd85ae42e12809aa07a","permalink":"/zh/docs/v2.7/dev/impls/compiler/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/compiler/","summary":"扩展说明 Java 代码编译器，用于动态生成字节码，加速调用。\n扩展接口 org.apache.dubbo.common.compiler.Compiler\n扩展配置 自动加载\n已知扩展  org.apache.dubbo.common.compiler.support.JdkCompiler org.apache.dubbo.common.compiler.support.JavassistCompiler  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxCompiler.java (实现Compiler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.compiler.Compiler (纯文本文件，内容为：xxx=com.xxx.XxxCompiler) XxxCompiler.java：\npackage com.xxx; import org.apache.dubbo.common.compiler.Compiler; public class XxxCompiler implements Compiler { public Object getExtension(Class\u0026lt;?\u0026gt; type, String name) { // ...  } } META-INF/dubbo/org.apache.dubbo.common.compiler.Compiler：\nxxx=com.xxx.XxxCompiler ","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 配置中心扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/config-center/","lvl3":138,"lvl4":"docs","lvl5":null,"objectID":"ea8249f8df2ebc016f112938b80f749a","permalink":"/zh/docs/v2.7/dev/impls/config-center/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/config-center/","summary":"设计目的 配置中心的核心功能是作为 Key-Value 存储，Dubbo 框架告知配置中心其关心的 key，配置中心返回该key对应的 value 值。\n按照应用场景划分，配置中心在 Dubbo 框架中主要承担以下职责：\n 作为外部化配置中心，即存储 dubbo.properties 配置文件，此时，key 值通常为文件名如 dubbo.properties，value 则为配置文件内容。 存储单个配置项，如各种开关项、常量值等。 存储服务治理规则，此时key通常按照 \u0026ldquo;服务名+规则类型\u0026rdquo; 的格式来组织，而 value 则为具体的治理规则。  为了进一步实现对 key-value 的分组管理，Dubbo 的配置中心还加入了 namespace、group 的概念，这些概念在很多专业的第三方配置中心中都有体现，通常情况下，namespace 用来隔离不同的租户，group 用来对同一租户的key集合做分组。\n当前，Dubbo 配置中心实现了对 Zookeeper、Nacos、Etcd、Consul、Apollo 的对接，接下来我们具体看一下 Dubbo 抽象的配置中心是怎么映射到具体的第三方实现中的。\n扩展接口  org.apache.dubbo.configcenter.DynamicConfigurationFactory org.apache.dubbo.configcenter.DynamicConfiguration  已知扩展  org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory org.apache.dubbo.configcenter.support.nacos.NacosDynamicConfigurationFactory org.apache.dubbo.configcenter.support.etcd.EtcdDynamicConfigurationFactory org.apache.dubbo.configcenter.consul.ConsulDynamicConfigurationFactory org.apache.dubbo.configcenter.support.apollo.ApolloDynamicConfigurationFactory org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfigurationFactory  实现原理 Zookeeper zookeeper提供了一个树状的存储模型，其实现原理如下：\nnamespace, group, key 等分别对应不同层级的 ZNode 节点，而 value 则作为根 ZNode 节点的值存储。\n  外部化配置中心 dubbo.properties","text":null,"weight":13},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dispatcher Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/dispatcher/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"c66feb9d59a5b876fc8a3d755d27d3e6","permalink":"/docs/v2.7/dev/impls/dispatcher/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/dispatcher/","summary":"","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"Parameter validation in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Parameter Validation","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/parameter-validation/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"40450e945abcc1db0adc6bd948d725d5","permalink":"/docs/v2.7/user/examples/parameter-validation/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/parameter-validation/","summary":"","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"Recommended usage for use dubbo","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Recommended usage","lvl1":"docs","lvl2":"/docs/v2.7/user/recommend/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"95ce85b2d6c32f29f3380aac3500d04b","permalink":"/docs/v2.7/user/recommend/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/recommend/","summary":"","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中进行参数验证","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"参数验证","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/parameter-validation/","lvl3":344,"lvl4":"docs","lvl5":null,"objectID":"40450e945abcc1db0adc6bd948d725d5","permalink":"/zh/docs/v2.7/user/examples/parameter-validation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/examples/parameter-validation/","summary":"参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证。\nMaven 依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.validation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.2.0.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 示例 参数标注示例 import java.io.Serializable; import java.util.Date; import javax.validation.constraints.Future; import javax.validation.constraints.Max; import javax.validation.constraints.Min; import javax.validation.constraints.NotNull; import javax.validation.constraints.Past; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; public class ValidationParameter implements Serializable { private static final long serialVersionUID = 7158911668568000392L; @NotNull // 不允许为空  @Size(min = 1, max = 20) // 长度或大小范围  private String name; @NotNull(groups = ValidationService.","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"Dubbo 推荐用法举例","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"推荐用法","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/recommend/","lvl3":290,"lvl4":"docs","lvl5":null,"objectID":"95ce85b2d6c32f29f3380aac3500d04b","permalink":"/zh/docs/v2.7/user/recommend/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/recommend/","summary":"在 Provider 端尽量多配置 Consumer 端属性 原因如下：\n 作服务的提供方，比服务消费方更清楚服务的性能参数，如调用的超时时间、合理的重试次数等 在 Provider 端配置后，Consumer 端不配置则会使用 Provider 端的配置，即 Provider 端的配置可以作为 Consumer 的缺省值 1。否则，Consumer 会使用 Consumer 端的全局设置，这对于 Provider 是不可控的，并且往往是不合理的  Provider 端尽量多配置 Consumer 端的属性，让 Provider 的实现者一开始就思考 Provider 端的服务特点和服务质量等问题。\n示例：\n\u0026lt;dubbo:service interface=\u0026#34;com.alibaba.hello.api.HelloService\u0026#34; version=\u0026#34;1.0.0\u0026#34; ref=\u0026#34;helloService\u0026#34; timeout=\u0026#34;300\u0026#34; retries=\u0026#34;2\u0026#34; loadbalance=\u0026#34;random\u0026#34; actives=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.alibaba.hello.api.WorldService\u0026#34; version=\u0026#34;1.0.0\u0026#34; ref=\u0026#34;helloService\u0026#34; timeout=\u0026#34;300\u0026#34; retries=\u0026#34;2\u0026#34; loadbalance=\u0026#34;random\u0026#34; actives=\u0026#34;0\u0026#34; \u0026gt; \u0026lt;dubbo:method name=\u0026#34;findAllPerson\u0026#34; timeout=\u0026#34;10000\u0026#34; retries=\u0026#34;9\u0026#34; loadbalance=\u0026#34;leastactive\u0026#34; actives=\u0026#34;5\u0026#34; /\u0026gt; \u0026lt;dubbo:service/\u0026gt; 建议在 Provider 端配置的 Consumer 端属性有：\n timeout：方法调用的超时时间 retries：失败重试次数，缺省是 2 2 loadbalance：负载均衡算法 3，缺省是随机 random。还可以配置轮询 roundrobin、最不活跃优先 4 leastactive 和一致性哈希 consistenthash 等 actives：消费者端的最大并发调用限制，即当 Consumer 对一个服务的并发调用到上限后，新调用会阻塞直到超时，在方法上配置 dubbo:method 则针对该方法进行并发限制，在接口上配置 dubbo:service，则针对该服务进行并发限制  详细配置说明请参考：Dubbo配置参考手册","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"消息派发扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/dispatcher/","lvl3":57,"lvl4":"docs","lvl5":null,"objectID":"c66feb9d59a5b876fc8a3d755d27d3e6","permalink":"/zh/docs/v2.7/dev/impls/dispatcher/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/dispatcher/","summary":"扩展说明 通道信息派发器，用于指定线程池模型。\n扩展接口 org.apache.dubbo.remoting.Dispatcher\n扩展配置 \u0026lt;dubbo:protocol dispatcher=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置dispatcher属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider dispatcher=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcher org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatcher org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcher org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcher org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxDispatcher.java (实现Dispatcher接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Dispatcher (纯文本文件，内容为：xxx=com.xxx.XxxDispatcher) XxxDispatcher.java：\npackage com.xxx; import org.apache.dubbo.remoting.Dispatcher; public class XxxDispatcher implements Dispatcher { public Group lookup(URL url) { // ...  } } META-INF/dubbo/org.apache.dubbo.remoting.Dispatcher：\nxxx=com.xxx.XxxDispatcher ","text":null,"weight":14},{"authors":null,"date":-62135596800,"description":"Cache result in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Cache Result","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/result-cache/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"900a6ebc6dc34c074f2da86aa656ce01","permalink":"/docs/v2.7/user/examples/result-cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/result-cache/","summary":"","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"Dubbo capacity plan","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Capacity plan","lvl1":"docs","lvl2":"/docs/v2.7/user/capacity-plan/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"84a7308d7882ddebd2382278ae873fc3","permalink":"/docs/v2.7/user/capacity-plan/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/capacity-plan/","summary":"","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"ThreadPool Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/threadpool/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7c22d55d1b3312d61830bec7260a5499","permalink":"/docs/v2.7/dev/impls/threadpool/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/threadpool/","summary":"","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"Dubbo 应用容量规划参考","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"容量规划","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/capacity-plan/","lvl3":56,"lvl4":"docs","lvl5":null,"objectID":"84a7308d7882ddebd2382278ae873fc3","permalink":"/zh/docs/v2.7/user/capacity-plan/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/capacity-plan/","summary":"以下数据供参考：\n使用 Dubbo 的会员服务项目  每天接收 4 亿次远程调用 使用 12 台网站标配机器提供服务（8 核 CPU，8G 内存） 平均负载在 1 以下（对于 8 核 CPU 负载很低） 平均响应时间 2.3 到 2.5 毫秒，网络开销约占 1.5 到 1.6 毫秒（和数据包大小有关）  使用 Dubbo 的产品授权服务项目  每天接收 3 亿次远程调用 使用 8 台网站标配机器提供服务（8 核CPU，8G 内存） 平均负载在 1 以下（对于 8 核 CPU 负载很低） 平均响应时间 1.4 到 2.8 毫秒，网络开销约占 1.0 到 1.1 毫秒（和数据包大小有关）  ","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"线程池扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/threadpool/","lvl3":55,"lvl4":"docs","lvl5":null,"objectID":"7c22d55d1b3312d61830bec7260a5499","permalink":"/zh/docs/v2.7/dev/impls/threadpool/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/threadpool/","summary":"扩展说明 服务提供方线程池实现策略，当服务器收到一个请求时，需要在线程池中创建一个线程去执行服务提供方业务逻辑。\n扩展接口 org.apache.dubbo.common.threadpool.ThreadPool\n扩展配置 \u0026lt;dubbo:protocol threadpool=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置threadpool时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider threadpool=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.common.threadpool.FixedThreadPool org.apache.dubbo.common.threadpool.CachedThreadPool  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxThreadPool.java (实现ThreadPool接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.threadpool.ThreadPool (纯文本文件，内容为：xxx=com.xxx.XxxThreadPool) XxxThreadPool.java：\npackage com.xxx; import org.apache.dubbo.common.threadpool.ThreadPool; import java.util.concurrent.Executor; public class XxxThreadPool implements ThreadPool { public Executor getExecutor() { // ...  } } META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool：\nxxx=com.xxx.XxxThreadPool ","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"通过缓存结果加速访问速度","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"结果缓存","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/result-cache/","lvl3":32,"lvl4":"docs","lvl5":null,"objectID":"900a6ebc6dc34c074f2da86aa656ce01","permalink":"/zh/docs/v2.7/user/examples/result-cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/result-cache/","summary":"结果缓存，用于加速热门数据的访问速度，Dubbo 提供声明式缓存，以减少用户加缓存的工作量。\n缓存类型  lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存。 threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问。 jcache 与 JSR107 集成，可以桥接各种缓存实现。  缓存类型可扩展，参见：缓存扩展\n配置 \u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; cache=\u0026#34;lru\u0026#34; /\u0026gt; 或：\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;findBar\u0026#34; cache=\u0026#34;lru\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt;  提示 2.1.0 以上版本支持。\n示例代码\n ","text":null,"weight":15},{"authors":null,"date":-62135596800,"description":"Generic reference in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Generic Reference","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/generic-reference/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e483ede777f89f248d6c231fb3f71698","permalink":"/docs/v2.7/user/examples/generic-reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/generic-reference/","summary":"","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"Dubbo performance report","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Performance","lvl1":"docs","lvl2":"/docs/v2.7/user/perf-test/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e30bc384e4e9f4f1fc1f9128bc5c69ed","permalink":"/docs/v2.7/user/perf-test/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/perf-test/","summary":"","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Serialization Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/serialize/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"32c40e6bc7317a73e637fdca50a7f43b","permalink":"/docs/v2.7/dev/impls/serialize/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/serialize/","summary":"","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"实现一个通用的服务测试框架，可通过 `GenericService` 调用所有服务实现","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用泛化调用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/generic-reference/","lvl3":189,"lvl4":"docs","lvl5":null,"objectID":"e483ede777f89f248d6c231fb3f71698","permalink":"/zh/docs/v2.7/user/examples/generic-reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/generic-reference/","summary":"泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的服务测试框架，可通过 GenericService 调用所有服务实现。\n通过 Spring 使用泛化调用 在 Spring 配置申明 generic=\u0026quot;true\u0026quot;：\n\u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; generic=\u0026#34;true\u0026#34; /\u0026gt; 在 Java 代码获取 barService 并开始泛化调用：\nGenericService barService = (GenericService) applicationContext.getBean(\u0026#34;barService\u0026#34;); Object result = barService.$invoke(\u0026#34;sayHello\u0026#34;, new String[] { \u0026#34;java.lang.String\u0026#34; }, new Object[] { \u0026#34;World\u0026#34; }); 通过 API 方式使用泛化调用 import org.apache.dubbo.rpc.service.GenericService; ... // 引用远程服务 // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ReferenceConfig\u0026lt;GenericService\u0026gt; reference = new ReferenceConfig\u0026lt;GenericService\u0026gt;(); // 弱类型接口名 reference.setInterface(\u0026#34;com.xxx.XxxService\u0026#34;); reference.setVersion(\u0026#34;1.0.0\u0026#34;); // 声明为泛化接口 reference.setGeneric(true); // 用org.apache.dubbo.rpc.service.GenericService可以替代所有接口引用 GenericService genericService = reference.","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"序列化扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/serialize/","lvl3":87,"lvl4":"docs","lvl5":null,"objectID":"32c40e6bc7317a73e637fdca50a7f43b","permalink":"/zh/docs/v2.7/dev/impls/serialize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/serialize/","summary":"扩展说明 将对象转成字节流，用于网络传输，以及将字节流转为对象，用于在收到字节流数据后还原成对象。\n扩展接口  org.apache.dubbo.common.serialize.Serialization org.apache.dubbo.common.serialize.ObjectInput org.apache.dubbo.common.serialize.ObjectOutput  扩展配置 \u0026lt;!-- 协议的序列化方式 --\u0026gt; \u0026lt;dubbo:protocol serialization=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置serialization时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider serialization=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.common.serialize.dubbo.DubboSerialization org.apache.dubbo.common.serialize.hessian.Hessian2Serialization org.apache.dubbo.common.serialize.java.JavaSerialization org.apache.dubbo.common.serialize.java.CompactedJavaSerialization  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxSerialization.java (实现Serialization接口) |-XxxObjectInput.java (实现ObjectInput接口) |-XxxObjectOutput.java (实现ObjectOutput接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization) XxxSerialization.java：\npackage com.xxx; import org.apache.dubbo.common.serialize.Serialization; import org.apache.dubbo.common.serialize.ObjectInput; import org.apache.dubbo.common.serialize.ObjectOutput; public class XxxSerialization implements Serialization { public ObjectOutput serialize(Parameters parameters, OutputStream output) throws IOException { return new XxxObjectOutput(output); } public ObjectInput deserialize(Parameters parameters, InputStream input) throws IOException { return new XxxObjectInput(input); } } META-INF/dubbo/org.","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"Dubbo 2.0 性能测试报告","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"性能测试报告","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/perf-test/","lvl3":448,"lvl4":"docs","lvl5":null,"objectID":"e30bc384e4e9f4f1fc1f9128bc5c69ed","permalink":"/zh/docs/v2.7/user/perf-test/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/user/perf-test/","summary":"测试说明  本次性能测试，测试了 dubbo 2.0 所有支持的协议在不同大小和数据类型下的表现，并与 dubbo 1.0 进行了对比。 整体性能相比 1.0 有了提升，平均提升 10%，使用 dubbo 2.0 新增的 dubbo 序列化还能获得 10%~50% 的性能提升，详见下面的性能数据。 稳定性测试中由于将底层通信框架从 mina 换成 netty，old 区对象的增长大大减少，50 小时运行，增长不到 200m，无 fullgc。 存在的问题：在 50k 数据的时候 2.0 性能不如 1.0，怀疑可能是缓冲区设置的问题，下版本会进一步确认。  测试环境 硬件部署与参数调整    机型 CPU 内存 网络 磁盘 内核     Tecal BH620 model name : Intel(R) Xeon(R) CPU E5520 @ 2.27GHz cache size : 8192 KB processor_count : 16 Total System Memory: 6G Hardware Memory Info: Size: 4096MB eth0: Link is up at 1000 Mbps, full duplex.","text":null,"weight":16},{"authors":null,"date":-62135596800,"description":"Generic service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Generic Service","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/generic-service/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1e21cb52fc6e23de37d7cd3997045a21","permalink":"/docs/v2.7/user/examples/generic-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/generic-service/","summary":"","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"使用 IDL 定义服务","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Protobuf","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/protobuf-idl/","lvl3":84,"lvl4":"docs","lvl5":null,"objectID":"d911e0febef2fd7ad7fb5835348dff0b","permalink":"/zh/docs/v2.7/user/examples/protobuf-idl/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/protobuf-idl/","summary":"当前 Dubbo 的服务定义和具体的编程语言绑定，没有提供一种语言中立的服务描述格式，比如 Java 就是定义 Interface 接口，到了其他语言又得重新以另外的格式定义一遍。 2.7.5 版本通过支持 Protobuf IDL 实现了语言中立的服务定义。\n日后，不论我们使用什么语言版本来开发 Dubbo 服务，都可以直接使用 IDL 定义如下服务，具体请参见示例\nsyntax = \u0026#34;proto3\u0026#34;; option java_multiple_files = true; option java_package = \u0026#34;org.apache.dubbo.demo\u0026#34;; option java_outer_classname = \u0026#34;DemoServiceProto\u0026#34;; option objc_class_prefix = \u0026#34;DEMOSRV\u0026#34;; package demoservice; // The demo service definition. service DemoService { rpc SayHello (HelloRequest) returns (HelloReply) {} } // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } ","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"对 Goolgle Protobuf 对象进行泛化调用","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"GoogleProtobuf 对象泛化调用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/pb-generic-reference/","lvl3":192,"lvl4":"docs","lvl5":null,"objectID":"b9f6f0e6ff4366da9b9e42641e2c5175","permalink":"/zh/docs/v2.7/user/examples/pb-generic-reference/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/pb-generic-reference/","summary":"泛化接口调用方式主要用于客户端没有 API 接口及模型类元的情况，参考 泛化调用。 一般泛化调用只能用于生成的服务参数为POJO的情况，而 GoogleProtobuf 的对象是基于 Builder 生成的非正常POJO，可以通过 protobuf-json 泛化调用。\nGoogleProtobuf 序列化相关的Demo可以参考 protobuf-demo\n通过Spring对Goolgle Protobuf对象泛化调用 在 Spring 中配置声明 generic = \u0026ldquo;protobuf-json\u0026rdquo;\n\u0026lt;dubbo:reference id=\u0026#34;barService\u0026#34; interface=\u0026#34;com.foo.BarService\u0026#34; generic=\u0026#34;protobuf-json\u0026#34; /\u0026gt; 在 Java 代码获取 barService 并开始泛化调用：\nGenericService barService = (GenericService) applicationContext.getBean(\u0026#34;barService\u0026#34;); Object result = barService.$invoke(\u0026#34;sayHello\u0026#34;,new String[]{\u0026#34;org.apache.dubbo.protobuf.GooglePbBasic$CDubboGooglePBRequestType\u0026#34;}, new Object[]{\u0026#34;{\\\u0026#34;double\\\u0026#34;:0.0,\\\u0026#34;float\\\u0026#34;:0.0,\\\u0026#34;bytesType\\\u0026#34;:\\\u0026#34;Base64String\\\u0026#34;,\\\u0026#34;int32\\\u0026#34;:0}\u0026#34;}); 通过 API 方式对 Goolgle Protobuf 对象泛化调用 ReferenceConfig\u0026lt;GenericService\u0026gt; reference = new ReferenceConfig\u0026lt;GenericService\u0026gt;(); // 弱类型接口名 reference.setInterface(GenericService.class.getName()); reference.setInterface(\u0026#34;com.xxx.XxxService\u0026#34;); // 声明为Protobuf-json reference.setGeneric(Constants.GENERIC_SERIALIZATION_PROTOBUF); GenericService genericService = reference.get(); Map\u0026lt;String, Object\u0026gt; person = new HashMap\u0026lt;String, Object\u0026gt;(); person.","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"Dubbo test coverage report","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Test coverage report","lvl1":"docs","lvl2":"/docs/v2.7/user/coveragence/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8e74b96022ae3417db6474b7a83751ae","permalink":"/docs/v2.7/user/coveragence/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/coveragence/","summary":"","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Transporter Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/remoting/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4e6b9ac2d6eb48aae425195ce7d83b63","permalink":"/docs/v2.7/dev/impls/remoting/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/remoting/","summary":"","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"实现泛化调用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/generic-service/","lvl3":88,"lvl4":"docs","lvl5":null,"objectID":"1e21cb52fc6e23de37d7cd3997045a21","permalink":"/zh/docs/v2.7/user/examples/generic-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/generic-service/","summary":"泛接口实现方式主要用于服务器端没有 API 接口及模型类元的情况，参数及返回值中的所有 POJO 均用 Map 表示，通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。\n在 Java 代码中实现 GenericService 接口：\npackage com.foo; public class MyGenericService implements GenericService { public Object $invoke(String methodName, String[] parameterTypes, Object[] args) throws GenericException { if (\u0026#34;sayHello\u0026#34;.equals(methodName)) { return \u0026#34;Welcome \u0026#34; + args[0]; } } } 通过 Spring 暴露泛化实现 在 Spring 配置申明服务的实现：\n\u0026lt;bean id=\u0026#34;genericService\u0026#34; class=\u0026#34;com.foo.MyGenericService\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; ref=\u0026#34;genericService\u0026#34; /\u0026gt; 通过 API 方式暴露泛化实现 ... // 用org.apache.dubbo.rpc.service.GenericService可以替代所有接口实现 GenericService xxxService = new XxxGenericService(); // 该实例很重量，里面封装了所有与注册中心及服务提供方连接，请缓存 ServiceConfig\u0026lt;GenericService\u0026gt; service = new ServiceConfig\u0026lt;GenericService\u0026gt;(); // 弱类型接口名 service.","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"Dubbo 初始的测试覆盖率报告，和现在基于 Codecov 的报告","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"测试覆盖率报告","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/coveragence/","lvl3":17,"lvl4":"docs","lvl5":null,"objectID":"8e74b96022ae3417db6474b7a83751ae","permalink":"/zh/docs/v2.7/user/coveragence/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/coveragence/","summary":" v2.0 Codecov报表 , 从 2017-12-29 后开始统计 测试覆盖率为 :  , 可以从 https://codecov.io/gh/apache/dubbo 页面得到覆盖率报表 v1.0 基于 2.0.12 版本，统计于 2012-02-03  ","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"网络传输扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/remoting/","lvl3":204,"lvl4":"docs","lvl5":null,"objectID":"4e6b9ac2d6eb48aae425195ce7d83b63","permalink":"/zh/docs/v2.7/dev/impls/remoting/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/remoting/","summary":"扩展说明 远程通讯的服务器及客户端传输实现。\n扩展接口  org.apache.dubbo.remoting.Transporter org.apache.dubbo.remoting.Server org.apache.dubbo.remoting.Client  扩展配置 \u0026lt;!-- 服务器和客户端使用相同的传输实现 --\u0026gt; \u0026lt;dubbo:protocol transporter=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 服务器和客户端使用不同的传输实现 --\u0026gt; \u0026lt;dubbo:protocol server=\u0026#34;xxx\u0026#34; client=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置transporter/server/client属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider transporter=\u0026#34;xxx\u0026#34; server=\u0026#34;xxx\u0026#34; client=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.remoting.transport.transporter.netty.NettyTransporter org.apache.dubbo.remoting.transport.transporter.mina.MinaTransporter org.apache.dubbo.remoting.transport.transporter.grizzly.GrizzlyTransporter  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxTransporter.java (实现Transporter接口) |-XxxServer.java (实现Server接口) |-XxxClient.java (实现Client接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.Transporter (纯文本文件，内容为：xxx=com.xxx.XxxTransporter) XxxTransporter.java：\npackage com.xxx; import org.apache.dubbo.remoting.Transporter; public class XxxTransporter implements Transporter { public Server bind(URL url, ChannelHandler handler) throws RemotingException { return new XxxServer(url, handler); } public Client connect(URL url, ChannelHandler handler) throws RemotingException { return new XxxClient(url, handler); } } XxxServer.","text":null,"weight":17},{"authors":null,"date":-62135596800,"description":"Run Dubbo benchmark suite","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Benchmark Suite","lvl1":"docs","lvl2":"/docs/v2.7/user/benchmark-tool/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8664bb36f8526d8f836e296aec381c16","permalink":"/docs/v2.7/user/benchmark-tool/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/benchmark-tool/","summary":"","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"Echo testing service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Echo Testing Service","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/echo-service/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e83a9020be59c0aa3eca86a35482159c","permalink":"/docs/v2.7/user/examples/echo-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/echo-service/","summary":"","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Exchanger Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/exchanger/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ea1fac2833c45bc18396eb07531500a5","permalink":"/docs/v2.7/dev/impls/exchanger/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/exchanger/","summary":"","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"信息交换扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/exchanger/","lvl3":109,"lvl4":"docs","lvl5":null,"objectID":"ea1fac2833c45bc18396eb07531500a5","permalink":"/zh/docs/v2.7/dev/impls/exchanger/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/exchanger/","summary":"扩展说明 基于传输层之上，实现 Request-Response 信息交换语义。\n扩展接口  org.apache.dubbo.remoting.exchange.Exchanger org.apache.dubbo.remoting.exchange.ExchangeServer org.apache.dubbo.remoting.exchange.ExchangeClient  扩展配置 \u0026lt;dubbo:protocol exchanger=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置exchanger属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider exchanger=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展 org.apache.dubbo.remoting.exchange.exchanger.HeaderExchanger\n扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxExchanger.java (实现Exchanger接口) |-XxxExchangeServer.java (实现ExchangeServer接口) |-XxxExchangeClient.java (实现ExchangeClient接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.exchange.Exchanger (纯文本文件，内容为：xxx=com.xxx.XxxExchanger) XxxExchanger.java：\npackage com.xxx; import org.apache.dubbo.remoting.exchange.Exchanger; public class XxxExchanger implements Exchanger { public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeServer(url, handler); } public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException { return new XxxExchangeClient(url, handler); } } XxxExchangeServer.","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"通过回声测试检测 Dubbo 服务是否可用","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"回声测试","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/echo-service/","lvl3":32,"lvl4":"docs","lvl5":null,"objectID":"e83a9020be59c0aa3eca86a35482159c","permalink":"/zh/docs/v2.7/user/examples/echo-service/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/echo-service/","summary":"回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。\n所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。\nSpring 配置：\n\u0026lt;dubbo:reference id=\u0026#34;memberService\u0026#34; interface=\u0026#34;com.xxx.MemberService\u0026#34; /\u0026gt; 代码：\n// 远程服务引用 MemberService memberService = ctx.getBean(\u0026#34;memberService\u0026#34;); EchoService echoService = (EchoService) memberService; // 强制转型为EchoService  // 回声测试可用性 String status = echoService.$echo(\u0026#34;OK\u0026#34;); assert(status.equals(\u0026#34;OK\u0026#34;)); ","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"如何使用基准测试工具包进行压力测试","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"基准测试工具包","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/benchmark-tool/","lvl3":38,"lvl4":"docs","lvl5":null,"objectID":"8664bb36f8526d8f836e296aec381c16","permalink":"/zh/docs/v2.7/user/benchmark-tool/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/benchmark-tool/","summary":"下载源码： git clone https://github.com/apache/dubbo.git 编译benchmark: cd dubbo/dubbo-test/dubbo-test-benchmark; mvn clean install 解压 benchmark压缩包： dubbo/dubbo-test/dubbo-test-benchmark/target/dubbo-test-benchmark-2.6.2-SNAPSHOT.tar.gz  阅读ReadMe.txt（内容如下，请以压缩包内的为准）\n  新建一个benchmark工程，如demo.benchmark\n  导入自己服务的接口api包和dubbo.benchmark.jar(解压dubbo.benchmark.tar.gz，在lib目录下)\n  新建一个类，实现AbstractClientRunnable\n 实现父类的构造函数 实现invoke方法，通过serviceFactory创建本地接口代理，并实现自己的业务逻辑，如下  public Object invoke(ServiceFactory serviceFactory) { DemoService demoService = (DemoService) serviceFactory.get(DemoService.class); return demoService.sendRequest(\u0026#34;hello\u0026#34;); }   将自己的benchmark工程打成jar包,如demo.benchmark.jar\n  将demo.benchmark.jar 和服务的api包放到dubbo.benchmark/lib目录下\n  配置dubbo.properties\n  运行run.bat(windows)或run.sh(linux)\n  如想测试dubbo的不同版本，直接替换lib下的dubbo的jar包即可。","text":null,"weight":18},{"authors":null,"date":-62135596800,"description":"Dubbo context","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Context","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/context/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"01325ae71cb2df776b9991bdfcda6310","permalink":"/docs/v2.7/user/examples/context/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/context/","summary":"","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Networker Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/networker/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e5fa8be661b897af57c4049fe2825f6f","permalink":"/docs/v2.7/dev/impls/networker/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/networker/","summary":"","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"Develop RESTful application in Dubbo","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"REST support","lvl1":"docs","lvl2":"/docs/v2.7/user/rest/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"9c68f32f54f9fbfefc1d3d1dac25772f","permalink":"/docs/v2.7/user/rest/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/rest/","summary":"","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中开发 REST 风格的远程调用","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":1600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"开发 REST 应用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/rest/","lvl3":1532,"lvl4":"docs","lvl5":null,"objectID":"9c68f32f54f9fbfefc1d3d1dac25772f","permalink":"/zh/docs/v2.7/user/rest/","publishdate":"0001-01-01T00:00:00Z","readingtime":8,"relpermalink":"/zh/docs/v2.7/user/rest/","summary":"作者：沈理\n文档版权：Apache 2.0许可证 署名-禁止演绎\n本文篇幅较长，因为REST本身涉及面较多。另外，本文参照 Spring 等的文档风格，不仅仅局限于框架用法的阐述，同时也努力呈现框架的设计理念和优良应用的架构思想。 对于想粗略了解 dubbo 和 REST 的人，只需浏览 概述 至 标准Java REST API：JAX-RS简介 几节即可。\n 目录  概述 REST的优点 应用场景 快速入门 标准Java REST API：JAX-RS简介 REST服务提供端详解  HTTP POST/GET的实现 Annotation放在接口类还是实现类 JSON、XML等多数据格式的支持 中文字符支持 XML数据格式的额外要求 定制序列化 配置REST Server的实现 获取上下文（Context）信息 配置端口号和Context Path 配置线程数和IO线程数 配置长连接 配置最大的HTTP连接数 配置每个消费端的超时时间和HTTP连接数 GZIP数据压缩 用Annotation取代部分Spring XML配置 添加自定义的Filter、Interceptor等 添加自定义的Exception处理 配置HTTP日志输出 输入参数的校验 是否应该透明发布REST服务   REST服务消费端详解  场景1：非dubbo的消费端调用dubbo的REST服务 场景2：dubbo消费端调用dubbo的REST服务 场景3：dubbo的消费端调用非dubbo的REST服务   Dubbo中JAX-RS的限制 REST常见问题解答（REST FAQ）  Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？ Dubbo REST中如何实现负载均衡和容错（failover）？ JAX-RS中重载的方法能够映射到同一URL地址吗？ JAX-RS中作POST的方法能够接收多个参数吗？   Dubbo当前体系可能的不足之处（与REST相关的）  RpcContext的侵入性 Protocol配置的局限性 XML命名不符合spring规范   REST最佳实践 性能基准测试  测试环境 测试脚本 测试结果   扩展讨论  REST与Thrift、Protobuf等的对比 REST与传统WebServices的对比 JAX-RS与Spring MVC的对比   未来  概述 dubbo支持多种远程调用方式，例如dubbo RPC（二进制序列化 + tcp协议）、http invoker（二进制序列化 + http协议，至少在开源版本没发现对文本序列化的支持）、hessian（二进制序列化 + http协议）、WebServices （文本序列化 + http协议）等等，但缺乏对当今特别流行的REST风格远程调用（文本序列化 + http协议）的支持。","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"通过上下文存放当前调用过程中所需的环境信息","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"上下文信息","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/context/","lvl3":104,"lvl4":"docs","lvl5":null,"objectID":"01325ae71cb2df776b9991bdfcda6310","permalink":"/zh/docs/v2.7/user/examples/context/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/context/","summary":"上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。\nRpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。\n服务消费方 // 远程调用 xxxService.xxx(); // 本端是否为消费端，这里会返回true boolean isConsumerSide = RpcContext.getContext().isConsumerSide(); // 获取最后一次调用的提供方IP地址 String serverIP = RpcContext.getContext().getRemoteHost(); // 获取当前服务配置信息，所有配置信息都将转换为URL的参数 String application = RpcContext.getContext().getUrl().getParameter(\u0026#34;application\u0026#34;); // 注意：每发起RPC调用，上下文状态会变化 yyyService.yyy(); 服务提供方 public class XxxServiceImpl implements XxxService { public void xxx() { // 本端是否为提供端，这里会返回true  boolean isProviderSide = RpcContext.","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"组网扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/networker/","lvl3":54,"lvl4":"docs","lvl5":null,"objectID":"e5fa8be661b897af57c4049fe2825f6f","permalink":"/zh/docs/v2.7/dev/impls/networker/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/networker/","summary":"扩展说明 对等网络节点组网器。\n扩展接口 org.apache.dubbo.remoting.p2p.Networker\n扩展配置 \u0026lt;dubbo:protocol networker=\u0026#34;xxx\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置networker属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider networker=\u0026#34;xxx\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.remoting.p2p.support.MulticastNetworker org.apache.dubbo.remoting.p2p.support.FileNetworker  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxNetworker.java (实现Networker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.p2p.Networker (纯文本文件，内容为：xxx=com.xxx.XxxNetworker) XxxNetworker.java：\npackage com.xxx; import org.apache.dubbo.remoting.p2p.Networker; public class XxxNetworker implements Networker { public Group lookup(URL url) { // ...  } } META-INF/dubbo/org.apache.dubbo.remoting.p2p.Networker：\nxxx=com.xxx.XxxNetworker ","text":null,"weight":19},{"authors":null,"date":-62135596800,"description":"","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Articles About Apache Dubbo","lvl1":"blog","lvl2":"/blog/news/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"995c359e0eda056a2e3b98e604c59580","permalink":"/blog/news/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/blog/news/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Pass implicit parameters between consumer and provider","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Implicit parameters","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/attachment/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ad43bf068939b19566c1e5232050eaa7","permalink":"/docs/v2.7/user/examples/attachment/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/attachment/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"community/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Community","lvl1":"community","lvl2":"/community/","lvl3":0,"lvl4":"community","lvl5":null,"objectID":"460964d71a5606848132aa51ae04f454","permalink":"/community/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/community/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Developer guide","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Developer Guide","lvl1":"docs","lvl2":"/docs/v2.7/dev/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7a7f37b3103a4fedc271d814bf98e742","permalink":"/docs/v2.7/dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"docs/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Documentation","lvl1":"docs","lvl2":"/docs/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"/docs/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 2.7 documentation","dir":"docs/v2.7/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo 2.7","lvl1":"docs","lvl2":"/docs/v2.7/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"df7e3029a6c8f7390b9cb9deab5e01f6","permalink":"/docs/v2.7/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 2.7 文档","dir":"docs/v2.7/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 2.7","lvl1":"docs","lvl2":"/zh/docs/v2.7/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"df7e3029a6c8f7390b9cb9deab5e01f6","permalink":"/zh/docs/v2.7/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 3.0 documentation","dir":"docs/v3.0/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Dubbo 3.0","lvl1":"docs","lvl2":"/docs/v3.0/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"572ebf48d0d563c29aae095b63b758a2","permalink":"/docs/v3.0/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v3.0/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 3.0 文档","dir":"docs/v3.0/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 3.0","lvl1":"docs","lvl2":"/zh/docs/v3.0/","lvl3":1,"lvl4":"docs","lvl5":null,"objectID":"572ebf48d0d563c29aae095b63b758a2","permalink":"/zh/docs/v3.0/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v3.0/","summary":" 建设中\n ","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"blog/releases/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"New Releases","lvl1":"blog","lvl2":"/blog/releases/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"fbc771f2981eed29c0bc016b2d68a41a","permalink":"/blog/releases/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/blog/releases/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo simple monitor service","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Simple Monitor","lvl1":"docs","lvl2":"/docs/v2.7/user/simple-monitor/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"66d0d4fdcf113d0ad58859b3335adf58","permalink":"/docs/v2.7/user/simple-monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/simple-monitor/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Telnet 命令扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/telnet-handler/","lvl3":79,"lvl4":"docs","lvl5":null,"objectID":"f9cb71bd890fcefcfeeb0a5449c43d93","permalink":"/zh/docs/v2.7/dev/impls/telnet-handler/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/telnet-handler/","summary":"扩展说明 所有服务器均支持 telnet 访问，用于人工干预。\n扩展接口 org.apache.dubbo.remoting.telnet.TelnetHandler\n扩展配置 \u0026lt;dubbo:protocol telnet=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置telnet属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider telnet=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.remoting.telnet.support.ClearTelnetHandler org.apache.dubbo.remoting.telnet.support.ExitTelnetHandler org.apache.dubbo.remoting.telnet.support.HelpTelnetHandler org.apache.dubbo.remoting.telnet.support.StatusTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ListTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.ChangeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CurrentTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.InvokeTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.TraceTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.CountTelnetHandler org.apache.dubbo.rpc.dubbo.telnet.PortTelnetHandler  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxTelnetHandler.java (实现TelnetHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.remoting.telnet.TelnetHandler (纯文本文件，内容为：xxx=com.xxx.XxxTelnetHandler) XxxTelnetHandler.java：\npackage com.xxx; import org.apache.dubbo.remoting.telnet.TelnetHandler; @Help(parameter=\u0026#34;...\u0026#34;, summary=\u0026#34;...\u0026#34;, detail=\u0026#34;...\u0026#34;) public class XxxTelnetHandler implements TelnetHandler { public String telnet(Channel channel, String message) throws RemotingException { // ...  } } META-INF/dubbo/org.","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"TelnetHandler Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/telnet-handler/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f9cb71bd890fcefcfeeb0a5449c43d93","permalink":"/docs/v2.7/dev/impls/telnet-handler/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/telnet-handler/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 开发者的指南","dir":"docs/v2.7/dev/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 开发指南","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/","lvl3":7,"lvl4":"docs","lvl5":null,"objectID":"7a7f37b3103a4fedc271d814bf98e742","permalink":"/zh/docs/v2.7/dev/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/","summary":"这篇文档的目标读者是对 dubbo 源码、设计有兴趣的，或者有意愿加入 dubbo 开发的人群。主要涵盖了 dubbo 的框架设计、扩展机制、编码规范、版本管理、构建等话题。","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"技术分享","lvl1":"blog","lvl2":"/zh/blog/news/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"995c359e0eda056a2e3b98e604c59580","permalink":"/zh/blog/news/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/blog/news/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"docs/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"文档","lvl1":"docs","lvl2":"/zh/docs/","lvl3":3,"lvl4":"docs","lvl5":null,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"/zh/docs/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/","summary":"欢迎阅读 Nacos 文档","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"blog/releases/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"版本发布","lvl1":"blog","lvl2":"/zh/blog/releases/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"fbc771f2981eed29c0bc016b2d68a41a","permalink":"/zh/blog/releases/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/blog/releases/","summary":"","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"","dir":"community/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"社区","lvl1":"community","lvl2":"/zh/community/","lvl3":3,"lvl4":"community","lvl5":null,"objectID":"460964d71a5606848132aa51ae04f454","permalink":"/zh/community/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/community/","summary":"欢迎阅读 Nacos 社区","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Dubbo 中的简单监控服务","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"简单监控","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/simple-monitor/","lvl3":99,"lvl4":"docs","lvl5":null,"objectID":"66d0d4fdcf113d0ad58859b3335adf58","permalink":"/zh/docs/v2.7/user/simple-monitor/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/simple-monitor/","summary":"Warning 监控中心也是一个标准的 Dubbo 服务，可以通过注册中心发现，也可以直连。    暴露一个简单监控中心服务到注册中心: (如果是用安装包，不需要自己写这个配置，如果是自己实现监控中心，则需要)\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;!-- 当前应用信息配置 --\u0026gt; \u0026lt;dubbo:application name=\u0026#34;simple-monitor\u0026#34; /\u0026gt; \u0026lt;!-- 连接注册中心配置 --\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;127.0.0.1:9090\u0026#34; /\u0026gt; \u0026lt;!-- 暴露服务协议配置 --\u0026gt; \u0026lt;dubbo:protocol port=\u0026#34;7070\u0026#34; /\u0026gt; \u0026lt;!-- 暴露服务配置 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.monitor.MonitorService\u0026#34; ref=\u0026#34;monitorService\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;monitorService\u0026#34; class=\u0026#34;org.apache.dubbo.monitor.simple.SimpleMonitorService\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt;   通过注册中心发现监控中心服务:\n\u0026lt;dubbo:monitor protocol=\u0026#34;registry\u0026#34; /\u0026gt; 或者在 dubbo.properties 配置：\ndubbo.monitor.protocol=registry   暴露一个简单监控中心服务，但不注册到注册中心: (如果是用安装包，不需要自己写这个配置，如果是自己实现监控中心，则需要)\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;!","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"通过 Dubbo 中的 Attachment 在服务消费方和提供方之间隐式传递参数","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"隐式参数","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/attachment/","lvl3":50,"lvl4":"docs","lvl5":null,"objectID":"ad43bf068939b19566c1e5232050eaa7","permalink":"/zh/docs/v2.7/user/examples/attachment/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/attachment/","summary":"可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。\n注意 path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。  在服务消费方端设置隐式参数 setAttachment 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。\nRpcContext.getContext().setAttachment(\u0026#34;index\u0026#34;, \u0026#34;1\u0026#34;); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用 xxxService.xxx(); // 远程调用 // ... 在服务提供方端获取隐式参数 public class XxxServiceImpl implements XxxService { public void xxx() { // 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用  String index = RpcContext.getContext().getAttachment(\u0026#34;index\u0026#34;); } } ","text":null,"weight":20},{"authors":null,"date":-62135596800,"description":"Asynchronous call in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Asynchronous Call","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/async-call/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"1474c3a0c9b92d9e32c22ba5d6e61d10","permalink":"/docs/v2.7/user/examples/async-call/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/async-call/","summary":"","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"Asynchronous execution on dubbo provider side","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Asynchronous Execution","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/async-execute-on-provider/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"ca90a81e34342dbf24931bdad217d775","permalink":"/docs/v2.7/user/examples/async-execute-on-provider/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/async-execute-on-provider/","summary":"","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"StatusChecker Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/status-checker/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"7d624b14ba1a67354e4e7921db2bba9e","permalink":"/docs/v2.7/dev/impls/status-checker/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/status-checker/","summary":"","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"Dubbo 服务提供方的异步执行","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"异步执行","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/async-execute-on-provider/","lvl3":156,"lvl4":"docs","lvl5":null,"objectID":"ca90a81e34342dbf24931bdad217d775","permalink":"/zh/docs/v2.7/user/examples/async-execute-on-provider/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/async-execute-on-provider/","summary":"Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无益于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行。\n注意 Provider 端异步执行和 Consumer 端异步调用是相互独立的，你可以任意正交组合两端配置\n Consumer同步 - Provider同步 Consumer异步 - Provider同步 Consumer同步 - Provider异步 Consumer异步 - Provider异步   定义 CompletableFuture 签名的接口 服务接口定义：\npublic interface AsyncService { CompletableFuture\u0026lt;String\u0026gt; sayHello(String name); } 服务实现：\npublic class AsyncServiceImpl implements AsyncService { @Override public CompletableFuture\u0026lt;String\u0026gt; sayHello(String name) { RpcContext savedContext = RpcContext.getContext(); // 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池  return CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(savedContext.getAttachment(\u0026#34;consumer-key1\u0026#34;)); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;async response from provider.","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中发起异步调用","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"异步调用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/async-call/","lvl3":209,"lvl4":"docs","lvl5":null,"objectID":"1474c3a0c9b92d9e32c22ba5d6e61d10","permalink":"/zh/docs/v2.7/user/examples/async-call/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/async-call/","summary":"从 2.7.0 开始，Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础\n基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。\n使用 CompletableFuture 签名的接口 需要服务提供者事先定义 CompletableFuture 签名的服务，具体参见服务端异步执行接口定义：\npublic interface AsyncService { CompletableFuture\u0026lt;String\u0026gt; sayHello(String name); } 注意接口的返回类型是 CompletableFuture\u0026lt;String\u0026gt;。\nXML引用服务：\n\u0026lt;dubbo:reference id=\u0026#34;asyncService\u0026#34; timeout=\u0026#34;10000\u0026#34; interface=\u0026#34;com.alibaba.dubbo.samples.async.api.AsyncService\u0026#34;/\u0026gt; 调用远程服务：\n// 调用直接返回CompletableFuture CompletableFuture\u0026lt;String\u0026gt; future = asyncService.sayHello(\u0026#34;async call request\u0026#34;); // 增加回调 future.whenComplete((v, t) -\u0026gt; { if (t != null) { t.printStackTrace(); } else { System.out.println(\u0026#34;Response: \u0026#34; + v); } }); // 早于结果输出 System.out.println(\u0026#34;Executed before response return.\u0026#34;); 使用 RpcContext 在 consumer.xml 中配置：","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"状态检查扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/status-checker/","lvl3":66,"lvl4":"docs","lvl5":null,"objectID":"7d624b14ba1a67354e4e7921db2bba9e","permalink":"/zh/docs/v2.7/dev/impls/status-checker/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/status-checker/","summary":"扩展说明 检查服务依赖各种资源的状态，此状态检查可同时用于 telnet 的 status 命令和 hosting 的 status 页面。\n扩展接口 org.apache.dubbo.common.status.StatusChecker\n扩展配置 \u0026lt;dubbo:protocol status=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置status属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider status=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.common.status.support.MemoryStatusChecker org.apache.dubbo.common.status.support.LoadStatusChecker org.apache.dubbo.rpc.dubbo.status.ServerStatusChecker org.apache.dubbo.rpc.dubbo.status.ThreadPoolStatusChecker org.apache.dubbo.registry.directory.RegistryStatusChecker org.apache.dubbo.rpc.config.spring.status.SpringStatusChecker org.apache.dubbo.rpc.config.spring.status.DataSourceStatusChecker  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxStatusChecker.java (实现StatusChecker接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.status.StatusChecker (纯文本文件，内容为：xxx=com.xxx.XxxStatusChecker) XxxStatusChecker.java：\npackage com.xxx; import org.apache.dubbo.common.status.StatusChecker; public class XxxStatusChecker implements StatusChecker { public Status check() { // ...  } } META-INF/dubbo/org.apache.dubbo.common.status.StatusChecker：\nxxx=com.xxx.XxxStatusChecker ","text":null,"weight":21},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Container Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/container/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"b1a7a2fd5fc995198d463c4f15fd842e","permalink":"/docs/v2.7/dev/impls/container/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/container/","summary":"","text":null,"weight":22},{"authors":null,"date":-62135596800,"description":"Local call in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Local Call","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/local-call/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"821f8a633c26133abdd7cc0c18b920b9","permalink":"/docs/v2.7/user/examples/local-call/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/local-call/","summary":"","text":null,"weight":22},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"容器扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/container/","lvl3":56,"lvl4":"docs","lvl5":null,"objectID":"b1a7a2fd5fc995198d463c4f15fd842e","permalink":"/zh/docs/v2.7/dev/impls/container/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/container/","summary":"扩展说明 服务容器扩展，用于自定义加载内容。\n扩展接口 org.apache.dubbo.container.Container\n扩展配置 java org.apache.dubbo.container.Main spring jetty log4j 已知扩展  org.apache.dubbo.container.spring.SpringContainer org.apache.dubbo.container.spring.JettyContainer org.apache.dubbo.container.spring.Log4jContainer  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxContainer.java (实现Container接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.Container (纯文本文件，内容为：xxx=com.xxx.XxxContainer) XxxContainer.java：\npackage com.xxx; org.apache.dubbo.container.Container; public class XxxContainer implements Container { public Status start() { // ...  } public Status stop() { // ...  } } META-INF/dubbo/org.apache.dubbo.container.Container：\nxxx=com.xxx.XxxContainer ","text":null,"weight":22},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中进行本地调用","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"本地调用","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/local-call/","lvl3":58,"lvl4":"docs","lvl5":null,"objectID":"821f8a633c26133abdd7cc0c18b920b9","permalink":"/zh/docs/v2.7/user/examples/local-call/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/local-call/","summary":"本地调用使用了 injvm 协议，是一个伪协议，它不开启端口，不发起远程调用，只在 JVM 内直接关联，但执行 Dubbo 的 Filter 链。\n配置 定义 injvm 协议\n\u0026lt;dubbo:protocol name=\u0026#34;injvm\u0026#34; /\u0026gt; 设置默认协议\n\u0026lt;dubbo:provider protocol=\u0026#34;injvm\u0026#34; /\u0026gt; 设置服务协议\n\u0026lt;dubbo:service protocol=\u0026#34;injvm\u0026#34; /\u0026gt; 优先使用 injvm\n\u0026lt;dubbo:consumer injvm=\u0026#34;true\u0026#34; .../\u0026gt; \u0026lt;dubbo:provider injvm=\u0026#34;true\u0026#34; .../\u0026gt; 或\n\u0026lt;dubbo:reference injvm=\u0026#34;true\u0026#34; .../\u0026gt; \u0026lt;dubbo:service injvm=\u0026#34;true\u0026#34; .../\u0026gt;  注意 Dubbo 从 2.2.0 每个服务默认都会在本地暴露，无需进行任何配置即可进行本地引用，如果不希望服务进行远程暴露，只需要在 provider 将 protocol 设置成 injvm 即可  自动暴露、引用本地服务 从 2.2.0 开始，每个服务默认都会在本地暴露。在引用服务的时候，默认优先引用本地服务。如果希望引用远程服务可以使用一下配置强制引用远程服务。\n\u0026lt;dubbo:reference ... scope=\u0026#34;remote\u0026#34; /\u0026gt; ","text":null,"weight":22},{"authors":null,"date":-62135596800,"description":"Callback parameter in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Callback parameter","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/callback-parameter/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e7adc55f0b319e59cf18e75371599cab","permalink":"/docs/v2.7/user/examples/callback-parameter/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/callback-parameter/","summary":"","text":null,"weight":23},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"PageHandler Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/page/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"3f1e9b94883558dc5c5ac4c2c0337ed4","permalink":"/docs/v2.7/dev/impls/page/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/page/","summary":"","text":null,"weight":23},{"authors":null,"date":-62135596800,"description":"通过参数回调从服务器端调用客户端逻辑","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"参数回调","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/callback-parameter/","lvl3":203,"lvl4":"docs","lvl5":null,"objectID":"e7adc55f0b319e59cf18e75371599cab","permalink":"/zh/docs/v2.7/user/examples/callback-parameter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/callback-parameter/","summary":"参数回调方式与调用本地 callback 或 listener 相同，只需要在 Spring 的配置文件中声明哪个参数是 callback 类型即可。Dubbo 将基于长连接生成反向代理，这样就可以从服务器端调用客户端逻辑。可以参考 dubbo 项目中的示例代码。\n服务接口示例 CallbackService.java package com.callback; public interface CallbackService { void addListener(String key, CallbackListener listener); } CallbackListener.java package com.callback; public interface CallbackListener { void changed(String msg); } 服务提供者接口实现示例 package com.callback.impl; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import com.callback.CallbackListener; import com.callback.CallbackService; public class CallbackServiceImpl implements CallbackService { private final Map\u0026lt;String, CallbackListener\u0026gt; listeners = new ConcurrentHashMap\u0026lt;String, CallbackListener\u0026gt;(); public CallbackServiceImpl() { Thread t = new Thread(new Runnable() { public void run() { while(true) { try { for(Map.","text":null,"weight":23},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Cache Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/cache/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"02af97c18563511ddb4f721b32b1e3b4","permalink":"/docs/v2.7/dev/impls/cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/cache/","summary":"","text":null,"weight":24},{"authors":null,"date":-62135596800,"description":"Event notification in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Event Notification","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/events-notify/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"579bc53e7cf8690c96736763af2a673b","permalink":"/docs/v2.7/user/examples/events-notify/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/events-notify/","summary":"","text":null,"weight":24},{"authors":null,"date":-62135596800,"description":"在调用之前、调用之后、出现异常时的时间通知","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"事件通知","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/events-notify/","lvl3":203,"lvl4":"docs","lvl5":null,"objectID":"579bc53e7cf8690c96736763af2a673b","permalink":"/zh/docs/v2.7/user/examples/events-notify/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/events-notify/","summary":"在调用之前、调用之后、出现异常时，会触发 oninvoke、onreturn、onthrow 三个事件，可以配置当事件发生时，通知哪个类的哪个方法。\n提示 支持版本：2.0.7 之后  服务提供者与消费者共享服务接口 interface IDemoService { public Person get(int id); } 服务提供者实现 class NormalDemoService implements IDemoService { public Person get(int id) { return new Person(id, \u0026#34;charles`son\u0026#34;, 4); } } 服务提供者配置 \u0026lt;dubbo:application name=\u0026#34;rpc-callback-demo\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;demoService\u0026#34; class=\u0026#34;org.apache.dubbo.callback.implicit.NormalDemoService\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.callback.implicit.IDemoService\u0026#34; ref=\u0026#34;demoService\u0026#34; version=\u0026#34;1.0.0\u0026#34; group=\u0026#34;cn\u0026#34;/\u0026gt; 服务消费者 Callback 接口 interface Notify { public void onreturn(Person msg, Integer id); public void onthrow(Throwable ex, Integer id); } 服务消费者 Callback 实现 class NotifyImpl implements Notify { public Map\u0026lt;Integer, Person\u0026gt; ret = new HashMap\u0026lt;Integer, Person\u0026gt;(); public Map\u0026lt;Integer, Throwable\u0026gt; errors = new HashMap\u0026lt;Integer, Throwable\u0026gt;(); public void onreturn(Person msg, Integer id) { System.","text":null,"weight":24},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"缓存扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/cache/","lvl3":105,"lvl4":"docs","lvl5":null,"objectID":"02af97c18563511ddb4f721b32b1e3b4","permalink":"/zh/docs/v2.7/dev/impls/cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/cache/","summary":"扩展说明 用请求参数作为 key，缓存返回结果。\n扩展接口 org.apache.dubbo.cache.CacheFactory\n扩展配置 \u0026lt;dubbo:service cache=\u0026#34;lru\u0026#34; /\u0026gt; \u0026lt;!-- 方法级缓存 --\u0026gt; \u0026lt;dubbo:service\u0026gt;\u0026lt;dubbo:method cache=\u0026#34;lru\u0026#34; /\u0026gt;\u0026lt;/dubbo:service\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:service\u0026gt;没有配置cache属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider cache=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.cache.support.lru.LruCacheFactory org.apache.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory org.apache.dubbo.cache.support.jcache.JCacheFactory  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxCacheFactory.java (实现CacheFactory接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.cache.CacheFactory (纯文本文件，内容为：xxx=com.xxx.XxxCacheFactory) XxxCacheFactory.java：\npackage com.xxx; import org.apache.dubbo.cache.CacheFactory; public class XxxCacheFactory implements CacheFactory { public Cache getCache(URL url, String name) { return new XxxCache(url, name); } } XxxCache.java：\npackage com.xxx; import org.","text":null,"weight":24},{"authors":null,"date":-62135596800,"description":"Local stub in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Local Stub","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/local-stub/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4e42fa55b07952f51684782b18f9a95a","permalink":"/docs/v2.7/user/examples/local-stub/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/local-stub/","summary":"","text":null,"weight":25},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Validation Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/validation/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"340a4f048f545ab371ee06f8c102ad11","permalink":"/docs/v2.7/dev/impls/validation/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/validation/","summary":"","text":null,"weight":25},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中利用本地存根在客户端执行部分逻辑","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"本地存根","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/local-stub/","lvl3":92,"lvl4":"docs","lvl5":null,"objectID":"4e42fa55b07952f51684782b18f9a95a","permalink":"/zh/docs/v2.7/user/examples/local-stub/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/local-stub/","summary":"远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub 1，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。\n在 spring 配置文件中按以下方式配置：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; stub=\u0026#34;true\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; stub=\u0026#34;com.foo.BarServiceStub\u0026#34; /\u0026gt; 提供 Stub 的实现 2：\npackage com.foo; public class BarServiceStub implements BarService { private final BarService barService; // 构造函数传入真正的远程代理对象  public BarServiceStub(BarService barService){ this.barService = barService; } public String sayHello(String name) { // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等  try { return barService.sayHello(name); } catch (Exception e) { // 你可以容错，可以做任何AOP拦截事项  return \u0026#34;容错数据\u0026#34;; } } }   Stub 必须有可传入 Proxy 的构造函数。 \u0026#x21a9;\u0026#xfe0e;","text":null,"weight":25},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"验证扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/validation/","lvl3":82,"lvl4":"docs","lvl5":null,"objectID":"340a4f048f545ab371ee06f8c102ad11","permalink":"/zh/docs/v2.7/dev/impls/validation/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/validation/","summary":"扩展说明 参数验证扩展点。\n扩展接口 org.apache.dubbo.validation.Validation\n扩展配置 \u0026lt;dubbo:service validation=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:service\u0026gt;没有配置validation属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider validation=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展 org.apache.dubbo.validation.support.jvalidation.JValidation\n扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxValidation.java (实现Validation接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.validation.Validation (纯文本文件，内容为：xxx=com.xxx.XxxValidation) XxxValidation.java：\npackage com.xxx; import org.apache.dubbo.validation.Validation; public class XxxValidation implements Validation { public Object getValidator(URL url) { // ...  } } XxxValidator.java：\npackage com.xxx; import org.apache.dubbo.validation.Validator; public class XxxValidator implements Validator { public XxxValidator(URL url) { // ...  } public void validate(Invocation invocation) throws Exception { // .","text":null,"weight":25},{"authors":null,"date":-62135596800,"description":"Local mock in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Local Mock","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/local-mock/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f01cec1c24e8e5459632d6af1a5a61bb","permalink":"/docs/v2.7/user/examples/local-mock/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/local-mock/","summary":"","text":null,"weight":26},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"LoggerAdapter Extension","lvl1":"docs","lvl2":"/docs/v2.7/dev/impls/logger-adapter/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"fcc31c6550d1e577803488f9a1b68e80","permalink":"/docs/v2.7/dev/impls/logger-adapter/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/dev/impls/logger-adapter/","summary":"","text":null,"weight":26},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"日志适配扩展","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/logger-adapter/","lvl3":82,"lvl4":"docs","lvl5":null,"objectID":"fcc31c6550d1e577803488f9a1b68e80","permalink":"/zh/docs/v2.7/dev/impls/logger-adapter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/logger-adapter/","summary":"扩展说明 日志输出适配扩展点。\n扩展接口 org.apache.dubbo.common.logger.LoggerAdapter\n扩展配置 \u0026lt;dubbo:application logger=\u0026#34;xxx\u0026#34; /\u0026gt; 或者：\n-Ddubbo:application.logger=xxx 已知扩展  org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter org.apache.dubbo.common.logger.jcl.JclLoggerAdapter org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxLoggerAdapter.java (实现LoggerAdapter接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.common.logger.LoggerAdapter (纯文本文件，内容为：xxx=com.xxx.XxxLoggerAdapter) XxxLoggerAdapter.java：\npackage com.xxx; import org.apache.dubbo.common.logger.LoggerAdapter; public class XxxLoggerAdapter implements LoggerAdapter { public Logger getLogger(URL url) { // ...  } } XxxLogger.java：\npackage com.xxx; import org.apache.dubbo.common.logger.Logger; public class XxxLogger implements Logger { public XxxLogger(URL url) { // .","text":null,"weight":26},{"authors":null,"date":-62135596800,"description":"如何在 Dubbo 中利用本地伪装实现服务降级","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"本地伪装","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/local-mock/","lvl3":196,"lvl4":"docs","lvl5":null,"objectID":"f01cec1c24e8e5459632d6af1a5a61bb","permalink":"/zh/docs/v2.7/user/examples/local-mock/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/local-mock/","summary":"本地伪装 1 通常用于服务降级，比如某验权服务，当服务提供方全部挂掉后，客户端不抛出异常，而是通过 Mock 数据返回授权失败。\n在 spring 配置文件中按以下方式配置：\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; mock=\u0026#34;true\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; mock=\u0026#34;com.foo.BarServiceMock\u0026#34; /\u0026gt; 在工程中提供 Mock 实现 2：\npackage com.foo; public class BarServiceMock implements BarService { public String sayHello(String name) { // 你可以伪造容错数据，此方法只在出现RpcException时被执行  return \u0026#34;容错数据\u0026#34;; } } 如果服务的消费方经常需要 try-catch 捕获异常，如：\nOffer offer = null; try { offer = offerService.findOffer(offerId); } catch (RpcException e) { logger.error(e); } 请考虑改为 Mock 实现，并在 Mock 实现中 return null。如果只是想简单的忽略异常，在 2.0.11 以上版本可用：\n\u0026lt;dubbo:reference interface=\u0026#34;com.","text":null,"weight":26},{"authors":null,"date":-62135596800,"description":"Delay publish dubbo service","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Delay Publish","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/delay-publish/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f2948309de059f0cdc8864e27ef45f5b","permalink":"/docs/v2.7/user/examples/delay-publish/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/delay-publish/","summary":"","text":null,"weight":27},{"authors":null,"date":-62135596800,"description":"延迟暴露 Dubbo 服务","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"延迟暴露","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/delay-publish/","lvl3":125,"lvl4":"docs","lvl5":null,"objectID":"f2948309de059f0cdc8864e27ef45f5b","permalink":"/zh/docs/v2.7/user/examples/delay-publish/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/delay-publish/","summary":"如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay \u0026gt; 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，并不会感知到此变化，因此请放心使用。\nDubbo 2.6.5 之前版本 延迟到 Spring 初始化完成后，再暴露服务1\n\u0026lt;dubbo:service delay=\u0026#34;-1\u0026#34; /\u0026gt; 延迟 5 秒暴露服务\n\u0026lt;dubbo:service delay=\u0026#34;5000\u0026#34; /\u0026gt; Dubbo 2.6.5 及以后版本 所有服务都将在 Spring 初始化完成后进行暴露，如果你不需要延迟暴露服务，无需配置 delay。\n延迟 5 秒暴露服务\n\u0026lt;dubbo:service delay=\u0026#34;5000\u0026#34; /\u0026gt; Spring 2.x 初始化死锁问题 触发条件 在 Spring 解析到 \u0026lt;dubbo:service /\u0026gt; 时，就已经向外暴露了服务，而 Spring 还在接着初始化其它 Bean。如果这时有请求进来，并且服务的实现类里有调用 applicationContext.getBean() 的用法。\n  请求线程的 applicationContext.getBean() 调用，先同步 singletonObjects 判断 Bean 是否存在，不存在就同步 beanDefinitionMap 进行初始化，并再次同步 singletonObjects 写入 Bean 实例缓存。","text":null,"weight":27},{"authors":null,"date":-62135596800,"description":"Concurrency control in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Concurrency Control","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/concurrency-control/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d4818dd63aa7d887172ce064a0903a0a","permalink":"/docs/v2.7/user/examples/concurrency-control/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/concurrency-control/","summary":"","text":null,"weight":28},{"authors":null,"date":-62135596800,"description":"Dubbo 中的并发控制","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"并发控制","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/concurrency-control/","lvl3":93,"lvl4":"docs","lvl5":null,"objectID":"d4818dd63aa7d887172ce064a0903a0a","permalink":"/zh/docs/v2.7/user/examples/concurrency-control/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/concurrency-control/","summary":"配置样例 样例 1 限制 com.foo.BarService 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; executes=\u0026#34;10\u0026#34; /\u0026gt; 样例 2 限制 com.foo.BarService 的 sayHello 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; executes=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/dubbo:service\u0026gt; 样例 3 限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; actives=\u0026#34;10\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; actives=\u0026#34;10\u0026#34; /\u0026gt; 样例 4 限制 com.foo.BarService 的 sayHello 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; actives=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/dubbo:service\u0026gt; 或\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; actives=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/dubbo:service\u0026gt; 如果 \u0026lt;dubbo:service\u0026gt; 和 \u0026lt;dubbo:reference\u0026gt; 都配了actives，\u0026lt;dubbo:reference\u0026gt; 优先，参见：配置的覆盖策略。","text":null,"weight":28},{"authors":null,"date":-62135596800,"description":"Config connections in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Config connections","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/config-connections/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4deeff98f39663388b7b7d0838e282fe","permalink":"/docs/v2.7/user/examples/config-connections/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/config-connections/","summary":"","text":null,"weight":29},{"authors":null,"date":-62135596800,"description":"Dubbo 中服务端和客户端的连接控制","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"连接控制","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/config-connections/","lvl3":45,"lvl4":"docs","lvl5":null,"objectID":"4deeff98f39663388b7b7d0838e282fe","permalink":"/zh/docs/v2.7/user/examples/config-connections/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/config-connections/","summary":"服务端连接控制 限制服务器端接受的连接不能超过 10 个 1：\n\u0026lt;dubbo:provider protocol=\u0026#34;dubbo\u0026#34; accepts=\u0026#34;10\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; accepts=\u0026#34;10\u0026#34; /\u0026gt; 客户端连接控制 限制客户端服务使用连接不能超过 10 个 2：\n\u0026lt;dubbo:reference interface=\u0026#34;com.foo.BarService\u0026#34; connections=\u0026#34;10\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; connections=\u0026#34;10\u0026#34; /\u0026gt; 如果 \u0026lt;dubbo:service\u0026gt; 和 \u0026lt;dubbo:reference\u0026gt; 都配了 connections，\u0026lt;dubbo:reference\u0026gt; 优先，参见：配置的覆盖策略\n  因为连接在 Server上，所以配置在 Provider 上 \u0026#x21a9;\u0026#xfe0e;\n 如果是长连接，比如 Dubbo 协议，connections 表示该服务对每个提供者建立的长连接数 \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":29},{"authors":null,"date":-62135596800,"description":"Guide for dubbo administrator","dir":"docs/v2.7/admin/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Admin Guide","lvl1":"docs","lvl2":"/docs/v2.7/admin/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8b503759c6c08210cfc3e43e9e51f06f","permalink":"/docs/v2.7/admin/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/admin/","summary":"","text":null,"weight":30},{"authors":null,"date":-62135596800,"description":"Lazy connect in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Lazy Connect","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/lazy-connect/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"210cebd01cec360b3f027df4177623d4","permalink":"/docs/v2.7/user/examples/lazy-connect/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/lazy-connect/","summary":"","text":null,"weight":30},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中配置延迟连接","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"延迟连接","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/lazy-connect/","lvl3":9,"lvl4":"docs","lvl5":null,"objectID":"210cebd01cec360b3f027df4177623d4","permalink":"/zh/docs/v2.7/user/examples/lazy-connect/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/lazy-connect/","summary":"延迟连接用于减少长连接数。当有调用发起时，再创建长连接。\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; lazy=\u0026#34;true\u0026#34; /\u0026gt;  提示 该配置只对使用长连接的 dubbo 协议生效。  ","text":null,"weight":30},{"authors":null,"date":-62135596800,"description":"Dubbo 管理员指南","dir":"docs/v2.7/admin/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"运维管理指南","lvl1":"docs","lvl2":"/zh/docs/v2.7/admin/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8b503759c6c08210cfc3e43e9e51f06f","permalink":"/zh/docs/v2.7/admin/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/admin/","summary":"","text":null,"weight":30},{"authors":null,"date":-62135596800,"description":"Config stickiness connection in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Stickiness Connection","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/stickiness/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"d7c20a3da1fc724bd9097cafaa17eeb7","permalink":"/docs/v2.7/user/examples/stickiness/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/stickiness/","summary":"","text":null,"weight":31},{"authors":null,"date":-62135596800,"description":"为有状态服务配置粘滞连接","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"粘滞连接","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/stickiness/","lvl3":17,"lvl4":"docs","lvl5":null,"objectID":"d7c20a3da1fc724bd9097cafaa17eeb7","permalink":"/zh/docs/v2.7/user/examples/stickiness/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/stickiness/","summary":"粘滞连接用于有状态服务，尽可能让客户端总是向同一提供者发起调用，除非该提供者挂了，再连另一台。\n粘滞连接将自动开启延迟连接，以减少长连接数。\n\u0026lt;dubbo:reference id=\u0026#34;xxxService\u0026#34; interface=\u0026#34;com.xxx.XxxService\u0026#34; sticky=\u0026#34;true\u0026#34; /\u0026gt; Dubbo 支持方法级别的粘滞连接，如果你想进行更细粒度的控制，还可以这样配置。\n\u0026lt;dubbo:reference id=\u0026#34;xxxService\u0026#34; interface=\u0026#34;com.xxx.XxxService\u0026#34;\u0026gt; \u0026lt;dubbo:mothod name=\u0026#34;sayHello\u0026#34; sticky=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; ","text":null,"weight":31},{"authors":null,"date":-62135596800,"description":"通过 TLS 保证传输安全","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"TLS","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/tls/","lvl3":79,"lvl4":"docs","lvl5":null,"objectID":"880d2d25f69edb264a66fab000c2d047","permalink":"/zh/docs/v2.7/user/examples/tls/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/tls/","summary":"2.7.5 版本在传输链路的安全性上做了很多工作，对于内置的 Dubbo Netty Server 和新引入的 gRPC 协议都提供了基于 TLS 的安全链路传输机制。\nTLS 的配置都有统一的入口，如下所示：\nProvider 端 SslConfig sslConfig = new SslConfig(); sslConfig.setServerKeyCertChainPath(\u0026#34;path to cert\u0026#34;); sslConfig.setServerPrivateKeyPath(args[1]); // 如果开启双向 cert 认证 if (mutualTls) { sslConfig.setServerTrustCertCollectionPath(args[2]); } ProtocolConfig protocolConfig = new ProtocolConfig(\u0026#34;dubbo/grpc\u0026#34;); protocolConfig.setSslEnabled(true); Consumer 端 if (!mutualTls) {} sslConfig.setClientTrustCertCollectionPath(args[0]); } else { sslConfig.setClientTrustCertCollectionPath(args[0]); sslConfig.setClientKeyCertChainPath(args[1]); sslConfig.setClientPrivateKeyPath(args[2]); } 为尽可能保证应用启动的灵活性，TLS Cert 的指定还能通过 -D 参数或环境变量等方式来在启动阶段根据部署环境动态指定，具体请参见 Dubbo 配置读取规则与 TLS 示例\n提示 参考 Dubbo 配置读取规则，TLS 示例\n如果要使用的是 gRPC 协议，在开启 TLS 时会使用到协议协商机制，因此必须使用支持 ALPN 机制的 Provider，推荐使用的是 netty-tcnative，具体可参见 gRPC Java 社区的总结","text":null,"weight":32},{"authors":null,"date":-62135596800,"description":"Config token based authorization in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Token Authorization","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/token-authorization/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"e062f7988d851f16aab04c6fe6159368","permalink":"/docs/v2.7/user/examples/token-authorization/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/token-authorization/","summary":"","text":null,"weight":32},{"authors":null,"date":-62135596800,"description":"通过令牌验证在注册中心控制权限","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"令牌验证","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/token-authorization/","lvl3":25,"lvl4":"docs","lvl5":null,"objectID":"e062f7988d851f16aab04c6fe6159368","permalink":"/zh/docs/v2.7/user/examples/token-authorization/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/token-authorization/","summary":"通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者\n可以全局设置开启令牌验证：\n\u0026lt;!--随机token令牌，使用UUID生成--\u0026gt; \u0026lt;dubbo:provider interface=\u0026#34;com.foo.BarService\u0026#34; token=\u0026#34;true\u0026#34; /\u0026gt; 或\n\u0026lt;!--固定token令牌，相当于密码--\u0026gt; \u0026lt;dubbo:provider interface=\u0026#34;com.foo.BarService\u0026#34; token=\u0026#34;123456\u0026#34; /\u0026gt; 也可在服务级别设置：\n\u0026lt;!--随机token令牌，使用UUID生成--\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; token=\u0026#34;true\u0026#34; /\u0026gt; 或\n\u0026lt;!--固定token令牌，相当于密码--\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.foo.BarService\u0026#34; token=\u0026#34;123456\u0026#34; /\u0026gt; ","text":null,"weight":32},{"authors":null,"date":-62135596800,"description":"Config routing rule in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Routing Rule","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/routing-rule/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"92aa8554e8e26816da654a754f5e6c4b","permalink":"/docs/v2.7/user/examples/routing-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/routing-rule/","summary":"","text":null,"weight":33},{"authors":null,"date":-62135596800,"description":"通过 Dubbo 中的路由规则做服务治理","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"路由规则","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/routing-rule/","lvl3":338,"lvl4":"docs","lvl5":null,"objectID":"92aa8554e8e26816da654a754f5e6c4b","permalink":"/zh/docs/v2.7/user/examples/routing-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/examples/routing-rule/","summary":"路由规则在发起一次RPC调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起RPC调用的备选地址。\n 条件路由。支持以服务或 Consumer 应用为粒度配置路由规则。 标签路由。以 Provider 应用为粒度配置路由规则。  后续我们计划在 2.6.x 版本的基础上继续增强脚本路由功能。\n条件路由 您可以随时在服务治理控制台 Dubbo-Admin 写入路由规则\n简介   应用粒度\n# app1的消费者只能消费所有端口为20880的服务实例 # app2的消费者只能消费所有端口为20881的服务实例 --- scope: application force: true runtime: true enabled: true key: governance-conditionrouter-consumer conditions: - application=app1 =\u0026gt; address=*:20880 - application=app2 =\u0026gt; address=*:20881 ...   服务粒度\n# DemoService的sayHello方法只能消费所有端口为20880的服务实例 # DemoService的sayHi方法只能消费所有端口为20881的服务实例 --- scope: service force: true runtime: true enabled: true key: org.apache.dubbo.samples.governance.api.DemoService conditions: - method=sayHello =\u0026gt; address=*:20880 - method=sayHi =\u0026gt; address=*:20881 .","text":null,"weight":33},{"authors":null,"date":-62135596800,"description":"Configure rule in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Configure rule","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/config-rule/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"972a0557e180ec2803a87e1c8a01e924","permalink":"/docs/v2.7/user/examples/config-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/config-rule/","summary":"","text":null,"weight":34},{"authors":null,"date":-62135596800,"description":"在 Dubbo `2.6.x` 版本以及更早的版本中配置路由规则","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"旧路由规则","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/routing-rule-deprecated/","lvl3":368,"lvl4":"docs","lvl5":null,"objectID":"e6da83e17c5aff26ac32a259260c46fe","permalink":"/zh/docs/v2.7/user/examples/routing-rule-deprecated/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/examples/routing-rule-deprecated/","summary":"路由规则 1 决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展 2。\n写入路由规则 向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;route://0.0.0.0/com.foo.BarService?category=routers\u0026amp;dynamic=false\u0026amp;rule=\u0026#34; + URL.encode(\u0026#34;host = 10.20.153.10 =\u0026gt; host = 10.20.153.11\u0026#34;))); 其中：\n route:// 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 group=foo 对指定服务的指定group生效，不填表示对未配置group的指定服务生效 version=1.0对指定服务的指定version生效，不填表示对未配置version的指定服务生效 category=routers 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 force=false 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。 runtime=false 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。 priority=1 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。 rule=URL.encode(\u0026quot;host = 10.20.153.10 =\u0026gt; host = 10.20.153.11\u0026quot;) 表示路由规则的内容，必填。  条件路由规则 基于条件表达式的路由规则，如：host = 10.20.153.10 =\u0026gt; host = 10.","text":null,"weight":34},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中配置应用级治理规则和服务级治理规则","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"配置规则","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/config-rule/","lvl3":227,"lvl4":"docs","lvl5":null,"objectID":"972a0557e180ec2803a87e1c8a01e924","permalink":"/zh/docs/v2.7/user/examples/config-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/examples/config-rule/","summary":"提示 本文描述的是新版本规则配置，而不是老版本配置规则  覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。2.7.0 版本开始，支持从服务和应用两个粒度来调整动态配置。\n概览 请在服务治理控制台查看或修改覆盖规则。\n应用粒度\n# 将应用demo（key:demo）在20880端口上提供（side:provider）的所有服务（scope:application）的权重修改为1000（weight:1000）。 --- configVersion: v2.7 scope: application key: demo enabled: true configs: - addresses: [\u0026#34;0.0.0.0:20880\u0026#34;] side: provider parameters: weight: 1000 ... 服务粒度\n# 所有消费（side:consumer）DemoService服务（key:org.apache.dubbo.samples.governance.api.DemoService）的应用实例（addresses:[0.0.0.0]），超时时间修改为6000ms --- configVersion: v2.7 scope: service key: org.apache.dubbo.samples.governance.api.DemoService enabled: true configs: - addresses: [0.0.0.0] side: consumer parameters: timeout: 6000 ... 规则详解 配置模板 --- configVersion: v2.7 scope: application/service key: app-name/group+service+version enabled: true configs: - addresses: [\u0026#34;0.","text":null,"weight":34},{"authors":null,"date":-62135596800,"description":"Downgrade service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Downgrade","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/service-downgrade/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"904f08ec4cc35a4b53eb0b60bb197e77","permalink":"/docs/v2.7/user/examples/service-downgrade/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/service-downgrade/","summary":"","text":null,"weight":35},{"authors":null,"date":-62135596800,"description":"Dubbo 中旧版本的规则配置方式","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"旧配置规则","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/config-rule-deprecated/","lvl3":56,"lvl4":"docs","lvl5":null,"objectID":"ccb4a7b9066493648c030615a8f9b04c","permalink":"/zh/docs/v2.7/user/examples/config-rule-deprecated/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/config-rule-deprecated/","summary":"向注册中心写入动态配置覆盖规则。该功能通常由监控中心或治理中心的页面完成。\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;override://0.0.0.0/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;application=foo\u0026amp;timeout=1000\u0026#34;)); 其中：\n override:// 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。 0.0.0.0 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。 com.foo.BarService 表示只对指定服务生效，必填。 category=configurators 表示该数据为动态配置类型，必填。 dynamic=false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。 enabled=true 覆盖规则是否生效，可不填，缺省生效。 application=foo 表示只对指定应用生效，可不填，表示对所有应用生效。 timeout=1000 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。  示例：\n  禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)\noverride://10.20.153.10/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;disbaled=true   调整权重：(通常用于容量评估，缺省权重为 100)\noverride://10.20.153.10/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;weight=200   调整负载均衡策略：(缺省负载均衡策略为 random)\noverride://10.20.153.10/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;loadbalance=leastactive   服务降级：(通常用于临时屏蔽某个出错的非关键服务)\noverride://0.0.0.0/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;application=foo\u0026amp;mock=force:return+null   提示 2.2.0 以上版本支持  ","text":null,"weight":35},{"authors":null,"date":-62135596800,"description":"降级 Dubbo 服务","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务降级","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/service-downgrade/","lvl3":24,"lvl4":"docs","lvl5":null,"objectID":"904f08ec4cc35a4b53eb0b60bb197e77","permalink":"/zh/docs/v2.7/user/examples/service-downgrade/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/service-downgrade/","summary":"可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。\n向注册中心写入动态配置覆盖规则：\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension(); Registry registry = registryFactory.getRegistry(URL.valueOf(\u0026#34;zookeeper://10.20.153.10:2181\u0026#34;)); registry.register(URL.valueOf(\u0026#34;override://0.0.0.0/com.foo.BarService?category=configurators\u0026amp;dynamic=false\u0026amp;application=foo\u0026amp;mock=force:return+null\u0026#34;)); 其中：\n mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。  提示 2.2.0 以上版本支持  ","text":null,"weight":35},{"authors":null,"date":-62135596800,"description":"Dubbo 消费端线程池模型用法","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"消费端线程池模型","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/consumer-threadpool/","lvl3":78,"lvl4":"docs","lvl5":null,"objectID":"68c40c82cf1fbdfbc7b20393e6d19266","permalink":"/zh/docs/v2.7/user/examples/consumer-threadpool/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/consumer-threadpool/","summary":"2.7.5 版本对整个调用链路做了全面的优化，根据压测结果显示，总体 QPS 性能提升将近 30%，同时也减少了调用过程中的内存分配开销。其中一个值得提及的设计点是 2.7.5 引入了 Servicerepository 的概念，在服务注册阶段提前生成 ServiceDescriptor 和 MethodDescriptor，以减少 RPC 调用阶段计算 Service 原信息带来的资源消耗。\n消费端线程池模型优化 对 2.7.5 版本之前的 Dubbo 应用，尤其是一些消费端应用，当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题，具体问题讨论可参见 Need a limited Threadpool in consumer side #2013\n改进后的消费端线程池模型，通过复用业务端被阻塞的线程，很好的解决了这个问题。\n老的线程池模型 我们重点关注 Consumer 部分：\n 业务线程发出请求，拿到一个 Future 实例。 业务线程紧接着调用 future.get 阻塞等待业务结果返回。 当业务数据返回后，交由独立的 Consumer 端线程池进行反序列化等处理，并调用 future.set 将反序列化后的业务结果置回。 业务线程拿到结果直接返回  2.7.5 版本引入的线程池模型\n 业务线程发出请求，拿到一个 Future 实例。 在调用 future.get() 之前，先调用 ThreadlessExecutor.wait()，wait 会使业务线程在一个阻塞队列上等待，直到队列中被加入元素。 当业务数据返回后，生成一个 Runnable Task 并放入 ThreadlessExecutor 队列 业务线程将 Task 取出并在本线程中执行：反序列化业务数据并 set 到 Future。 业务线程拿到结果直接返回  这样，相比于老的线程池模型，由业务线程自己负责监测并解析返回结果，免去了额外的消费端线程池开销。","text":null,"weight":35},{"authors":null,"date":-62135596800,"description":"Graceful shutdown in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Graceful Shutdown","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/graceful-shutdown/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"6ecdc93d18e6df5dca3dc69d978d2c16","permalink":"/docs/v2.7/user/examples/graceful-shutdown/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/graceful-shutdown/","summary":"","text":null,"weight":36},{"authors":null,"date":-62135596800,"description":"让 Dubbo 服务完成优雅停机","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"优雅停机","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/graceful-shutdown/","lvl3":37,"lvl4":"docs","lvl5":null,"objectID":"6ecdc93d18e6df5dca3dc69d978d2c16","permalink":"/zh/docs/v2.7/user/examples/graceful-shutdown/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/graceful-shutdown/","summary":"Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果用户使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。\n原理 服务提供方\n 停止时，先标记为不接收新请求，新请求过来时直接报错，让客户端重试其它机器。 然后，检测线程池中的线程是否正在运行，如果有，等待所有线程执行完成，除非超时，则强制关闭。  服务消费方\n 停止时，不再发起新的调用请求，所有新的调用在客户端即报错。 然后，检测有没有请求的响应还没有返回，等待响应返回，除非超时，则强制关闭。  设置方式 设置优雅停机超时时间，缺省超时时间是 10 秒，如果超时则强制关闭。\n# dubbo.properties dubbo.service.shutdown.wait=15000 如果 ShutdownHook 不能生效，可以自行调用：\nDubboShutdownHook.destroyAll();  建议 使用 tomcat 等容器部署的场景，建议通过扩展 ContextListener 等自行调用以下代码实现优雅停机  ","text":null,"weight":36},{"authors":null,"date":-62135596800,"description":"Hostname binding in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Hostname Binding","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/hostname-binding/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4e333c1dc8b7670c92d7620d2cbf3fa4","permalink":"/docs/v2.7/user/examples/hostname-binding/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/hostname-binding/","summary":"","text":null,"weight":37},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中绑定主机名","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"主机绑定","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/hostname-binding/","lvl3":60,"lvl4":"docs","lvl5":null,"objectID":"4e333c1dc8b7670c92d7620d2cbf3fa4","permalink":"/zh/docs/v2.7/user/examples/hostname-binding/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/hostname-binding/","summary":"查找顺序 缺省主机 IP 查找顺序：\n 通过 LocalHost.getLocalHost() 获取本机地址。 如果是 127.* 等 loopback 地址，则扫描各网卡，获取网卡 IP。  主机配置 注册的地址如果获取不正确，比如需要注册公网地址，可以：\n  可以在 /etc/hosts 中加入：机器名 公网 IP，比如：\ntest1 205.182.23.201   在 dubbo.xml 中加入主机地址的配置：\n\u0026lt;dubbo:protocol host=\u0026#34;205.182.23.201\u0026#34;\u0026gt;   或在 dubbo.properties 中加入主机地址的配置：\ndubbo.protocol.host=205.182.23.201   端口配置 缺省主机端口与协议相关：\n   协议 端口     dubbo 20880   rmi 1099   http 80   hessian 80   webservice 80   memcached 11211   redis 6379    可以按照下面的方式配置端口：","text":null,"weight":37},{"authors":null,"date":-62135596800,"description":"自定义 Dubbo 服务对外暴露的主机地址","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"主机配置","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/set-host/","lvl3":147,"lvl4":"docs","lvl5":null,"objectID":"0a6cc68241e30f4fa935190cec647706","permalink":"/zh/docs/v2.7/user/examples/set-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/set-host/","summary":"背景 在 Dubbo 中， Provider 启动时主要做两个事情，一是启动 server，二是向注册中心注册服务。启动 server 时需要绑定 socket，向注册中心注册服务时也需要发送 socket 唯一标识服务地址。\n dubbo中不设置host时默认host是什么? 那在dubbo中如何指定服务的host,我们是否可以用hostname或domain代替IP地址作为host? 在使用docker时,有时需要设置端口映射,此时,启动server时绑定的socket和向注册中心注册的socket使用不同的端口号,此时又该如何设置?  dubbo 中不设置 host 时默认 host 是什么 一般的 dubbo 协议配置如下:\n... \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20890\u0026#34; /\u0026gt; ... 可以看到,只配置了端口号,没有配置 host，此时设置的 host 又是什么呢?\n查看代码发现,在 org.apache.dubbo.config.ServiceConfig#findConfigedHosts() 中,通过 InetAddress.getLocalHost().getHostAddress() 获取默认 host。其返回值如下：\n 未联网时，返回 127.0.0.1 在阿里云服务器中，返回私有地址,如: 172.18.46.234 在本机测试时，返回公有地址，如: 30.5.10.11  那在 dubbo 中如何指定服务的 socket? 除此之外,可以通过 dubbo.protocol 或 dubbo.provider 的 host 属性对 host 进行配置,支持IP地址和域名,如下:\n... \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20890\u0026#34; host=\u0026#34;www.example.com\u0026#34;/\u0026gt; ... 在使用 docker 时，有时需要设置端口映射，此时，启动 server 时绑定的 socket 和向注册中心注册的 socket 使用不同的端口号，此时又该如何设置？ 见 dubbo 通过环境变量设置 host","text":null,"weight":37},{"authors":null,"date":-62135596800,"description":"减少注册中心上服务的注册数据","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"注册信息简化","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/simplify-registry-data/","lvl3":456,"lvl4":"docs","lvl5":null,"objectID":"7398fbb32d6e3d96ec4fe8d07461a82b","permalink":"/zh/docs/v2.7/user/examples/simplify-registry-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/docs/v2.7/user/examples/simplify-registry-data/","summary":"背景 Dubbo provider 中的服务配置项有接近 30 个配置项。 排除注册中心服务治理需要之外，很大一部分配置项是 provider 自己使用，不需要透传给消费者。这部分数据不需要进入注册中心，而只需要以 key-value 形式持久化存储。\nDubbo consumer 中的配置项也有 20+个配置项。在注册中心之中，服务消费者列表中只需要关注 application，version，group，ip，dubbo 版本等少量配置，其他配置也可以以 key-value 形式持久化存储。\n这些数据是以服务为维度注册进入注册中心，导致了数据量的膨胀，进而引发注册中心(如 zookeeper)的网络开销增大，性能降低。\n现有功能 sample 当前现状一个简单展示。通过这个展示，分析下为什么需要做简化配置。\n参考 sample 子工程： dubbo-samples-simplified-registry/dubbo-samples-simplified-registry-nosimple （跑 sample 前，先跑下 ZKClean 进行配置项清理）\ndubbo-provider.xml配置\n\u0026lt;dubbo:application name=\u0026#34;simplified-registry-nosimple-provider\u0026#34;/\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;demoService\u0026#34; class=\u0026#34;org.apache.dubbo.samples.simplified.registry.nosimple.impl.DemoServiceImpl\u0026#34;/\u0026gt; \u0026lt;dubbo:service async=\u0026#34;true\u0026#34; interface=\u0026#34;org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService\u0026#34; version=\u0026#34;1.2.3\u0026#34; group=\u0026#34;dubbo-simple\u0026#34; ref=\u0026#34;demoService\u0026#34; executes=\u0026#34;4500\u0026#34; retries=\u0026#34;7\u0026#34; owner=\u0026#34;vict\u0026#34; timeout=\u0026#34;5300\u0026#34;/\u0026gt; 启动 provider 的 main 方法之后，查看 zookeeper 的叶子节点（路径为：/dubbo/org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService/providers 目录下）的内容如下：\ndubbo%3A%2F%2F30.5.124.158%3A20880%2Forg.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService %3Fanyhost%3Dtrue%26application%3Dsimplified-registry-xml-provider%26async%3Dtrue%26dubbo%3D 2.0.2%26**executes**%3D4500%26generic%3Dfalse%26group%3Ddubbo-simple%26interface%3D org.apache.dubbo.samples.simplified.registry.nosimple.api.DemoService%26methods%3D sayHello%26**owner**%3Dvict%26pid%3D2767%26**retries**%3D7%26revision%3D1.2.3%26side%3D provider%26**timeout**%3D5300%26timestamp%3D1542361152795%26valid%3Dtrue%26version%3D1.2.3 从加粗字体中能看到有：executes, retries, owner, timeout。但是这些字段不是每个都需要传递给 dubbo ops 或者 dubbo consumer。 同样的，consumer 也有这个问题，可以在例子中启动 Consumer 的 main 方法进行查看。","text":null,"weight":37},{"authors":null,"date":-62135596800,"description":"Config logger Strategy in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Logger Strategy","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/logger-strategy/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"79eac244ba791d1465fc061e5ca09894","permalink":"/docs/v2.7/user/examples/logger-strategy/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/logger-strategy/","summary":"","text":null,"weight":38},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中适配日志框架","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"日志适配","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/logger-strategy/","lvl3":22,"lvl4":"docs","lvl5":null,"objectID":"79eac244ba791d1465fc061e5ca09894","permalink":"/zh/docs/v2.7/user/examples/logger-strategy/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/logger-strategy/","summary":"自 2.2.1 开始，dubbo 开始内置 log4j、slf4j、jcl、jdk 这些日志框架的适配[1]，也可以通过以下方式显式配置日志输出策略：\n 命令行\njava -Ddubbo.application.logger=log4j   在 dubbo.properties 中指定\ndubbo.application.logger=log4j   在 dubbo.xml 中配置\n\u0026lt;dubbo:application logger=\u0026#34;log4j\u0026#34; /\u0026gt;   [1]: 自定义扩展可以参考 日志适配扩展","text":null,"weight":38},{"authors":null,"date":-62135596800,"description":"Config dubbo access log","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Access Log","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/accesslog/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"f40f8a84e883fb3274cd565bb06b309d","permalink":"/docs/v2.7/user/examples/accesslog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/accesslog/","summary":"","text":null,"weight":39},{"authors":null,"date":-62135596800,"description":"配置 Dubbo 的访问日志","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"访问日志","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/accesslog/","lvl3":9,"lvl4":"docs","lvl5":null,"objectID":"f40f8a84e883fb3274cd565bb06b309d","permalink":"/zh/docs/v2.7/user/examples/accesslog/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/accesslog/","summary":"如果你想记录每一次请求信息，可开启访问日志，类似于apache的访问日志。注意：此日志量比较大，请注意磁盘容量。\n将访问日志输出到当前应用的log4j日志：\n\u0026lt;dubbo:protocol accesslog=\u0026#34;true\u0026#34; /\u0026gt; 将访问日志输出到指定文件：\n\u0026lt;dubbo:protocol accesslog=\u0026#34;http://10.20.160.198/wiki/display/dubbo/foo/bar.log\u0026#34; /\u0026gt; ","text":null,"weight":39},{"authors":null,"date":-62135596800,"description":"Use service container in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Service Container","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/service-container/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"661754ac053de871101e14b540e55e3f","permalink":"/docs/v2.7/user/examples/service-container/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/service-container/","summary":"","text":null,"weight":40},{"authors":null,"date":-62135596800,"description":"使用 Dubbo 中的服务容器","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"服务容器","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/service-container/","lvl3":85,"lvl4":"docs","lvl5":null,"objectID":"661754ac053de871101e14b540e55e3f","permalink":"/zh/docs/v2.7/user/examples/service-container/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/service-container/","summary":"服务容器是一个 standalone 的启动程序，因为后台服务不需要 Tomcat 或 JBoss 等 Web 容器的功能，如果硬要用 Web 容器去加载服务提供方，增加复杂性，也浪费资源。\n服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。\n服务容器的加载内容可以扩展，内置了 spring, jetty, log4j 等加载，可通过容器扩展点进行扩展。配置配在 java 命令的 -D 参数或者 dubbo.properties 中。\n容器类型 Spring Container   自动加载 META-INF/spring 目录下的所有 Spring 配置。\n  配置 spring 配置加载位置：\ndubbo.spring.config=classpath*:META-INF/spring/*.xml   Jetty Container  启动一个内嵌 Jetty，用于汇报状态。 配置：  dubbo.jetty.port=8080：配置 jetty 启动端口 dubbo.jetty.directory=/foo/bar：配置可通过 jetty 直接访问的目录，用于存放静态文件 dubbo.jetty.page=log,status,system：配置显示的页面，缺省加载所有页面    Log4j Container  自动配置 log4j 的配置，在多进程启动时，自动给日志文件按进程分目录。 配置：  dubbo.","text":null,"weight":40},{"authors":null,"date":-62135596800,"description":"Cache ReferenceConfig in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"ReferenceConfig Cache","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/reference-config-cache/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"99e92843885e2d65c668954ecf91a105","permalink":"/docs/v2.7/user/examples/reference-config-cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/reference-config-cache/","summary":"","text":null,"weight":41},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中缓存 ReferenceConfig","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"ReferenceConfig 缓存","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/reference-config-cache/","lvl3":75,"lvl4":"docs","lvl5":null,"objectID":"99e92843885e2d65c668954ecf91a105","permalink":"/zh/docs/v2.7/user/examples/reference-config-cache/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/reference-config-cache/","summary":"ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。\n因此，自 2.4.0 版本开始， dubbo 提供了简单的工具类 ReferenceConfigCache用于缓存 ReferenceConfig 实例。\n使用方式如下：\nReferenceConfig\u0026lt;XxxService\u0026gt; reference = new ReferenceConfig\u0026lt;XxxService\u0026gt;(); reference.setInterface(XxxService.class); reference.setVersion(\u0026#34;1.0.0\u0026#34;); ...... ReferenceConfigCache cache = ReferenceConfigCache.getCache(); // cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig XxxService xxxService = cache.get(reference); // 注意！ Cache会持有ReferenceConfig，不要在外部再调用ReferenceConfig的destroy方法，导致Cache内的ReferenceConfig失效！ // 使用xxxService对象 xxxService.sayHello(); 消除 Cache 中的 ReferenceConfig，将销毁 ReferenceConfig 并释放对应的资源。\nReferenceConfigCache cache = ReferenceConfigCache.getCache(); cache.destroy(reference); 缺省 ReferenceConfigCache 把相同服务 Group、接口、版本的 ReferenceConfig 认为是相同，缓存一份。即以服务 Group、接口、版本为缓存的 Key。\n可以修改这个策略，在 ReferenceConfigCache.getCache 时，传一个 KeyGenerator。详见 ReferenceConfigCache 类的方法。\nKeyGenerator keyGenerator = new ... ReferenceConfigCache cache = ReferenceConfigCache.","text":null,"weight":41},{"authors":null,"date":-62135596800,"description":"Config registry only service in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Register Only","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/registry-only/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"21ba8aa0bf882b2c6b628f84067b36eb","permalink":"/docs/v2.7/user/examples/registry-only/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/registry-only/","summary":"","text":null,"weight":41},{"authors":null,"date":-62135596800,"description":"只注册不订阅","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"只注册","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/registry-only/","lvl3":20,"lvl4":"docs","lvl5":null,"objectID":"21ba8aa0bf882b2c6b628f84067b36eb","permalink":"/zh/docs/v2.7/user/examples/registry-only/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/registry-only/","summary":"如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。\n禁用订阅配置\n\u0026lt;dubbo:registry id=\u0026#34;hzRegistry\u0026#34; address=\u0026#34;10.20.153.10:9090\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;qdRegistry\u0026#34; address=\u0026#34;10.20.141.150:9090\u0026#34; subscribe=\u0026#34;false\u0026#34; /\u0026gt; 或者\n\u0026lt;dubbo:registry id=\u0026#34;hzRegistry\u0026#34; address=\u0026#34;10.20.153.10:9090\u0026#34; /\u0026gt; \u0026lt;dubbo:registry id=\u0026#34;qdRegistry\u0026#34; address=\u0026#34;10.20.141.150:9090?subscribe=false\u0026#34; /\u0026gt; ","text":null,"weight":41},{"authors":null,"date":-62135596800,"description":"Distributed transaction support in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Distributed transaction","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/distributed-transaction/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"be6d0699d1fccdf10adf210b93678edf","permalink":"/docs/v2.7/user/examples/distributed-transaction/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/distributed-transaction/","summary":"","text":null,"weight":42},{"authors":null,"date":-62135596800,"description":"Dubbo 中分布式事务的支持","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"分布式事务","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/distributed-transaction/","lvl3":9,"lvl4":"docs","lvl5":null,"objectID":"be6d0699d1fccdf10adf210b93678edf","permalink":"/zh/docs/v2.7/user/examples/distributed-transaction/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/distributed-transaction/","summary":"分布式事务基于 JTA/XA 规范实现。\n两阶段提交：\n在 Dubbo 中，可以采用 seata 来完成对分布式事务的支持。","text":null,"weight":42},{"authors":null,"date":-62135596800,"description":"Automatical thread dump in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Thread Dump","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/dump/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"b673e6652144521dc8f9cc476405c9f4","permalink":"/docs/v2.7/user/examples/dump/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/dump/","summary":"","text":null,"weight":43},{"authors":null,"date":-62135596800,"description":"在 Dubbo 自动导出线程堆栈来保留现场","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"导出线程堆栈","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/dump/","lvl3":18,"lvl4":"docs","lvl5":null,"objectID":"b673e6652144521dc8f9cc476405c9f4","permalink":"/zh/docs/v2.7/user/examples/dump/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/dump/","summary":"当业务线程池满时，我们需要知道线程都在等待哪些资源、条件，以找到系统的瓶颈点或异常点。dubbo 通过 Jstack 自动导出线程堆栈来保留现场，方便排查问题。\n默认策略:\n 导出路径，user.home标识的用户主目录 导出间隔，最短间隔允许每隔10分钟导出一次  指定导出路径：\n# dubbo.properties dubbo.application.dump.directory=/tmp \u0026lt;dubbo:application ...\u0026gt; \u0026lt;dubbo:parameter key=\u0026#34;dump.directory\u0026#34; value=\u0026#34;/tmp\u0026#34; /\u0026gt; \u0026lt;/dubbo:application\u0026gt; ","text":null,"weight":43},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中使用高效的 Java 序列化（Kryo 和 FST）","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Kryo 和 FST 序列化","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/serialization/","lvl3":97,"lvl4":"docs","lvl5":null,"objectID":"8dd9a37434ecd075fc3e2e64499a722f","permalink":"/zh/docs/v2.7/user/examples/serialization/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/serialization/","summary":"启用 Kryo 和 FST 使用 Kryo 和 FST 非常简单，只需要在 dubbo RPC 的 XML 配置中添加一个属性即可：\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; serialization=\u0026#34;kryo\u0026#34;/\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; serialization=\u0026#34;fst\u0026#34;/\u0026gt; 注册被序列化类 要让 Kryo 和 FST 完全发挥出高性能，最好将那些需要被序列化的类注册到 dubbo 系统中，例如，我们可以实现如下回调接口：\npublic class SerializationOptimizerImpl implements SerializationOptimizer { public Collection\u0026lt;Class\u0026gt; getSerializableClasses() { List\u0026lt;Class\u0026gt; classes = new LinkedList\u0026lt;Class\u0026gt;(); classes.add(BidRequest.class); classes.add(BidResponse.class); classes.add(Device.class); classes.add(Geo.class); classes.add(Impression.class); classes.add(SeatBid.class); return classes; } } 然后在 XML 配置中添加：\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; serialization=\u0026#34;kryo\u0026#34; optimizer=\u0026#34;org.apache.dubbo.demo.SerializationOptimizerImpl\u0026#34;/\u0026gt; 在注册这些类后，序列化的性能可能被大大提升，特别针对小数量的嵌套对象的时候。\n当然，在对一个类做序列化的时候，可能还级联引用到很多类，比如Java集合类。针对这种情况，我们已经自动将JDK中的常用类进行了注册，所以你不需要重复注册它们（当然你重复注册了也没有任何影响），包括：\nGregorianCalendar InvocationHandler BigDecimal BigInteger Pattern BitSet URI UUID HashMap ArrayList LinkedList HashSet TreeSet Hashtable Date Calendar ConcurrentHashMap SimpleDateFormat Vector BitSet StringBuffer StringBuilder Object Object[] String[] byte[] char[] int[] float[] double[] 由于注册被序列化的类仅仅是出于性能优化的目的，所以即使你忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo和FST的性能依然普遍优于 hessian 和 dubbo 序列化。","text":null,"weight":44},{"authors":null,"date":-62135596800,"description":"Config netty4 support in dubbo","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Netty4","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/netty4/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"198b73996e21add81302e7fa9972499b","permalink":"/docs/v2.7/user/examples/netty4/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/netty4/","summary":"","text":null,"weight":44},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中配置 Netty4","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Netty4 支持","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/netty4/","lvl3":40,"lvl4":"docs","lvl5":null,"objectID":"198b73996e21add81302e7fa9972499b","permalink":"/zh/docs/v2.7/user/examples/netty4/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/netty4/","summary":"Dubbo 2.5.6 版本新增了对 netty4 通信模块的支持，启用方式如下\nprovider 端：\n\u0026lt;dubbo:protocol server=\u0026#34;netty4\u0026#34; /\u0026gt; 或\n\u0026lt;dubbo:provider server=\u0026#34;netty4\u0026#34; /\u0026gt; consumer 端：\n\u0026lt;dubbo:consumer client=\u0026#34;netty4\u0026#34; /\u0026gt;  注意  provider 端如需不同的协议使用不同的通信层框架，请配置多个 protocol 分别设置 consumer 端请使用如下形式：  \u0026lt;dubbo:consumer client=\u0026#34;netty\u0026#34;\u0026gt; \u0026lt;dubbo:reference /\u0026gt; \u0026lt;/dubbo:consumer\u0026gt; \u0026lt;dubbo:consumer client=\u0026#34;netty4\u0026#34;\u0026gt; \u0026lt;dubbo:reference /\u0026gt; \u0026lt;/dubbo:consumer\u0026gt; 接下来我们会继续完善： 性能测试指标及与 netty3 版本的性能测试对比，我们会提供一份参考数据\n ","text":null,"weight":44},{"authors":null,"date":-62135596800,"description":"Using Efficient Java Serialization in Dubbo (Kryo and FST)","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Serialization","lvl1":"docs","lvl2":"/docs/v2.7/user/examples/serialization/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"8dd9a37434ecd075fc3e2e64499a722f","permalink":"/docs/v2.7/user/examples/serialization/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/examples/serialization/","summary":"","text":null,"weight":44},{"authors":null,"date":-62135596800,"description":"在 Dubbo 中使用高效的 Java 序列化（Kryo 和 FST）","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Kryo 和 FST 序列化","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/serialization/","lvl3":259,"lvl4":"docs","lvl5":null,"objectID":"7e4d2dd5c9e83bbb5103115e2ebf07d8","permalink":"/zh/docs/v2.7/user/serialization/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/docs/v2.7/user/serialization/","summary":"目录  序列化漫谈 启用Kryo和FST 注册被序列化类 无参构造函数和Serializable接口 序列化性能分析与测试  测试环境 测试脚本 Dubbo RPC中不同序列化生成字节大小比较 Dubbo RPC中不同序列化响应时间和吞吐量对比   未来  序列化漫谈 dubbo RPC是dubbo体系中最核心的一种高性能、高吞吐量的远程调用方式，我喜欢称之为多路复用的TCP长连接调用，简单的说：\n 长连接：避免了每次调用新建TCP连接，提高了调用的响应速度 多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量。  dubbo RPC主要用于两个dubbo系统之间作远程调用，特别适合高并发、小数据的互联网场景。\n而序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是我们提升分布式系统性能的最关键因素之一。\n在dubbo RPC中，同时支持多种序列化方式，例如：\n dubbo序列化：阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它 hessian2序列化：hessian是一种跨语言的高效二进制序列化方式。但这里实际不是原生的hessian2序列化，而是阿里修改过的hessian lite，它是dubbo RPC默认启用的序列化方式 json序列化：目前有两种实现，一种是采用的阿里的fastjson库，另一种是采用dubbo中自己实现的简单json库，但其实现都不是特别成熟，而且json这种文本序列化性能一般不如上面两种二进制序列化。 java序列化：主要是采用JDK自带的Java序列化实现，性能很不理想。  在通常情况下，这四种主要序列化方式的性能从上到下依次递减。对于dubbo RPC这种追求高性能的远程调用方式来说，实际上只有1、2两种高效序列化方式比较般配，而第1个dubbo序列化由于还不成熟，所以实际只剩下2可用，所以dubbo RPC默认采用hessian2序列化。\n但hessian是一个比较老的序列化实现了，而且它是跨语言的，所以不是单独针对java进行优化的。而dubbo RPC实际上完全是一种Java to Java的远程调用，其实没有必要采用跨语言的序列化方式（当然肯定也不排斥跨语言的序列化）。\n最近几年，各种新的高效序列化方式层出不穷，不断刷新序列化性能的上限，最典型的包括：\n 专门针对Java语言的：Kryo，FST等等 跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等等  这些序列化方式的性能多数都显著优于hessian2（甚至包括尚未成熟的dubbo序列化）。\n有鉴于此，我们为dubbo引入Kryo和FST这两种高效Java序列化实现，来逐步取代hessian2。\n其中，Kryo是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。而FST是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例，但我认为它还是非常有前途的。\n在面向生产环境的应用中，我建议目前更优先选择Kryo。\n启用Kryo和FST 使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：\n\u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; serialization=\u0026#34;kryo\u0026#34;/\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; serialization=\u0026#34;fst\u0026#34;/\u0026gt; 注册被序列化类 要让Kryo和FST完全发挥出高性能，最好将那些需要被序列化的类注册到dubbo系统中，例如，我们可以实现如下回调接口：\npublic class SerializationOptimizerImpl implements SerializationOptimizer { public Collection\u0026lt;Class\u0026gt; getSerializableClasses() { List\u0026lt;Class\u0026gt; classes = new LinkedList\u0026lt;Class\u0026gt;(); classes.","text":null,"weight":46},{"authors":null,"date":-62135596800,"description":"Other languages support","dir":"docs/v2.7/user/languages/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Other Languages","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"02206d902c8cda160d64edda38eef032","permalink":"/docs/v2.7/user/languages/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/","summary":"","text":null,"weight":50},{"authors":null,"date":-62135596800,"description":"Java 和 Go 是 Dubbo 社区主力支持的语言，除此之外，Dubbo 社区还有以下语言的支持","dir":"docs/v2.7/user/languages/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"其他语言支持","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"02206d902c8cda160d64edda38eef032","permalink":"/zh/docs/v2.7/user/languages/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/languages/","summary":"","text":null,"weight":50},{"authors":null,"date":-62135596800,"description":"Guidelines for contributing to Dubbo","dir":"docs/contribution-guidelines/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Contribution Guideline","lvl1":"docs","lvl2":"/docs/contribution-guidelines/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"99a93ef9534d11fef4be3e4b3b1a6381","permalink":"/docs/contribution-guidelines/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/contribution-guidelines/","summary":"","text":null,"weight":90},{"authors":null,"date":-62135596800,"description":"Dubbo 贡献指南","dir":"docs/contribution-guidelines/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"为 Dubbo 做贡献","lvl1":"docs","lvl2":"/zh/docs/contribution-guidelines/","lvl3":171,"lvl4":"docs","lvl5":null,"objectID":"99a93ef9534d11fef4be3e4b3b1a6381","permalink":"/zh/docs/contribution-guidelines/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/contribution-guidelines/","summary":"为 Dubbo 做贡献 Dubbo 是在非限制性的 Apache 2.0 许可下发布的，遵循标准的 Github 开发流程，使用Github追踪处理问题，并将 pull request 合并到 master 中。如果您想为 Dubbo 做贡献（即便是一些微小的），请不要犹豫，遵循下面的指导方针。\n签署贡献者许可协议 在我们接受一个补丁或 pull request 之前，我们需要您签署贡献者许可协议。签署贡献者协议并不授予任何人对代码仓库的提交权限，但是它意味着我们可以接受您的贡献，并且如果我们这样做，您将获得一个作者标注。主动贡献者可能会被邀请加入核心团队，并有权限合并 pull request。\n联系我们 邮件列表 邮件列表是讨论几乎所有与 Dubbo 有关事情的推荐方式。有关如何订阅的详细文档，请参阅指南。\n dev@dubbo.apache.org: 开发邮件列表，如果您在使用或开发Dubbo时遇到任何问题，您可以在此提出问题。 commits@dubbo.apache.org: 所有提交将被发送到这个邮件列表。如果您对Dubbo的发展感兴趣，您可以订阅它。 notification@dubbo.apache.org: 所有Github issue和pull request的更新都会被发送到这个邮件列表。  报告问题 在报告任何问题时请遵循模版。\n代码约定 我们的代码风格几乎和标准 Java 约定一致（流行IDE的默认设置满足这一点），主要有以下附加限制：\n  如果当前行中有超过 120 个字符，则起一个新的行。\n  确保所有新的 .java 文件都有一个简单的 JavaDoc 类注释，其中至少有一个标识创建日期的标签，最好至少有一个关于该类的解释说明。\n  将ASF许可注释添加到所有新的 .java 文件（从项目中的现有文件复制）\n  请确保没有将 @author 标记添加到您所贡献的文件中，因为 Apache 不使用 @author 标记，其他方式（如cvs）将公平地记录所有您的贡献。","text":null,"weight":90},{"authors":null,"date":-62135596800,"description":"Erlang support","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Erlang","lvl1":"docs","lvl2":"/docs/v2.7/user/languages/erlang/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4a67628aafafb6a037d36c033439062d","permalink":"/docs/v2.7/user/languages/erlang/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/docs/v2.7/user/languages/erlang/","summary":"","text":null,"weight":200},{"authors":null,"date":-62135596800,"description":"Erlang 支持","dir":"docs/v2.7/user/languages/erlang/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Erlang","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/languages/erlang/","lvl3":0,"lvl4":"docs","lvl5":null,"objectID":"4a67628aafafb6a037d36c033439062d","permalink":"/zh/docs/v2.7/user/languages/erlang/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/docs/v2.7/user/languages/erlang/","summary":"","text":null,"weight":200},{"authors":null,"date":1608595200,"description":"本文将向你介绍Dubbo-Api-Docs\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo-Api-Docs -- Apache Dubbo文档展示\u0026测试工具","lvl1":"blog","lvl2":"/zh/blog/2020/12/22/dubbo-api-docs-apache-dubbo%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","lvl3":485,"lvl4":"blog","lvl5":null,"objectID":"93382be6830640281976f814623e8ff5","permalink":"/zh/blog/2020/12/22/dubbo-api-docs-apache-dubbo%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","publishdate":"2020-12-22T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2020/12/22/dubbo-api-docs-apache-dubbo%E6%96%87%E6%A1%A3%E5%B1%95%E7%A4%BA%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","summary":"Dubbo-Api-Docs 简介 Dubbo-Api-Docs 是一个展示dubbo接口文档,测试接口的工具. 参考了springfox的设计,通过增加一些描述接口及参数的注解,即可展示具备测试能力的接口文档.\nDubbo-Api-Docs 目前通过直连服务节点的方式获取该服务的接口列表. 测试接口时可以直连也可以通过注册中心.未来会增加通过注册中心获取服务列表的方式.并根据Dubbo的升级规划增加新的功能支持.也会根据社区的需求增加功能.\nDubbo-Api-Docs 会在服务提供者启动完毕后扫描docs相关注解并将处理结果缓存.并增加一些Dubbo-Api-Docs相关的Dubbo提供者接口. 缓存的数据在将来可能会放到Dubbo元数据中心中.\n当前版本: 同Dubbo版本号  由于Dubbo-Api-Docs目前还处于测试阶段,并未发包到maven中央仓库,需要自行编译.编译方式同大部分java工程编译方式,此处就不赘述了,源码仓库\n \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-api-docs-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-api-docs-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${dubbo-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 快速入门 1.dubbo提供者项目的方法参数中加上 Dubbo-Api-Docs 注解  如果 dubbo提供者的接口和方法参数在一个单独的jar项目中,则在该项目中引入: dubbo-api-docs-annotations dubbo提供者项目引入 dubbo-api-docs-core 在提供者项目的项目启动类(标注了@SpringBootApplication的类)或者配制类(标注了@Configuration的类)中增加注解 @EnableDubboApiDocs 以启用Dubbo Api Docs功能   为避免增加生产环境中的资源占用, 建议单独创建一个配制类用于启用Dubbo-Api-Docs, 并配合 @Profile(\u0026ldquo;dev\u0026rdquo;) 注解使用 当然, Dubbo-Api-Docs 仅在项目启动时多消耗了点CPU资源, 并使用了一点点内存用于缓存, 将来会考虑将缓存中的内容放到元数据中心.\n 下面以dubbo-api-docs-examples项目中的部分服务接口为例: git clone -b 2.7.x https://github.com/apache/dubbo-spi-extensions.git 进入dubbo-spi-extensions/dubbo-api-docs 目录,编译源码并安装到本地仓库:\nmvn clean install -Dmaven.test.skip=true 进入 dubbo-spi-extensions/dubbo-api-docs/dubbo-api-docs-examples 目录\ndubbo-api-docs-examples 中有两个子模块:","text":null,"weight":0},{"authors":null,"date":1608595200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"home","lang":"zh","lastmod":1611132661,"lvl0":"Nacos","lvl1":"page","lvl2":"/zh/","lvl3":0,"lvl4":"","lvl5":null,"objectID":"","permalink":"/zh/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/zh/","summary":"","text":null,"weight":0},{"authors":null,"date":1589760000,"description":"2.7.5 发布，及其功能解析\n","dir":"blog/releases/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"2.7.5 功能解析","lvl1":"blog","lvl2":"/zh/blog/2020/05/18/2.7.5-%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/","lvl3":630,"lvl4":"blog","lvl5":null,"objectID":"838641158b8ab3643bae5c5606aeb489","permalink":"/zh/blog/2020/05/18/2.7.5-%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/","publishdate":"2020-05-18T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2020/05/18/2.7.5-%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/","summary":"近日，备受瞩目的 Dubbo 2.7.5 版本正式发布，在 2.7.5 版本中，Dubbo 引入了很多新的特性、对现有的很多功能做了增强、同时在性能上也有了非常大的提升，这个版本无论对 Dubbo 社区亦或是开发者来说，都将是一个里程碑式的版本。\n 应用粒度服务注册【beta】 HTTP/2 (gRPC) 协议支持 Protobuf 支持 性能优化，调用链路性能提升 30% 支持 TLS 安全传输链路 优化的消费端线程模型 新增更适应多集群部署场景的负载均衡策略 全新的应用开发 API （兼容老版本应用）【beta】 其他一些功能增强与 bugfix  首先，从服务发现上，新版本突破以往基于接口粒度的模型，引入了全新的基于应用粒度的服务发现机制 - 服务自省，虽然该机制当前仍处于 beta 阶段，但对于 Dubbo 向整个微服务云原生体系靠齐，都打下了非常好的基础；得益于紧凑的协议设计和代码实现上的优化，Dubbo 一直以来都具有较好的性能表现，在 2.7.5 版本中，性能上有了进一步的提升，根据来自官方维护团队的压测，新版本在调用链路上性能提升达到 30%；云原生微服务时代，多语言需求变得越来越普遍，协议的通用性和穿透性对于构建打通前后端的整套微服务体系也变得非常关键，Dubbo 通过实现 gRPC 协议实现了对 HTTP/2 协议的支持，同时增加了与 Protobuf 的结合。\n1. 应用粒度服务注册【beta】 从 Java 实现版本的角度来说，Dubbo 是一个面向接口代理的服务开发框架，服务定义、服务发布以及服务引用都是基于接口，服务治理层面包括服务发现、各种规则定义也都是基于接口定义的，基于接口可以说是 Dubbo 的一大优势，比如向开发者屏蔽了远程调用细节、治理粒度更精细等。但基于接口的服务定义同时也存在一些问题，如服务，与业界通用的微服务体系等。\n针对以上问题，2.7.5 版本引入了一种新的服务定义/治理机制：服务自省，简单来说这是一种基于应用粒度的服务治理方案。一个实例只向注册中心注册一条记录，彻底解决服务推送性能瓶颈，同时由于这样的模型与主流微服务体系如 SpringCloud、K8S 等天然是对等的，因此为 Dubbo 解决和此类异构体系间的互联互通清除了障碍。有兴趣进一步了解 Dubbo 服务自省机制如何解决异构微服务体系互联互通问题的，可具体参考我们之前的文章解析《Dubbo 如何成为联通异构微服务体系的最佳服务开发框架》。\n以下是服务自省机制的基本工作原理图。\n要了解更多关于服务自省工作原理的细节，请参与官方文档及后续文章。\n服务自省与当前已有的机制之间可以说是互补的关系，Dubbo 框架会继续保持接口粒度的服务治理的优势，实现接口和应用两个粒度互为补充的局面，兼顾性能、灵活性和通用性，力争使 Dubbo 成为微服务开发的最佳框架。","text":null,"weight":0},{"authors":null,"date":1589760000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"home","lang":"en","lastmod":1611132661,"lvl0":"Nacos","lvl1":"page","lvl2":"/","lvl3":0,"lvl4":"","lvl5":null,"objectID":"","permalink":"/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/","summary":"","text":null,"weight":0},{"authors":null,"date":1589760000,"description":"This article will introduce you how to understand the details of each version and upgrade matters needing attention.\n","dir":"blog/releases/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Past Releases","lvl1":"blog","lvl2":"/blog/2020/05/18/past-releases/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"414170e37e220d792d5b2d99e148cb2c","permalink":"/blog/2020/05/18/past-releases/","publishdate":"2020-05-18T00:00:00Z","readingtime":0,"relpermalink":"/blog/2020/05/18/past-releases/","summary":"","text":null,"weight":0},{"authors":null,"date":1589760000,"description":"本文将向你介绍如何点击了解各版本详情和升级注意事项。\n","dir":"blog/releases/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"过往版本","lvl1":"blog","lvl2":"/zh/blog/2020/05/18/%E8%BF%87%E5%BE%80%E7%89%88%E6%9C%AC/","lvl3":214,"lvl4":"blog","lvl5":null,"objectID":"414170e37e220d792d5b2d99e148cb2c","permalink":"/zh/blog/2020/05/18/%E8%BF%87%E5%BE%80%E7%89%88%E6%9C%AC/","publishdate":"2020-05-18T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2020/05/18/%E8%BF%87%E5%BE%80%E7%89%88%E6%9C%AC/","summary":"验证 可以按照这里的步骤, 利用KEYS文件来验证下载。\nApache Dubbo 请点击了解各版本详情和升级注意事项\n GitHub: https://github.com/apache/incubator-dubbo\n发布说明：https://github.com/apache/incubator-dubbo/releases\n 2.7.7 (2020-05-18)  source | asc | sha512  2.7.5 (2019-12-29)  source | asc | sha512  2.7.4.1 (2019-10-27)  source | asc | sha512  2.7.4 (2019-10-19)  source | asc | sha512  2.7.3 (2019-07-19)  source | asc | sha512  2.7.2 (2019-06-06)  source | asc | sha512  2.7.1 (2019-03-26)  source | asc | sha512 binary | asc | sha512  2.","text":null,"weight":0},{"authors":null,"date":1589155200,"description":"通过这篇文章我们将：总结过去一年 Dubbo 社区取得的成绩\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"从 2019 到 2020，Apache Dubbo 年度回顾与总结","lvl1":"blog","lvl2":"/zh/blog/2020/05/11/%E4%BB%8E-2019-%E5%88%B0-2020apache-dubbo-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/","lvl3":722,"lvl4":"blog","lvl5":null,"objectID":"49b89df6d1097461528a6d84c220dd2a","permalink":"/zh/blog/2020/05/11/%E4%BB%8E-2019-%E5%88%B0-2020apache-dubbo-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/","publishdate":"2020-05-11T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2020/05/11/%E4%BB%8E-2019-%E5%88%B0-2020apache-dubbo-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%BB%E7%BB%93/","summary":"非常感谢大家对 Dubbo 社区的关注，通过这篇文章我们将：总结过去一年 Dubbo 社区取得的成绩，包括社区和框架演进两个方面；展望未来 Dubbo 社区和框架的新的规划（roadmap）。社区建设是推动 Dubbo 健康持续发展的一个非常重要的环节，我们需要与社区保持良性的互动、有活跃的贡献者、有积极的富有建设性的讨论，而整个 Dubbo 社区过去一年在这方面都做的不错；在框架演进上，我们主要发布了 2.7.0 - 2.7.5 共 6 个特性版本，功能层面涵盖编程模型、协议、服务治理、性能优化等多个方面；除了已经发布的功能外，我们在 Dubbo 3.0 协议、服务自省和云原生等方向上也做了深入的探索，对这些方向的支持将是 Dubbo 接下来的重要工作方向，希望能通过这篇文章将其中更详细的思考和计划同步给大家。\n社区回顾 回顾 Dubbo 社区过去一年的发展，其中一个重要的节点就是 2019 年 5 月从 Apache 孵化毕业。成为第二个由 Alibaba 捐献后从 Apache 毕业的项目，我有幸参与到了从重启开源、进入 Apache 孵化到毕业的整个过程，社区在此过程中做了大量的工作，包括邮件列表建设、代码规范检查、文档和代码国际化、issue/pr 处理等，这些一方面是 Apache 社区要求的工作，同时也为推动 Dubbo 的发展起到了正面的作用。\n在从 Apache 毕业之后，Dubbo 相关的项目也进行了迁移，都迁移到了 Apache 组织之下：\nDubbo 社区的项目总共有 24 个之多，维护如此多的项目，并不是单纯靠几个活跃的开发者就能做到的，而是靠整个社区努力的结果。我总结了过去一年提名的所有 Committer/PMC，总过有 27 人获得提名（23 名 committer、4 名 PMC），通过下方的饼状图可以看出，只有不到 20% 的贡献者是来自于 Alibaba，而 80% 以上是来自各个不同组织的开发者或爱好者。这样的 Committer 分布，是加入 Apache 带给 Dubbo 社区的一个最重要的变化之一：Dubbo 项目是属于整个社区的，反映的是不同组织不同开发者的共同诉求，它的发展不是由一个公司控制或决定的，而是由社区共同讨论后决定的。如果你对参与到 Dubbo 社区感兴趣，都可以参与到 Dubbo 发展的讨论、决策和 coding 中来，也非常期待各位能成为下一个 Committer。","text":null,"weight":0},{"authors":null,"date":1575244800,"description":"对正在开发的功能进行验证测试，或者单独调用某台机器的服务\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo测试验证","lvl1":"blog","lvl2":"/zh/blog/2019/12/02/dubbo%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81/","lvl3":207,"lvl4":"blog","lvl5":null,"objectID":"bba95a80d0c9ac3bc3448762eb6882eb","permalink":"/zh/blog/2019/12/02/dubbo%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81/","publishdate":"2019-12-02T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/12/02/dubbo%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81/","summary":"除了线上常规的使用场景以外，我们在日常使用中还需要一些特定的使用方式，比如对正在开发的功能进行验证测试，比如单独调用某台机器的服务，这篇文章就来介绍一下这些场景下的使用方式。\n只订阅 为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。\n可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。 禁用注册配置\n\u0026lt;dubbo:registry address=\u0026quot;10.20.153.10:9090\u0026quot; register=\u0026quot;false\u0026quot; /\u0026gt;  或者\n\u0026lt;dubbo:registry address=\u0026quot;10.20.153.10:9090?register=false\u0026quot; /\u0026gt;  指定IP调用 在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表\n可以通过以下几种配置来指定IP调用\n XML 配置： 如果是线上需求需要点对点，可在 dubbo:reference 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下： \u0026lt;dubbo:reference id=\u0026quot;xxxService\u0026quot; interface=\u0026quot;com.alibaba.xxx.XxxService\u0026quot; url=\u0026quot;dubbo://localhost:20890\u0026quot; /\u0026gt; 通过-D参数指定： 在 JVM 启动参数中加入-D参数映射服务地址，如：java -Dcom.alibaba.xxx.XxxService=dubbo://localhost:20890 通过文件映射: 如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 dubbo:reference 中的配置，如： java -Ddubbo.resolve.file=xxx.properties\n然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：com.alibaba.xxx.XxxService=dubbo://localhost:20890  回声测试 使用方式 回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。\n所有服务自动实现 EchoService 接口，只需将任意服务引用强制转型为 EchoService，即可使用。\nSpring 配置：\n\u0026lt;dubbo:reference id=\u0026quot;memberService\u0026quot; interface=\u0026quot;com.xxx.MemberService\u0026quot; /\u0026gt;  代码：","text":null,"weight":0},{"authors":null,"date":1575072000,"description":"Dubbo 是实现框架，融入 service mesh 理念就是我们今天分享的","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 在 Service Mesh 下的思考和方案","lvl1":"blog","lvl2":"/zh/blog/2019/11/30/dubbo-%E5%9C%A8-service-mesh-%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%96%B9%E6%A1%88/","lvl3":107,"lvl4":"blog","lvl5":null,"objectID":"16236abf1ae05810ebb1e62d67158ba3","permalink":"/zh/blog/2019/11/30/dubbo-%E5%9C%A8-service-mesh-%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%96%B9%E6%A1%88/","publishdate":"2019-11-30T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/11/30/dubbo-%E5%9C%A8-service-mesh-%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%96%B9%E6%A1%88/","summary":"开头 Service Mesh这个“热”词是2016年9月被“造”出来，而今年2018年更是被称为service Mesh的关键之年，各家大公司都希望能在这个思潮下领先一步。今天我也分享阿里中间件在这方面的观点，思考和实践。考虑到有些人没了解过Dubbo(集团内以HSF为主)和Servicemesh，先简单介绍下这两个词。Dubbo应该是国内最受欢迎的远程服务框架，在Github上有超过2w的star数，也是阿里分布式架构互联互通的核心所在。跟Dubbo一样，servicemesh也是面向服务互联互通这一问题域，是云原生技术栈的核心之一；大家可以简单理解service mesh就是云原生组织定义的微服务架构解决理念。Dubbo是实现框架，融入service mesh理念就是我们今天分享的。\n现状和挑战 当前Dubbo支撑的阿里分布式应用内支撑万级别的应用数，运行在20多万的服务器实例上，每天调用量是万亿级别，这应该是国内最大的分布式应用集群。\n挑战主要来自三方面\n 首先， 数以万计的应用意味着有以十万级的服务，理顺错综复杂的服务拓扑关系，甚至及时诊断某个异常调用链路，需要考虑海量数据的拉取分析，是非常有挑战的，阿里通过EagleEye鹰眼链路系统提供可观察性和治理能力来解决； 第二个挑战是机房级别容灾，阿里的机房是分布在天南海北，大家可以想象横跨数千公里的网络延迟会造成服务互通很大的影响，所以在保证一定恢复时间和一定数据容错的情况下做异地多活是有巨大挑战，阿里通过支持异地多活的单元化架构解决。 第三个挑战是阿里业务众多，尤其像阿里生态中的高德，UC，优酷等所使用的开发语言跟淘系Java是不一样的，比如PHP，C，Nodejs，Dart等，要维护多个版本并保证各版本具有同样的功能是成本比较高的；这个挑战在云原生的新一代理念下更具挑战，毕竟。今天主题跟第三个挑战是息息相关，能解决一定的问题。  这里讲个大鱼吃小鱼的故事来简单理解下云原生：软件会吃掉这个世界，也就是信息化不可避免，而开源会吃掉软件，最终云原生会吃掉开源。这正代表了云原生理念的颠覆性，从商业软件到开源到云原生，环环相套，以体系化和层次化的方式推荐各个方面的开源方案和标准，这会极大降低企业级架构服务的技术门槛，是企业信息化之路的一大利好，当然也是进化方向。这个故事跟今天的主题\u0026ndash;开发者定义软件未来，是非常契合，也就是说这个趋势至少在企业级软件服务领域正在发生。云原生：Cloud Native is Patterns with A complete and trusted tool kit for modern architectures。\nService Mesh的典型方案\nService Mesh的典型方案 讲完故事，回到servicemesh。\n传统形态下SDK代表着一个特定语言的库，由应用和微服务框架共处一进程内，在发布升级中共享生命周期。比较典型的代表是Twitter的finagle，Google的stubby/grpc，阿里巴巴的HSF/Dubbo.\nServiemesh下推荐是右边Sidecar方案，Sidecar方案没有引入新的功能，只是改变了原有功能的位置，以独立的应用来存在，大家可以暂时以nginx来理解其网络代理能力也可以。\n在这张图中希望大家关注两个信息， 1）所有的sidecar形成逻辑网络被称为数据面，是业务服务的链路中是强依赖节点，承载了业务数据互联互通的基础；传统的ops管控服务被称为控制面，这部分跟传统是大同小异。 2）在sidecar形态下，网络会增加两跳，即应用与sidecar之间，他们之间的数据互通也是基于协议规范。后面会详细讲。\nSidecar模式的优劣 接下来从开发和运维两个阶段来分开比较。\n 多语言支持方面，既然sidecar是独立应用，用最合适的一种语言开发完成即可，就避免了需要针对不同语言的应用场景做不同的版本开发。当前阿里选择基于C语言的Envoy做二次开发来追求最小的footprint和性能，当然也曾经历一些弯路，比如曾经用Java开发过一个sidecar，但最终由于引入JRE体量大和GC带来的抖动等问题证明不可行。有必要强调的是：这里说的是sidecar自身开发现在避免了多语言多版本的问题，而真要支持任意服务自由采用任意语言实现这一理想，是需要站在从业务到数据面再到业务的整个链路上的数据交互做思考。 性能方面，sidecar情形下由于会增加两跳，这两跳是业务应用与sidecar的两个进程之间的调用，这是本机，即便是经过优化，也是会增加进程切换以及数据转换的开销。经过我们的优化测试，在正常的业务访问下，相比SDK形态下最多增加1毫秒的开销，这在大多数业务情形下是基本无感知无影响。 再看运维阶段的比较，一般SDK形态的服务框架都是只关心开发的诉求，对于如何运维都是不关心，而软件生命周期中运维是最长的，如何从中间件角度解决更多的运维问题是非常有意义的。阿里的中间件经常需要升级，以库的形式升级时就需要业务方应用重新打包，这个推动业务方变更的方式是比较被动，而且周期很长。 当以镜像为基本原子单位进行发布部署时，阿里的中间件SDK体量大概是200兆，需要与业务一起打包，这样在业务应用升级时让分发的包就显得笨重，时效性相比sidecar形态就差一截。  稍微总结下，sidecar具有两个明显优势，一个是多语言开发维护成本低 ，另一个是独立升级，当然代价是需要增加一点点的网络延迟。至此大家是不是觉得Sidecar基本完美？ 别着急，需要大家再思考一个问题：SDK模式下中间件组件会随应用一起发布，拥有完全一致的生命周期；而在sidecar模式下，如何管理sidecar的生命周期？这里可以拿无线耳机来举个例子，无线耳机是独立了，但必须独立电源的驱动，所以充电是要的。是的，在大规模的集群中这个点会带来不小的复杂性。\n关键点 下面跟大家分享下我们对servicemesh理解的三个关键技术点。分别是sidecar运维，数据面与控制面的集成，协议。\n 先说sidecar的运维，这是个难点，也是为什么sidecar方案以前没有被广泛应用的重要原因。前面说sidecar与应用现在成为两个不同的进程，要考虑多个事宜，一是要考虑如何把sidecar与应用部署在一起，二是考虑业务进程或sidecar进程一方需要升级重启时如何协同来保证请求的正常处理或转发，即优雅上下线的问题。这些事宜考虑清楚并解决后，算是具备servicemesh的前提条件。当然，kubernetes解决了这块的事情，提供了initiator类似插件的机制来对原子性的pod进行注入sidecar，并通过健康检查机制来保证两个进程的协同。简单地也可以这么理解：先把kubernetes容器调度平台的实施是servicemesh的前提条件。 数据面中的sidecar的服务治理能力则是其核心竞争力，包括负载均衡策略，路由，安全，权重等等，这些能力是以规则形式通过控制面来统一下发给数据面。在传统微服务框架下数据面和控制面的集成是紧耦合，也就是数据面和控制面是一体的，举例来说用了Dubbo框架，只能选择Dubbo-Ops。而Envoy作为servicemesh思潮的带领者，提出了一整套的API规范，Istio可以实现其xDS接口，阿里巴巴也可以根据自己的架构设计实现类似的服务平台。 协议 协议 协议， 重要的事说三遍。。。sidecar和Dubbo的内核是网络协议的处理器，而sidecar又是面向多语言场景的，所以自然协议处理能力是要强调的。先说下阿里Dubbo当下向Mesh方向发展时遇到难点。首先我们的服务接口都是通过Java Interface描述，其次涉及的传输模型DTO也是Java POJO定义，最后协议也是私有的。这会导致跨语言比较难，而sidecar形态需要面向多语言，这些问题更是首当其冲。考虑到这里有点稍微偏细节点，希望大家带着如下问题来先思考下：业务应用到sidecar之间的数据交换要考虑什么? Sidecar自身在处理网络字节流时又要考虑什么？是的，首先业务应用最好都不依赖特定协议库，也不依赖特接口定义库；Sidecar自身处理数据时跟nginx很接近，但最好具备协议转换适配的能力，比如把基于HTTP的请求转换为Dubbo请求，就能轻松集成Dubbo遗留系统。  回看协议 既然协议在跨语言场景下如此重要，有必要稍微回归下协议的历史轨迹。看历史一般是轻松有趣的过程，最重要的好处是能使我们头脑清晰而不迷茫。\n我们先从2008年说起，很近也就10年，阿里服务框架诞生这一年。当年各大公司还在炒作SOA思想的时候，阿里在不清楚SOA思想的情况下根据自身业务诉求实践拥抱了SOA的架构。阿里服务框架一直是从三个层面来定义，第一RPC通信 第二是提供丰富强大的治理能力 第三就是基于容器隔离的运维能力，使得中间件可以独立升级。这个理念直到今日都是非常先进，非常的赞。就像前面说的，Dubbo主要是面向Java领域的微服务架构解决方案，在以Java为主导的技术架构下是绝对首选，但因为其协议设计是私有特性，要想成为跨语言的协议标准是有一定难度。\n事实上，之前已经出现了很多通用的跨语言的服务集成规范。最早是91年的CORBA，是分布式对象访问协议，2000年的SOAP是当年webservice思想下的协议，无论是CORBA还是SOAP都是支持所有平台和语言的一套规范，但是设计地比较复杂笨重，且性能存在一定问题。\nREST是一种架构风格，相比SOAP的设计，有非常优秀的理念和最佳实践指导，并且万维网作为世界上最大型最成功的的分布式应用是REST最好的证明。但跟SOAP一样，REST跑在1上有性能瓶颈，这个也可能是当年阿里服务框架没有选择REST规范的原因。额外提下，REST思想虽然很早就有，但事实上REST的规范在Java领域JAX-RS API 直到最近两年在2.","text":null,"weight":0},{"authors":null,"date":1572652800,"description":"本文介绍了 Dubbo 服务端异步接口的实现背景和实践\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo服务端异步接口的实现背景和实践","lvl1":"blog","lvl2":"/zh/blog/2019/11/02/dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","lvl3":106,"lvl4":"blog","lvl5":null,"objectID":"c5636591d950af661f4acc9d447a43f0","permalink":"/zh/blog/2019/11/02/dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","publishdate":"2019-11-02T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/11/02/dubbo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","summary":"铺垫 建议先对Dubbo的处理过程中涉及的线程阶段先做个了解，具体可参考Dubbo客户端异步接口的实现背景和使用场景。\n实现背景 有必要比较详细点的介绍下服务端的线程策略来加深用户在选择服务端异步的判断依据，同时有必要引出协程这一在服务端异步中常常会用到的“秘密武器”。\n服务端的线程策略 Dubbo支持多种NIO框架来做Remoting的协议实现，无论是Netty，Mina或者Grizzly，实现都大同小异，都是基于事件驱动的方式来做网络通道建立，数据流读取的。其中以Grizzly对于线程策略的介绍为例，通常支持以下四种。Dubbo作为一个RPC框架，默认选择的是第一种策略，原因在于业务服务是CPU密集型还是IO阻塞型，是无法断定的，第一种策略是最保险的策略。当然，对于这几种策略有了了解后，再结合业务场景做针对性的选择是最完美的。\n Worker-thread策略  最常用最普适的策略，其中IO线程将NIO事件处理委托给工作线程。\n此策略具有很高的伸缩性。我们可以根据需要更改IO和worker线程池的大小，并且不存在在特定NIO事件处理期间可能发生的，同一Selector各个Channel之间相互干扰的风险。\n缺点是有线程上下文切换的代价。\nSame-thread策略  可能是最有效的策略。与第一种不同，同一线程处理当前线程中的NIO事件，避免了昂贵的线程上下文切换。\n这个策略可以调整IO线程池大小，也是具备可伸缩性；缺点也很明显，它要求业务处理中一定不要有阻塞处理，因为它可能会阻止在同一个IO线程上发生的其他NIO事件的处理。\nDynamic策略  如前所述，前两种策略具有明显的优点和缺点。但是，如果策略可以尝试在运行时根据当前条件（负载，收集的统计信息等）巧妙地交换它们，何如？\n这种策略可能会带来很多好处，能更好地控制资源，前提是不要使条件评估逻辑过载，防止评估判断的复杂性会使这种策略效率低下。 多说一句，希望大家对这个策略多留意一下，它可能是Dubbo服务端异步方式的最佳搭配。我也多扯个淡，这几天关注了些adaptive XX或者predictive XX，这里看到dynamic真是亲切，Dubbo作为产品级生产级的微服务解决方案，是必须既要adaptive，又要predictive，还要dynamic，哈哈。\nLeader-follower策略  此策略类似于第一种，但它不是将NIO事件处理传递给worker线程，而是通过将控制传递给Selector给工作线程，并将实际NIO事件处理当前IO线程中。这种策略其实是把worker和IO线程阶段做了混淆，个人不建议。\n协程与线程 在CPU资源的管理上，OS和JVM的最小调度单位都是线程，业务应用通过扩展实现的协程包是可以具备独立的运行单位，事实上也是基于线程来做的，核心应该是遇到IO阻塞，或者锁等待时，保存上下文，然后切换到另一个协程。至于说的协程开销低，能更高效的使用CPU，这些考虑到协程库的用户态实现和上下文设计是支持的，但也建议大家结合实际业务场景做性能测试。\n在默认的Dubbo线程策略中，是有worker线程池来执行业务逻辑，但也常常会发生ThreadPool Full的问题，为了尽快释放worker线程，在业务服务的实现中会另起线程。代价是再次增加线程上下文切换，同时需要考虑链路级别的数据传送(比如tracing信息)和流控的出口控制等等。当然，如果Dubbo能够切换到Same-thread策略，再配合协程库的支持，服务端异步是一种值得推荐的使用方式。\n示例 通过示例来体验下Dubbo服务端异步接口。Demo代码请访问github之https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify。\npublic class AsyncServiceImpl implements AsyncService { @Override public String sayHello(String name) { System.out.println(\u0026#34;Main sayHello() method start.\u0026#34;); final AsyncContext asyncContext = RpcContext.startAsync(); new Thread(() -\u0026gt; { asyncContext.signalContextSwitch(); System.out.println(\u0026#34;Attachment from consumer: \u0026#34; + RpcContext.getContext().getAttachment(\u0026#34;consumer-key1\u0026#34;)); System.out.println(\u0026#34; -- Async start.\u0026#34;); try { Thread.","text":null,"weight":0},{"authors":null,"date":1572566400,"description":"本文介绍了 Dubbo 客户端异步接口的实现背景和实践 \n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo客户端异步接口的实现背景和实践","lvl1":"blog","lvl2":"/zh/blog/2019/11/01/dubbo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","lvl3":97,"lvl4":"blog","lvl5":null,"objectID":"93f3c061617a752caadadabdd30ab5fd","permalink":"/zh/blog/2019/11/01/dubbo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","publishdate":"2019-11-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/11/01/dubbo%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%92%8C%E5%AE%9E%E8%B7%B5/","summary":"铺垫 先简单介绍下一次完整的Dubbo调用所经历的线程阶段。几个信息这里罗列下\n  Biz~代表业务线程，即便是业务逻辑处理所处的线程，Biz~线程池可能是业务自己创建维护，大多数的可能是系统框架自身管理的（比如web型的业务系统跑在Tomcat容器下，Biz~线程就是Tomcat维护）；IO~代表网络数据处理线程，是IO框架（比如Netty，Grizzly）创建维护，Dubbo Remoting所默认Netty实现是NioEventloopLoopGroup；另外按照Channel与IO线程的绑定关系，也可以直接把IO~看成一个可接受事件消息的Channel。像Biz和IO这样的异步处理阶段在JDK8中有个很精确地抽象描述，叫CompletionStage。\n  大家知道，线程与线程之间做数据通信的方式是共享变量，Biz和IO两个stage之间的数据通信是Queue，具体到Dubbo实现，在客户端一侧的实现（即上图中用1所标注的步骤）中Biz是通过向EventLoop的LinkedBlockingQueue放置一个Task，而EventLoop有对应的Thread会不停的迭代Queue来执行Task中所包含的信息，具体代码可以看SingleThreadEventExecutor（顺便提下，Netty中默认是用无上限的LinkedBlockingQueue，在Biz的速率高于网络速率情况下，似乎好像有Memory Leak的风险）。\n  如上图所示，标准的一次RPC调用经过了图中所示的1,2,3,4的四次消息(事件)传递，分别是客户端业务线程到IO线程的请求发出，服务端IO线程到业务逻辑线程的__请求接受，__服务端处理完成后由业务逻辑线程到IO线程的响应写出，客户端收到结果后从IO线程到业务逻辑的响应处理。除了1与4之间一般需要维护响应和请求的映射对应关系，四次的事件处理都是完全独立的，所以一次RPC调用天然是异步的，而同步是基于异步而来。\n  客户端异步 实现背景 在Java语言（其他语言不清楚）下一次本地接口的调用可以透明地通过代理机制转为远程RPC的调用，大多数业务方也比较喜欢这种与本地接口类似的编程方式做远程服务集成，所以虽然RPC内部天然是异步的，但使用Dubbo的用户使用最广泛的还是同步，而异步反而成为小众的使用场景。同步的优点是编程模型更加符合业务方的“传统”习惯，代价是在图中的1代表的请求发出事件后需要阻塞当前的Biz~线程，一直等到4代表的响应处理后才能唤醒。在这个短则微秒级别，长则秒级的1,2,3,4处理过程中都要阻塞Biz~线程，就会消耗线程资源，增加系统资源的开销。\n所以，客户端异步的出发点是节省线程资源开销，代价是需要了解下异步的使用方式:)。在同步方式下API接口的返回类型是代表着某个业务类，而当异步情况下，响应返回与请求发出是完全独立的两个事件，需要API接口的返回类型变为上述中说的CompletionStage才是最贴合的，这是Dubbo在异步上支持的必然异步。回到最近的Dubbo发布版，是不改变接口的情况下，需要在服务创建时注册一个回调接口来处理响应返回事件。\n下面以示例来说。\n示例 事件通知的示例代码请参考：https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-notify\n事件通知允许 Consumer 端在调用之前、调用正常返回之后或调用出现异常时，触发 oninvoke、onreturn、onthrow 三个事件。\n可以通过在配置 Consumer 时，指定事件需要通知的方法，如：\n\u0026lt;bean id=\u0026#34;demoCallback\u0026#34; class=\u0026#34;com.alibaba.dubbo.samples.notify.impl.NotifyImpl\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; check=\u0026#34;false\u0026#34; interface=\u0026#34;com.alibaba.dubbo.samples.notify.api.DemoService\u0026#34; version=\u0026#34;1.0.0\u0026#34; group=\u0026#34;cn\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; onreturn=\u0026#34;demoCallback.onreturn\u0026#34; onthrow=\u0026#34;demoCallback.onthrow\u0026#34;/\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 其中，NotifyImpl 的代码如下：\npublic class NotifyImpl implements Notify{ public Map\u0026lt;Integer, String\u0026gt; ret = new HashMap\u0026lt;Integer, String\u0026gt;(); public void onreturn(String name, int id) { ret.put(id, name); System.out.println(\u0026#34;onreturn: \u0026#34; + name); } public void onthrow(Throwable ex, String name, int id) { System.","text":null,"weight":0},{"authors":null,"date":1572220800,"description":"本文整理自刘军在 Dubbo 成都 meetup 上分享的《Dubbo 在多语言和协议穿透性方向上的探索》。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 在跨语言和协议穿透性方向上的探索：支持 HTTP/2 gRPC 和 Protobuf","lvl1":"blog","lvl2":"/zh/blog/2019/10/28/dubbo-%E5%9C%A8%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%A9%BF%E9%80%8F%E6%80%A7%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%8E%A2%E7%B4%A2%E6%94%AF%E6%8C%81-http/2-grpc-%E5%92%8C-protobuf/","lvl3":1504,"lvl4":"blog","lvl5":null,"objectID":"c292df5d5e5af2d5f801b5ddefaaed5a","permalink":"/zh/blog/2019/10/28/dubbo-%E5%9C%A8%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%A9%BF%E9%80%8F%E6%80%A7%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%8E%A2%E7%B4%A2%E6%94%AF%E6%8C%81-http/2-grpc-%E5%92%8C-protobuf/","publishdate":"2019-10-28T00:00:00Z","readingtime":8,"relpermalink":"/zh/blog/2019/10/28/dubbo-%E5%9C%A8%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%A9%BF%E9%80%8F%E6%80%A7%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E6%8E%A2%E7%B4%A2%E6%94%AF%E6%8C%81-http/2-grpc-%E5%92%8C-protobuf/","summary":"本文总体上可分为基础产品简介、Dubbo 对 gRPC (HTTP/2) 和 Protobuf 的支持及示例演示三部分，在简介部分介绍了 Dubbo、HTTP/2、gRPC、Protobuf 的基本概念和特点；第二部分介绍了 Dubbo 为何要支持 gRPC (HTTP/2) 和 Protobuf，以及这种支持为 gRPC 和 Dubbo 开发带来的好处与不同；第三部分通过两个实例分别演示了 Dubbo gRPC 和 Dubbo Protobuf 的使用方式。\n基本介绍 Dubbo 协议 从协议层面展开，以下是当前 2.7 版本支持的 Dubbo 协议\n众所周知，Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。在这里我们着重讲一下 Dubbo 在协议通用性方面值得改进的地方，关于协议详细解析请参见官网博客\n Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。 Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。 扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。 在 Java 版本的代码实现上，不够精简和通用。如在链路传输中，存在一些语言绑定的内容；消息体中存在冗余内容，如 Service Name 在 Body 和 Attachments 中都存在。  HTTP/1 相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。","text":null,"weight":0},{"authors":null,"date":1571702400,"description":"本文介绍了 Dubbo 中本地存根和本地伪装的用法","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"本地存根和本地伪装","lvl1":"blog","lvl2":"/zh/blog/2019/10/22/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BC%AA%E8%A3%85/","lvl3":689,"lvl4":"blog","lvl5":null,"objectID":"5621d5dd8cbc91117f0dc33068a8a8aa","permalink":"/zh/blog/2019/10/22/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BC%AA%E8%A3%85/","publishdate":"2019-10-22T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2019/10/22/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BC%AA%E8%A3%85/","summary":"基本概念 典型的 RPC 调用客户端是依赖并且只依赖接口编程来进行远程调用的。在真正发起远程调用之前，用户往往需要做一些预处理的工作，比如提前校验参数。在拿到返回调用结果之后，用户可能需要缓存结果，或者是在调用失败的时候构造容错数据，而不是简单的抛出异常。\n这个时候，用户可以编写出类似以下的代码来处理上面提出的这些场景：\ntry { preProcess(); return service.invoke(...); } catch (Throwable e) { return mockValue; } finally { postProcess(); } 类似的，用户也可以通过面向切面编程 AOP 的高级技巧来解决上面的诉求，比如通过 Spring AOP 的方式可以通过类似下面的这段配置来完成。使用 AOP 的技巧相比上面的代码来说，避免了容错处理等与业务无关的代码对业务代码的侵入，使得业务处理主逻辑更简洁。\n\u0026lt;bean id=\u0026#34;demo-service-stub\u0026#34; class=\u0026#34;org.apache.dubbo.demo.DemoServiceStub\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;demo-service-mock\u0026#34; class=\u0026#34;org.apache.dubbo.demo.DemoServiceMock\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:aspect id=\u0026#34;stub\u0026#34; ref=\u0026#34;demo-service-stub\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;stubPointcut\u0026#34; expression=\u0026#34;execution(* org.apache.dubbo.samples.DemoService+.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:before method=\u0026#34;preProcess\u0026#34; pointcut-ref=\u0026#34;stubPointcut\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;postProcess\u0026#34; pointcut-ref=\u0026#34;stubPointcut\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;aop:aspect id=\u0026#34;mock\u0026#34; ref=\u0026#34;demo-service-mock\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;mockPointcut\u0026#34; expression=\u0026#34;execution(* org.apache.dubbo.samples.DemoService+.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:after-throwing method=\u0026#34;mock\u0026#34; pointcut-ref=\u0026#34;mockPointcut\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 为了进一步的方便用户做 Dubbo 开发，框架提出了本地存根 Stub 和本地伪装 Mock 的概念。通过约定大于配置的理念，进一步的简化了配置，使用起来更加方便，并且不依赖额外的 AOP 框架就达到了 AOP 的效果。","text":null,"weight":0},{"authors":null,"date":1571270400,"description":"URL 是 Dubbo 种一个重要的领域模型，了解它可以更加轻松的理解 Dubbo 的设计理念。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 中的 URL 统一模型","lvl1":"blog","lvl2":"/zh/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/","lvl3":455,"lvl4":"blog","lvl5":null,"objectID":"e043c065f20d0c94097c28ef4c1ae65e","permalink":"/zh/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/","publishdate":"2019-10-17T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/","summary":"定义 在不谈及 dubbo 时，我们大多数人对 URL 这个概念并不会感到陌生。统一资源定位器 (RFC1738――Uniform Resource Locators (URL)）应该是最广为人知的一个 RFC 规范，它的定义也非常简单\n 因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语 义。而这些字符串则被称为：“统一资源定位器”（URL）\n 一个标准的 URL 格式至多可以包含如下的几个部分\nprotocol://username:password@host:port/path?key=value\u0026amp;key=value 一些典型 URL\nhttp://www.facebook.com/friends?param1=value1\u0026amp;amp;param2=value2 https://username:password@10.20.130.230:8080/list?version=1.0.0 ftp://username:password@192.168.1.7:21/1/read.txt 当然，也有一些不太符合常规的 URL，也被归类到了 URL 之中\n192.168.1.3:20880 url protocol = null, url host = 192.168.1.3, port = 20880, url path = null file:///home/user1/router.js?type=script url protocol = file, url host = null, url path = home/user1/router.js file://home/user1/router.js?type=script\u0026lt;br\u0026gt; url protocol = file, url host = home, url path = user1/router.","text":null,"weight":0},{"authors":null,"date":1569888000,"description":"研究 Dubbo 网卡地址注册时的一点思考","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"研究 Dubbo 网卡地址注册时的一点思考","lvl1":"blog","lvl2":"/zh/blog/2019/10/01/%E7%A0%94%E7%A9%B6-dubbo-%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%B3%A8%E5%86%8C%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","lvl3":1538,"lvl4":"blog","lvl5":null,"objectID":"c98542a138d20c77e214718201184588","permalink":"/zh/blog/2019/10/01/%E7%A0%94%E7%A9%B6-dubbo-%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%B3%A8%E5%86%8C%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","publishdate":"2019-10-01T00:00:00Z","readingtime":8,"relpermalink":"/zh/blog/2019/10/01/%E7%A0%94%E7%A9%B6-dubbo-%E7%BD%91%E5%8D%A1%E5%9C%B0%E5%9D%80%E6%B3%A8%E5%86%8C%E6%97%B6%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","summary":"1 如何选择合适的网卡地址 可能相当一部分人还不知道我这篇文章到底要讲什么，我说个场景，大家应该就明晰了。在分布式服务调用过程中，以 Dubbo 为例，服务提供者往往需要将自身的 IP 地址上报给注册中心，供消费者去发现。在大多数情况下 Dubbo 都可以正常工作，但如果你留意过 Dubbo 的 github issue，其实有不少人反馈：Dubbo Provider 注册了错误的 IP。如果你能立刻联想到：多网卡、内外网地址共存、VPN、虚拟网卡等关键词，那我建议你一定要继续将本文看下去，因为我也想到了这些，它们都是本文所要探讨的东西！那么“如何选择合适的网卡地址”呢，Dubbo 现有的逻辑到底算不算完备？我们不急着回答它，而是带着这些问题一起进行研究，相信到文末，其中答案，各位看官自有评说。\n2 Dubbo 是怎么做的 Dubbo 获取网卡地址的逻辑在各个版本中也是千回百转，走过弯路，也做过优化，我们用最新的 2.7.2-SNAPSHOT 版本来介绍，在看以下源码时，大家可以怀着质疑的心态去阅读，在 dubbo github 的 master 分支可以获取源码。获取 localhost 的逻辑位于 org.apache.dubbo.common.utils.NetUtils#getLocalAddress0() 之中\nprivate static InetAddress getLocalAddress0() { InetAddress localAddress = null; // 首先尝试获取 /etc/hosts 中 hostname 对应的 IP  localAddress = InetAddress.getLocalHost(); Optional\u0026lt;InetAddress\u0026gt; addressOp = toValidAddress(localAddress); if (addressOp.isPresent()) { return addressOp.get(); } // 没有找到适合注册的 IP，则开始轮询网卡  Enumeration\u0026lt;NetworkInterface\u0026gt; interfaces = NetworkInterface.","text":null,"weight":0},{"authors":null,"date":1566777600,"description":"可以通过泛化调用，在控制台上调用真实的服务提供者 \n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo Admin服务测试功能","lvl1":"blog","lvl2":"/zh/blog/2019/08/26/service-test/","lvl3":253,"lvl4":"blog","lvl5":null,"objectID":"3dc9a0a4ebc42652800d8ca77a5ef008","permalink":"/zh/blog/2019/08/26/service-test/","publishdate":"2019-08-26T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/08/26/service-test/","summary":"基于Dubbo2.7的元数据，Dubbo Admin实现了服务测试功能，可以通过泛化调用，在控制台上调用真实的服务提供者\n使用方式  部署服务提供者： 可以在这里下载demo，此工程基于spring boot，方便在IDE或者命令行启动，对于服务测试来说，只需要启动dubbo-basic-provider即可。 服务查询： 完成服务端部署后，可以到Dubbo Admin的服务测试页面上查询对应的服务: 这里的信息和元数据类似，包含方法名，参数类型和返回值信息，点击右边的标签就可以进入服务测试页面 服务测试： 服务测试页面包含了两个json编辑器，参数类型的信息都是以json格式保存，这里需要填入对应的参数值(本例中数类型时String)，填写完成后点击执行即可对服务端发起调用，调用结果展示在右边的编辑器中，如果调用失败，会显示详细的失败原因，下面来看一下调用失败的例子：\n本例中，先关掉Dubbo服务提供者的进程，再执行服务测试，可以看到返回的结果是找不到服务提供者的异常。和普通调用一样，业务和框架的异常都会返回在结果中，方便业务排查。 复合类型参数\n考虑UserService中的以下方法和类型：  //org.apache.dubbo.demo.api.UserService Result getUser(String name, UserInfoDO userInfoDO); public class UserInfoDO { private int id; private LocationDO locationDO; private DepartmentDO departmentDO; @Override public String toString() { return \u0026#34;UserInfoDO{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, locationDO=\u0026#34; + locationDO.toString() + \u0026#34;, departmentDO=\u0026#34; + departmentDO.toString() + \u0026#39;}\u0026#39;; } } public class DepartmentDO { private String departName; private LocationDO departLocation; @Override public String toString() { return \u0026#34;DepartmentDO{\u0026#34; + \u0026#34;departName=\u0026#39;\u0026#34; + departName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, departLocation=\u0026#34; + departLocation.","text":null,"weight":0},{"authors":null,"date":1566777600,"description":"This article introduces how to make service test with Dubbo.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Admin service test","lvl1":"blog","lvl2":"/blog/2019/08/26/service-test/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"3dc9a0a4ebc42652800d8ca77a5ef008","permalink":"/blog/2019/08/26/service-test/","publishdate":"2019-08-26T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/08/26/service-test/","summary":"","text":null,"weight":0},{"authors":null,"date":1565481600,"description":"This article introduces how to use Apache Skywalking to track Dubbo applications.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Tracing Dubbo service with Apache Skywalking","lvl1":"blog","lvl2":"/blog/2019/08/11/tracing-dubbo-service-with-apache-skywalking/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"6814ca1099453fba5e7ef1159e65eac3","permalink":"/blog/2019/08/11/tracing-dubbo-service-with-apache-skywalking/","publishdate":"2019-08-11T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/08/11/tracing-dubbo-service-with-apache-skywalking/","summary":"","text":null,"weight":0},{"authors":null,"date":1565481600,"description":"本文介绍如何使用 Apache Skywalking 对 Dubbo 应用做分布式链路追踪。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用Apache Skywalking (Incubator) 做分布式跟踪","lvl1":"blog","lvl2":"/zh/blog/2019/08/11/%E4%BD%BF%E7%94%A8apache-skywalking-incubator-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","lvl3":168,"lvl4":"blog","lvl5":null,"objectID":"6814ca1099453fba5e7ef1159e65eac3","permalink":"/zh/blog/2019/08/11/%E4%BD%BF%E7%94%A8apache-skywalking-incubator-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","publishdate":"2019-08-11T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/08/11/%E4%BD%BF%E7%94%A8apache-skywalking-incubator-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","summary":"Apache Skywalking(Incubator)简介 Apache Skywalking(Incubator) 专门为微服务架构和云原生架构系统而设计并且支持分布式链路追踪的APM系统。Apache Skywalking(Incubator)通过加载探针的方式收集应用调用链路信息，并对采集的调用链路信息进行分析，生成应用间关系和服务间关系以及服务指标。Apache Skywalking (Incubating)目前支持多种语言，其中包括Java，.Net Core，Node.js和Go语言。\n目前Skywalking已经支持从6个可视化维度剖析分布式系统的运行情况。总览视图是应用和组件的全局视图，其中包括组件和应用数量，应用的告警波动，慢服务列表以及应用吞吐量；拓扑图从应用依赖关系出发，展现整个应用的拓扑关系；应用视图则是从单个应用的角度，展现应用的上下游关系，TopN的服务和服务器，JVM的相关信息以及对应的主机信息。服务视图关注单个服务入口的运行情况以及此服务的上下游依赖关系，依赖度，帮助用户针对单个服务的优化和监控；调用链展现了调用的单次请求经过的所有埋点以及每个埋点的执行时长；告警视图根据配置阈值针对应用、服务器、服务进行实时告警。\nDubbo与Apache Skywalking(Incubator) 编写Dubbo示例程序 Dubbo实例程序已上传到Github仓库中。方便大家下载使用。\nAPI工程 服务接口：\npackage org.apache.skywalking.demo.interfaces; public interface HelloService { String sayHello(String name); } Dubbo服务提供工程 package org.apache.skywalking.demo.provider; @Service(version = \u0026#34;${demo.service.version}\u0026#34;, application = \u0026#34;${dubbo.application.id}\u0026#34;, protocol = \u0026#34;${dubbo.protocol.id}\u0026#34;, registry = \u0026#34;${dubbo.registry.id}\u0026#34;, timeout = 60000) public class HelloServiceImpl implements HelloService { public String sayHello(String name) { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(1)); return \u0026#34;Hello, \u0026#34; + name; } } Consumer工程 package org.apache.skywalking.demo.consumer; @RestController public class ConsumerController { private static int COUNT = 0; @Reference(version = \u0026#34;${demo.","text":null,"weight":0},{"authors":null,"date":1565481600,"description":"当一个应用既是一个服务的提供者，同时也是这个服务的消费者的时候，可以直接对本机提供的服务发起本地调用\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"本地调用","lvl1":"blog","lvl2":"/zh/blog/2019/08/11/%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8/","lvl3":227,"lvl4":"blog","lvl5":null,"objectID":"e3b9ca455ab832b680156607a7194a91","permalink":"/zh/blog/2019/08/11/%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8/","publishdate":"2019-08-11T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/08/11/%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8/","summary":"本地调用介绍 当一个应用既是一个服务的提供者，同时也是这个服务的消费者的时候，可以直接对本机提供的服务发起本地调用。从 2.2.0 版本开始，Dubbo 默认在本地以 injvm 的方式暴露服务，这样的话，在同一个进程里对这个服务的调用会优先走本地调用。\n与本地对象上方法调用不同的是，Dubbo 本地调用会经过 Filter 链，其中包括了 Consumer 端的 Filter 链以及 Provider 端的 Filter 链。通过这样的机制，本地消费者和其他消费者都是统一对待，统一监控，服务统一进行治理。\n同时，相比于远程调用来说，Dubbo 本地调用性能较优，省去了请求、响应的编解码及网络传输的过程。\n要使用 Dubbo 本地调用不需做特殊配置，按正常 Dubbo 服务暴露服务即可。任一服务在暴露远程服务的同时，也会同时以 injvm 的协议暴露本地服务。injvm 是一个伪协议，不会像其他协议那样对外开启端口，只用于本地调用的目的。\n以下面的 XML 配置为例：\n\u0026lt;dubbo:registry address=\u0026#34;zookeeper://127.0.0.1:2181\u0026#34;/\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20800\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;demoServiceTarget\u0026#34; class=\u0026#34;org.apache.dubbo.samples.local.impl.DemoServiceImpl\u0026#34;/\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.samples.local.api.DemoService\u0026#34; ref=\u0026#34;demoServiceTarget\u0026#34;/\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; interface=\u0026#34;org.apache.dubbo.samples.local.api.DemoService\u0026#34;/\u0026gt; 这里同时配置了同一服务 DemoService 的提供者以及消费者。在这种情况下，该应用中的 DemoService 的消费方会优先使用 injvm 协议进行本地调用。上述的例子可以在 dubbo-samples 工程中找到源码：https://github.com/apache/dubbo-samples/blob/master/dubbo-samples-local\n细粒度控制本地调用 本地调用是可以显示关闭的，通过这种方式，服务提供者可以做到对远端服务消费者和本地消费者一视同仁。具体做法是通过 scope=\u0026ldquo;remote\u0026rdquo; 来关闭 injvm 协议的暴露，这样，即使是本地调用者，也需要从注册中心上获取服务地址列表，然后才能发起调用，而这个时候的调用过程，与远端的服务消费者的过程是一致的。\n\u0026lt;bean id=\u0026#34;target\u0026#34; class=\u0026#34;org.apache.dubbo.samples.local.impl.DemoServiceImpl\u0026#34;/\u0026gt; \u0026lt;!-- 服务提供者指定 scope=\u0026#34;remote\u0026#34; --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.samples.local.api.DemoService\u0026#34; ref=\u0026#34;target\u0026#34; scope=\u0026#34;remote\u0026#34;/\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; interface=\u0026#34;org.","text":null,"weight":0},{"authors":null,"date":1564099200,"description":"本文介绍了如何在 Dubbo 中发布 RESTful 服务","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1900,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在 Dubbo 中使用 REST","lvl1":"blog","lvl2":"/zh/blog/2019/07/26/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-rest/","lvl3":1843,"lvl4":"blog","lvl5":null,"objectID":"65377268902ab8706eafbc665963550d","permalink":"/zh/blog/2019/07/26/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-rest/","publishdate":"2019-07-26T00:00:00Z","readingtime":9,"relpermalink":"/zh/blog/2019/07/26/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-rest/","summary":"什么是 REST REST 是 Roy Thomas Fielding 1 在 2000 年他的博士论文 2 “架构风格以及基于网络的软件架构设计” 中提出来的一个概念。REST 是 REpresentational State Transfer 的缩写，翻译过来就是 “表现层状态转化”。REST 就是 Roy 在这篇论文中提出的面向互联网的软件所应当具备的架构风格。\n按照 REpresentational State Transfer 的字面意思，可以把应用看成是一个虚拟的状态机，软件提供的不是服务而是一系列的资源，对这些资源的访问通过统一的操作来访问，而返回的结果代表了资源状态的一次跃迁。REST 是一种架构风格，如果一个软件架构符合 REST 风格，就可以称之为 RESTful 架构。这个架构应当具备以下一些设计上的约束：资源具有唯一标示、资源之间有关联关系、使用标准的方式来访问、资源有多种表现形式、无状态交互。\n举例来说，一个简单的静态 HTML 页面的网站就很好的符合了 RESTful 架构风格。访问 http://acme.com/accounts 返回一个包含所有账号的页面，选取其中一个链接 http://acme.com/accounts/1 又会返回包含用户 1 的详细信息。爬虫软件在这种场景下工作的很好，当知道了某个网站的首页地址后，可以自举发现这个网站上所有关联的网页。更重要的是，这种访问形式不依赖网站提供的任何客户端，而是仅仅通过 HTTP 标准的访问方式完成的。可以说，HTML 这种超媒体文档的组织形式就是资源的表现层状态迁移的一种形式。\n对于一个提供服务的动态网站来说，可以按照类似的思路将其 RESTful 化：\n  GET http://acme.com/accounts 返回所有账号信息\n  POST http://acme.com/accounts 创建一个新的账号\n  GET http://acme.com/accounts/1 返回账号 1 的信息\n  DELETE http://acme.","text":null,"weight":0},{"authors":null,"date":1561161600,"description":"在这篇文章中，我们将探索如何利用 Dubbo 对多协议、多服务发现模型的支持，来实现异构微服务体系间的互联互通\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用 Dubbo 连接异构微服务体系","lvl1":"blog","lvl2":"/zh/blog/2019/06/22/%E4%BD%BF%E7%94%A8-dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/","lvl3":540,"lvl4":"blog","lvl5":null,"objectID":"bbdac92a6e594eae8d3d1cb764d3b38f","permalink":"/zh/blog/2019/06/22/%E4%BD%BF%E7%94%A8-dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/","publishdate":"2019-06-22T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2019/06/22/%E4%BD%BF%E7%94%A8-dubbo-%E8%BF%9E%E6%8E%A5%E5%BC%82%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%93%E7%B3%BB/","summary":"从编程开发的角度来说，Dubbo 首先是一款 RPC 服务框架，它最大的优势在于提供了面向接口代理的服务编程模型，对开发者屏蔽了底层的远程通信细节。同时 Dubbo 也是一款服务治理框架，它为分布式部署的微服务提供了服务发现、流量调度等服务治理解决方案。\n在这篇文章中，我们将以以上基础能力为背景，尝试突破 Dubbo 体系自身，探索如何利用 Dubbo 对多协议、多服务发现模型的支持，来实现异构微服务体系间的互联互通。在实际业务场景中，这可以用来解决异构技术体系共存场景下的通信问题，帮助公司实现在异构技术体系间作平滑迁移，解决大规模跨区域、多集群部署场景的地址发现及流量调度等问题。\n面向接口代理的透明服务开发框架 我们还是从 Dubbo 是一个微服务开发框架 这个大家熟知的概念开始。就像 Spring 是开发 Java 应用的基础框架一样，我们经常会选用 Dubbo 作为开发微服务业的基础框架。 Dubbo 框架的最大优势我认为就在其面向接口的编程模型，使得开发远程服务调用就像开发本地服务一样（以 Java 语言为例）：\n 服务定义  public interface GreetingsService { String sayHi(String name); } 消费方调用服务  // 和调用本地服务一样，完全透明。 @Reference private GreetingService greetingService; public void doSayHello(String name) { greetingService.sayHi(\u0026#34;Hello world!\u0026#34;); } 下图是 Dubbo 的基本工作原理图，服务提供者与服务消费者之间通过注册中心协调地址，通过约定的协议实现数据交换。\n同构/异构微服务体系面临的问题 关于 Dubbo 协议本身及其服务治理相关功能细节并不是本文的重点，我们今天将从一个更高的层次，来看看公司内部构建微服务体系所面的挑战，以及 Dubbo 能为架构选型和迁移等提供哪些解决思路。\n一个公司内部的微服务可能都是基于某一个相同的服务框架开发的，比如说 Dubbo，对于这样的架构，我们称之为是同构的微服务体系；而有些公司的微服务可能是使用多个不同的服务框架所建设，我们称之为异构的微服务体系，多个不同技术栈微服务体系的共存在大型组织内还是非常普遍的，造成这种局面可能有很多原因。比如，可能是遗留系统带来的，也可能是公司正在做技术栈迁移，或者就是不同业务部门为了满足各自特殊需求而做的独立选型（这也意味着异构微服务体系的长期共存）。\n1. 异构微服务体系共存\n我们很容易想到的一个挑战是：**不同的体系间通常是使用不同的 RPC 通信协议、部署独立的注册中心集群，面对这种多协议、多注册中心集群的场景，要如何实现相互之间透明的地址发现和透明的 RPC 调用？**如果我们什么都不做，那么每个微服务体系就只能感知到自己体系内的服务状态，流量也在各自的体系内封闭。而要做到从体系 A 平滑的迁移到体系 B，或者想长期的保持公司内部多个体系的共存，则解决不同体系间的互联互通，实现流量的透明调度将是非常重要的环节。","text":null,"weight":0},{"authors":null,"date":1556755200,"description":"This article introduces the principles and details of Dubbo's SPI.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo extensible mechanism source code analysis - part 2","lvl1":"blog","lvl2":"/blog/2019/05/02/dubbo-extensible-mechanism-source-code-analysis-part-2/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"d171ea21934b0b9dd7cf3feee4f097a8","permalink":"/blog/2019/05/02/dubbo-extensible-mechanism-source-code-analysis-part-2/","publishdate":"2019-05-02T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/05/02/dubbo-extensible-mechanism-source-code-analysis-part-2/","summary":"","text":null,"weight":0},{"authors":null,"date":1556755200,"description":"本文介绍了SPI扩展机制的实现原理与细节。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo可扩展机制源码解析","lvl1":"blog","lvl2":"/zh/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","lvl3":944,"lvl4":"blog","lvl5":null,"objectID":"d171ea21934b0b9dd7cf3feee4f097a8","permalink":"/zh/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","publishdate":"2019-05-02T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/2019/05/02/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","summary":"在Dubbo可扩展机制实战中，我们了解了Dubbo扩展机制的一些概念，初探了Dubbo中LoadBalance的实现，并自己实现了一个LoadBalance。是不是觉得Dubbo的扩展机制很不错呀，接下来，我们就深入Dubbo的源码，一睹庐山真面目。\nExtensionLoader ExtensionLoader 是最核心的类，负责扩展点的加载和生命周期管理。我们就以这个类开始吧。 ExtensionLoader 的方法比较多，比较常用的方法有:\n public static \u0026lt;T\u0026gt; ExtensionLoader\u0026lt;T\u0026gt; getExtensionLoader(Class\u0026lt;T\u0026gt; type) public T getExtension(String name) public T getAdaptiveExtension()  比较常见的用法有:\n LoadBalance lb = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(loadbalanceName) RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()  说明：在接下来展示的源码中，我会将无关的代码(比如日志，异常捕获等)去掉，方便大家阅读和理解。\n getExtensionLoader方法 这是一个静态工厂方法，入参是一个可扩展的接口，返回一个该接口的ExtensionLoader实体类。通过这个实体类，可以根据name获得具体的扩展，也可以获得一个自适应扩展。  public static \u0026lt;T\u0026gt; ExtensionLoader\u0026lt;T\u0026gt; getExtensionLoader(Class\u0026lt;T\u0026gt; type) { // 扩展点必须是接口  if (!type.isInterface()) { throw new IllegalArgumentException(\u0026#34;Extension type(\u0026#34; + type + \u0026#34;) is not interface!\u0026#34;); } // 必须要有@SPI注解  if (!withExtensionAnnotation(type)) { throw new IllegalArgumentException(\u0026#34;Extension type without @SPI Annotation!","text":null,"weight":0},{"authors":null,"date":1556668800,"description":"本文以一般的一致性Hash实现作为引子，详细剖析了Dubbo一致性Hash负载均衡算法的实现\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 一致性Hash负载均衡实现剖析","lvl1":"blog","lvl2":"/zh/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/","lvl3":410,"lvl4":"blog","lvl5":null,"objectID":"5345dfd026ec756fd0ab979096078381","permalink":"/zh/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/","publishdate":"2019-05-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/05/01/dubbo-%E4%B8%80%E8%87%B4%E6%80%A7hash%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E5%89%96%E6%9E%90/","summary":"需要强调的是，Dubbo的Hash映射模型与大部分网上资料描述的环形队列Hash映射模型是存在一些区别的。于我而言，环形队列Hash映射模型，不足以让我对一致性Hash有足够彻底的了解。直到看懂了Dubbo的一致性Hash的实现，才觉得豁然开朗。\n一、环形队列Hash映射模型 这种方案，其基础还是基于取模运算。对2^32取模，那么，Hash值的区间为[0, 2^32-1]。接下来要做的，就包括两部分：\na、映射服务 将服务地址（ip+端口）按照一定规则构造出特定的识别码（如md5码），再用识别码对2^32取模，确定服务在Hash值区间对应的位置。假设有Node1、Node2、Node3三个服务，其映射关系如下：\nb、映射请求、定位服务 在发起请求时，我们往往会带上参数，而这些参数，就可以被我们用来确定具体调用哪一个服务。假设有请求R1、R2、R3，对它们的参数也经过计算特定识别码、取余的一系列运算之后，有如下映射关系：\n从图中，我们可以看到，R1请求映射在0-Node1中间，R2请求映射在Node1-Node2中间，R3请求映射在Node2-Node3中间。我们取服务Hash值大于请求Hash值的第一个服务作为实际的调用服务。也就是说，R1请求将调用Node1服务，R2请求将调用Node2服务，R3请求将调用Node3服务。\nc、新增服务节点 假设新增服务Node4，映射在Node3之前，恰巧破坏了原来的一个映射关系：\n这样，请求R3将会实际调用服务Node4，但请求R1、R2不受影响。\nd、删除服务节点 假设服务Node2宕机，那么R2请求将会映射到Node3：\n原本的R1、R3请求不受影响。\n 可以看出，当新增、删除服务时，受影响的请求是有限的。不至于像简单取模映射一般，服务发生变化时，需要调整全局的映射关系。\n e、平衡性与虚拟节点 在我们上面的假设中，我们假设Node1、Node2、Node3三个服务在经过Hash映射后所分布的位置恰巧把环切成了均等的三分，请求的分布也基本是平衡的。但是实际上计算服务Hash值的时候，是很难这么巧的。也许一不小心就映射成了这个样子：\n这样，就会导致大部分请求都会被映射到Node1上。因此，引出了虚拟节点。\n所谓虚拟节点，就是除了对服务本身地址进行Hash映射外，还通过在它地址上做些处理（比如Dubbo中，在ip+port的字符串后加上计数符1、2、3\u0026hellip;\u0026hellip;，分别代表虚拟节点1、2、3），以达到同一服务映射多个节点的目的。通过引入虚拟节点，我们可以把上图中映射给Node1的请求进一步拆分：\n如上图所示，若有请求落在Node3-Node1\u0026rsquo;区间，该请求应该是调用Node1\u0026rsquo;服务，但是因为Node1\u0026rsquo;是Node1的虚拟节点，所以实际调用的是Node1服务。通过引入虚拟节点，请求的分布就会比较平衡了。\n二、Dubbo一致性Hash的使用与负载均衡策略的引入阶段 a、如何使用一致性Hash作为Dubbo的负载均衡策略？ dubbo:service、dubbo:reference、dubbo:provider、dubbo:consumer、dubbo:method这几个配置项都可以配置Dubbo的负载均衡策略，其中一致性Hash的属性值是：consistenthash。\n以dubbo:reference为例：\nXML配置：\n \u0026lt;dubbo:reference loadbalance=\u0026ldquo;consistenthash\u0026rdquo; /\u0026gt;\n Properties配置：\n dubbo.reference.loadbalance=consistenthash\n 注解：\n @Reference(loadbalance = \u0026ldquo;consistenthash\u0026rdquo;)\n b、Dubbo负载均衡策略的引入阶段 Dubbo实现的是客户端负载均衡。关于服务接口代理类的实现，这里不做详细描述，可以参考官网：\n 服务引入：http://dubbo.apache.org/zh-cn/docs/source_code_guide/refer-service.html。\n 在接口代理类生成、并且装配好后，服务的调用基本是这样一个流程：proxy -\u0026gt; MockClusterInvoker -\u0026gt; 集群策略（如：FailoverClusterInvoker） -\u0026gt; 初始化负载均衡策略 -\u0026gt; 根据选定的负载均衡策略确定Invoker。\n负载均衡策略的初始化是在AbstractClusterInvoker中的initLoadBalance方法中初始化的：\nprotected LoadBalance initLoadBalance(List\u0026lt;Invoker\u0026lt;T\u0026gt;\u0026gt; invokers, Invocation invocation) { if (CollectionUtils.isNotEmpty(invokers)) { return ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl() .","text":null,"weight":0},{"authors":null,"date":1556150400,"description":"description: This article introduces Dubbo's SPI mechanism.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo extensible mechanism source code analysis - part 1","lvl1":"blog","lvl2":"/blog/2019/04/25/dubbo-extensible-mechanism-source-code-analysis-part-1/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"9be5a813ad39e1fa40b619701a7be99d","permalink":"/blog/2019/04/25/dubbo-extensible-mechanism-source-code-analysis-part-1/","publishdate":"2019-04-25T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/04/25/dubbo-extensible-mechanism-source-code-analysis-part-1/","summary":"","text":null,"weight":0},{"authors":null,"date":1556150400,"description":"description: 本文介绍了Dubbo框架的核心，SPI扩展机制。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo可扩展机制实战","lvl1":"blog","lvl2":"/zh/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/","lvl3":303,"lvl4":"blog","lvl5":null,"objectID":"9be5a813ad39e1fa40b619701a7be99d","permalink":"/zh/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/","publishdate":"2019-04-25T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/04/25/dubbo%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98/","summary":"1. Dubbo的扩展机制 在Dubbo的官网上，Dubbo描述自己是一个高性能的RPC框架。今天我想聊聊Dubbo的另一个很棒的特性, 就是它的可扩展性。 如同罗马不是一天建成的，任何系统都一定是从小系统不断发展成为大系统的，想要从一开始就把系统设计的足够完善是不可能的，相反的，我们应该关注当下的需求，然后再不断地对系统进行迭代。在代码层面，要求我们适当的对关注点进行抽象和隔离，在软件不断添加功能和特性时，依然能保持良好的结构和可维护性，同时允许第三方开发者对其功能进行扩展。在某些时候，软件设计者对扩展性的追求甚至超过了性能。\n在谈到软件设计时，可扩展性一直被谈起，那到底什么才是可扩展性，什么样的框架才算有良好的可扩展性呢？它必须要做到以下两点:\n 作为框架的维护者，在添加一个新功能时，只需要添加一些新代码，而不用大量的修改现有的代码，即符合开闭原则。 作为框架的使用者，在添加一个新功能时，不需要去修改框架的源码，在自己的工程中添加代码即可。  Dubbo很好的做到了上面两点。这要得益于Dubbo的微内核+插件的机制。接下来的章节中我们会慢慢揭开Dubbo扩展机制的神秘面纱。\n2. 可扩展的几种解决方案 通常可扩展的实现有下面几种:\n Factory模式 IoC容器 OSGI容器  Dubbo作为一个框架，不希望强依赖其他的IoC容器，比如Spring，Guice。OSGI也是一个很重的实现，不适合Dubbo。最终Dubbo的实现参考了Java原生的SPI机制，但对其进行了一些扩展，以满足Dubbo的需求。\n3. Java SPI机制 既然Dubbo的扩展机制是基于Java原生的SPI机制，那么我们就先来了解下Java SPI吧。了解了Java的SPI，也就是对Dubbo的扩展机制有一个基本的了解。如果对Java SPI比较了解的同学，可以跳过。\nJava SPI(Service Provider Interface)是JDK内置的一种动态加载扩展点的实现。在ClassPath的META-INF/services目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用java.util.ServiceLoader来加载具体的实现。 让我们通过一个简单的例子，来看看Java SPI是如何工作的。\n 定义一个接口IRepository用于实现数据储存  public interface IRepository { void save(String data); } 提供IRepository的实现 IRepository有两个实现。MysqlRepository和MongoRepository。  public class MysqlRepository implements IRepository { public void save(String data) { System.out.println(\u0026#34;Save \u0026#34; + data + \u0026#34; to Mysql\u0026#34;); } } public class MongoRepository implements IRepository { public void save(String data) { System.","text":null,"weight":0},{"authors":null,"date":1550620800,"description":"Implementation background and practice of Dubbo client asynchronous interface\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Implementation background and practice of Dubbo client asynchronous interface","lvl1":"blog","lvl2":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-client-asynchronous-interface/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"93f3c061617a752caadadabdd30ab5fd","permalink":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-client-asynchronous-interface/","publishdate":"2019-02-20T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-client-asynchronous-interface/","summary":"","text":null,"weight":0},{"authors":null,"date":1550620800,"description":"Implementation background and practice of Dubbo server asynchronous interface\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Implementation background and practice of Dubbo server asynchronous interface","lvl1":"blog","lvl2":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-server-asynchronous-interface/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"c5636591d950af661f4acc9d447a43f0","permalink":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-server-asynchronous-interface/","publishdate":"2019-02-20T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/02/20/implementation-background-and-practice-of-dubbo-server-asynchronous-interface/","summary":"","text":null,"weight":0},{"authors":null,"date":1549152000,"description":"本文介绍了通过提前if判断帮助CPU分支预测的优化技巧\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"提前if判断帮助CPU分支预测","lvl1":"blog","lvl2":"/zh/blog/2019/02/03/%E6%8F%90%E5%89%8Dif%E5%88%A4%E6%96%AD%E5%B8%AE%E5%8A%A9cpu%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/","lvl3":296,"lvl4":"blog","lvl5":null,"objectID":"69734cc9b09972e14abcca5261d44d17","permalink":"/zh/blog/2019/02/03/%E6%8F%90%E5%89%8Dif%E5%88%A4%E6%96%AD%E5%B8%AE%E5%8A%A9cpu%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/","publishdate":"2019-02-03T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/02/03/%E6%8F%90%E5%89%8Dif%E5%88%A4%E6%96%AD%E5%B8%AE%E5%8A%A9cpu%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/","summary":"分支预测 在stackoverflow上有一个非常有名的问题：为什么处理有序数组要比非有序数组快？，可见分支预测对代码运行效率有非常大的影响。\n现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。\n要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。\n那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？\nDubbo里ChannelEventRunnable的switch判断 在ChannelEventRunnable里有一个switch来判断channel state，然后做对应的逻辑：查看\n一个channel建立起来之后，超过99.9%情况它的state都是ChannelState.RECEIVED，那么可以考虑把这个判断提前。\nbenchmark验证 下面通过jmh来验证下：\npublic class TestBenchMarks { public enum ChannelState { CONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT } @State(Scope.Benchmark) public static class ExecutionPlan { @Param({ \u0026#34;1000000\u0026#34; }) public int size; public ChannelState[] states = null; @Setup public void setUp() { ChannelState[] values = ChannelState.values(); states = new ChannelState[size]; Random random = new Random(new Date().getTime()); for (int i = 0; i \u0026lt; size; i++) { int nextInt = random.","text":null,"weight":0},{"authors":null,"date":1549065600,"description":"使用Alibaba开源的应用诊断利器Arthas来排查Dubbo应用的问题。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"当Dubbo遇上Arthas：排查问题的实践","lvl1":"blog","lvl2":"/zh/blog/2019/02/02/%E5%BD%93dubbo%E9%81%87%E4%B8%8Aarthas%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B7%B5/","lvl3":683,"lvl4":"blog","lvl5":null,"objectID":"e809282d41c6c3d963ac6f9d7e3c8584","permalink":"/zh/blog/2019/02/02/%E5%BD%93dubbo%E9%81%87%E4%B8%8Aarthas%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B7%B5/","publishdate":"2019-02-02T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2019/02/02/%E5%BD%93dubbo%E9%81%87%E4%B8%8Aarthas%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E8%B7%B5/","summary":"Apache Dubbo是Alibaba开源的高性能RPC框架，在国内有非常多的用户。\n Github: https://github.com/apache/dubbo 文档：http://dubbo.apache.org/zh-cn/  Arthas是Alibaba开源的应用诊断利器，9月份开源以来，Github Star数三个月超过6000。\n Github: https://github.com/alibaba/arthas 文档：https://alibaba.github.io/arthas/ Arthas开源交流QQ群: 916328269 Arthas开源交流钉钉群: 21965291  当Dubbo遇上Arthas，会碰撞出什么样的火花呢？下面来分享Arthas排查Dubbo问题的一些经验。\ndubbo-arthas-demo 下面的排查分享基于这个dubbo-arthas-demo，非常简单的一个应用，浏览器请求从Spring MVC到Dubbo Client，再发送到Dubbo Server。\nDemo里有两个spring boot应用，可以先启动server-demo，再启动client-demo。\n https://github.com/hengyunabc/dubbo-arthas-demo  /user/{id} -\u0026gt; UserService -\u0026gt; UserServiceImpl Browser Dubbo Client Dubbo Server Client端：\n@RestController public class UserController { @Reference(version = \u0026#34;1.0.0\u0026#34;) private UserService userService; @GetMapping(\u0026#34;/user/{id}\u0026#34;) public User findUserById(@PathVariable Integer id) { return userService.findUser(id); } Server端：\n@Service(version = \u0026#34;1.0.0\u0026#34;) public class UserServiceImpl implements UserService { @Override public User findUser(int id) { if (id \u0026lt; 1) { throw new IllegalArgumentException(\u0026#34;user id \u0026lt; 1, id: \u0026#34; + id); } for (User user : users) { if (user.","text":null,"weight":0},{"authors":null,"date":1548460800,"description":"本文记录了一个小白成长为Dubbo committer的过程。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"遇见Dubbo","lvl1":"blog","lvl2":"/zh/blog/2019/01/26/%E9%81%87%E8%A7%81dubbo/","lvl3":44,"lvl4":"blog","lvl5":null,"objectID":"3688f29e492cb48cb784e1f4f58b83ae","permalink":"/zh/blog/2019/01/26/%E9%81%87%E8%A7%81dubbo/","publishdate":"2019-01-26T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/01/26/%E9%81%87%E8%A7%81dubbo/","summary":"我是一个有Dubbo情节的程序员。\nDubbo以不同方式，陪伴了我时间不长的整个代码生涯。不久前，通过社区投票，我被选举为Committer。当时我在朋友圈发了一句话，也是贯穿我从开始使用Dubbo、研究Dubbo、贡献Dubbo到最后成为Committer的全过程，一直为我提供内心无与伦比愉悦的源泉：成长这种事，能看见脚印特别幸福。\n今天来个回忆杀，把我和Dubbo的那些事拿出来说说。\n小白 我知道Dubbo，是在我大三翘课出去实习的时候，那个时候是无知的，我眼里最牛的人就是能熟练使用各种配置，精通SSH框架的人。就是在那种情况下，我外出实习，遇到了一群影响我至今的人。当时也是机缘巧合，我们进行了两个非常小的模块的服务化改造。那时的团队除了我们老大，全是一群新兵蛋子，老大指哪我们打哪。老大说，就用Dubbo吧，从那时候开始，我才知道，哦！原来还有一种东西叫做RPC，还有个阿里巴巴的RPC框架叫Dubbo。\n苦于当时非常有限的水平和高强度的工作，我和Dubbo的缘分也就停留在一面之缘的程度——要说认识谈不上，说不认识也牵强。\nContributor 我在二维火任职的一年算是我Dubbo生涯里承上启下的一年。二维火当时自己维护了一个Dubbo的分支，有一群对Dubbo非常了解的人。那时候，工作结束搞Dubbo，周六加班研究Dubbo。看源码，看不懂就debug一下，debug也不明白就问，问人，问google，里外折腾了个遍。\n后来毕业加入网易云音乐。大概是今年五月份的时候，我发现了一个Dubbo的小bug，并且给Dubbo提交了pull request。在第一次被merge之后，非常受鼓舞，这才有了后续的故事。后来，回看这第一次提交，真的算是我和Dubbo的一个拐点，拐弯之后，我才逐渐走上一条成为Committer的路。\n可能很多人看到这里要望而却步了，这也是做开源给很多人留下的固有的印象——是不是没发现BUG就不能提交pull request，不能做贡献？其实完全不是的，这里给大家敲黑板划重点：其实很多贡献者的第一次贡献，贡献的并非代码，而是文档修改或者单元测试。相比于BUG或者新的Feature，单测和文档上的修复门槛就比较低了。\n我自己的方法论就是：先尝试增加单元测试，写单测的时候顺手debug+看代码。或者多看文档，了解框架的同时，发现错别字、语意不明或者文档上的链接干脆点不开的情况，直接提交PR到对应的仓库。\n万事开头难。第一次被merge代码，你就可以成为一个Contributor了。Contributor很多，但是Committer很少，下面继续说怎么从一个Contributor成长为独当一面的Committer。\nCommitter 做开源和写代码一样，都不是一朝一夕的事情，而是量变促成质变的过程。这是一个没捷径可走的过程，欲带皇冠必承其重。身后的Dubbo功底自不必多说，这个部分主要是想跟大家说一下除了钻研和热爱之外，其他需要注意的地方。\n首先是多提交高质量PR。任何一个PR都会被review，代码中的问题，思路上的偏差，都会被指正。提交PR是一个反复琢磨的过程。PR的质量不能简单的归结于新增了多少行代码，高质量的PR一定是经过缜密思考的，为什么删除代码，新增的代码有什么意义，修改之后有什么效果等等。希望大家更加重视质量而非数量，眼光放长远，相信你的收获一定会非常大！\n第二个就是，我们需要培养一种思维方式——Apache Way。一句话概括就是社区重于代码。Apache是一个注重社区的的开源组织，其行为方式相比于目前我们的开发方式，还是有所不同，这里我举一个Apache Way的例子，用以说明传统方式相较于Apache Way的区别在哪里，这里假设我想为Dubbo开发一个功能A。\nOld Way：\n 功能设计：做一个设计文档（根据功能大小而定），大概划定需要修改或新增的类，大体设计接口等。 开发代码。 提交PR。 Review \u0026amp; Merge  可以看到，我们整个过程中，真正与社区交互的只有最后一步。\nApache Way：\n 功能设计：发送邮件至mailing list并且提交ISSUE，与社区成员共同探讨，产出一个设计文档（根据功能大小而定），大概划定需要修改或新增的类，大体设计接口等。然后再次发送邮件并且回复ISSUE，通知社区设计文档定稿或者方案确定。 开发代码：发送邮件至社区，通知社区成员我即将投入开发功能A，如需帮助，可以同时说明需要协助。 提交PR：发送邮件并且回复ISSUE，提醒社区开发结束，贴上PR地址以通知社区review代码。 Review + Merge后，发送邮件并且关闭ISSUE，通知社区功能A的开发功能告一段落。  可以看到，Apache Way就是在整个开发过程中，不断地与社区交互，最大发挥社区的功能，汲取众人之力，这才是所谓社区以及所谓开源的含义。\n结尾 Dubbo目前还在孵化阶段，整个Dubbo社区还不完善，我们也在跟着Dubbo一起成长，我们非常希望更多的Dubbo爱好者深度参与到Dubbo中，为你的代码生涯树一个里程碑。\n相信过程，收获结果；天道酬勤，功不唐捐！","text":null,"weight":0},{"authors":null,"date":1547683200,"description":"This article will introduce you how to use Seata to ensure consistency between Dubbo Microservices.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"How to use Seata to ensure consistency between Dubbo Microservices","lvl1":"blog","lvl2":"/blog/2019/01/17/how-to-use-seata-to-ensure-consistency-between-dubbo-microservices/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"17a13e90ad94ccd9df5bfc022b0ccb17","permalink":"/blog/2019/01/17/how-to-use-seata-to-ensure-consistency-between-dubbo-microservices/","publishdate":"2019-01-17T00:00:00Z","readingtime":0,"relpermalink":"/blog/2019/01/17/how-to-use-seata-to-ensure-consistency-between-dubbo-microservices/","summary":"","text":null,"weight":0},{"authors":null,"date":1547683200,"description":"本文主要介绍如何使用Seata保证Dubbo微服务间的一致性\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何使用Seata保证Dubbo微服务间的一致性","lvl1":"blog","lvl2":"/zh/blog/2019/01/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8seata%E4%BF%9D%E8%AF%81dubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/","lvl3":453,"lvl4":"blog","lvl5":null,"objectID":"17a13e90ad94ccd9df5bfc022b0ccb17","permalink":"/zh/blog/2019/01/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8seata%E4%BF%9D%E8%AF%81dubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/","publishdate":"2019-01-17T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2019/01/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8seata%E4%BF%9D%E8%AF%81dubbo%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/","summary":"案例 用户采购商品业务，整个业务包含3个微服务:\n 库存服务: 扣减给定商品的库存数量。 订单服务: 根据采购请求生成订单。 账户服务: 用户账户金额扣减。  业务结构图 StorageService public interface StorageService { /** * 扣除存储数量 */ void deduct(String commodityCode, int count); } OrderService public interface OrderService { /** * 创建订单 */ Order create(String userId, String commodityCode, int orderCount); } AccountService public interface AccountService { /** * 从用户账户中借出 */ void debit(String userId, int money); } 主要的业务逻辑： public class BusinessServiceImpl implements BusinessService { private StorageService storageService; private OrderService orderService; /** * 采购 */ public void purchase(String userId, String commodityCode, int orderCount) { storageService.","text":null,"weight":0},{"authors":null,"date":1546819200,"description":"当前版本的Dubbo Admin包含了之前版本中的绝大部分功能，包括服务治理，服务查询等，同时支持了Dubbo2.7中服务治理的新特性\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"新版 Dubbo Admin 介绍","lvl1":"blog","lvl2":"/zh/blog/2019/01/07/%E6%96%B0%E7%89%88-dubbo-admin-%E4%BB%8B%E7%BB%8D/","lvl3":61,"lvl4":"blog","lvl5":null,"objectID":"00b81f507a85044607f8ce902370bacb","permalink":"/zh/blog/2019/01/07/%E6%96%B0%E7%89%88-dubbo-admin-%E4%BB%8B%E7%BB%8D/","publishdate":"2019-01-07T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/01/07/%E6%96%B0%E7%89%88-dubbo-admin-%E4%BB%8B%E7%BB%8D/","summary":"Demo地址：http://47.91.207.147/#/service github: https://github.com/apache/dubbo-ops Dubbo Admin之前的版本过于老旧，也长期疏于维护，因此在去年年中的时候，对该项目进行了一次重构，项目结构上的变化如下：\n 将后端框架从webx替换成spring boot 前端采用Vue和Vuetify.js作为开发框架 移除velocity模板 集成swagger，提供api管理功能  当前版本的Dubbo Admin包含了之前版本中的绝大部分功能，包括服务治理，服务查询等，同时支持了Dubbo2.7中服务治理的新特性。\n配置规范 由于在Dubbo2.7中，配置中心和注册中心做了分离，并且增加了元数据中心，因此Dubbo Admin的配置方式也做了更新，application.properties中的配置如下:\nadmin.registry.address=zookeeper://127.0.0.1:2181 admin.config-center=zookeeper://127.0.0.1:2181 admin.metadata-report.address=zookeeper://127.0.0.1:2181 也可以和Dubbo2.7一样，在配置中心指定元数据和注册中心的地址，以zookeeper为例，配置的路径和内容如下:\n# /dubbo/config/dubbo/dubbo.properties dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.metadata-report.address=zookeeper://127.0.0.1:2181 配置中心里的地址会覆盖掉本地application.properties的配置\n功能介绍 功能上，主要延续了之前版本的功能，包括服务查询和服务治理，2.7版本在服务治理的功能上有了很大的改进，这些改进也大部分都会以Dubbo Admin作为入口来体现。\n标签路由 标签路由是Dubbo2.7引入的新功能，配置以应用作为维度，给不同的服务器打上不同名字的标签，配置如下图所示：\n调用的时候，客户端可以通过setAttachment的方式，来设置不同的标签名称，比如本例中，setAttachment(tag1)，客户端的选址范围就在如图所示的三台机器中，可以通过这种方式来实现流量隔离，灰度发布等功能。\n应用级别的服务治理 在Dubbo2.6及更早版本中，所有的服务治理规则都只针对服务粒度，如果要把某条规则作用到应用粒度上，需要为应用下的所有服务配合相同的规则，变更，删除的时候也需要对应的操作，这样的操作很不友好，因此Dubbo2.7版本中增加了应用粒度的服务治理操作，对于条件路由(包括黑白名单)，动态配置(包括权重，负载均衡)都可以做应用级别的配置：\n上图是条件路由的配置，可以按照应用名，服务名两个维度来填写，也可以按照这两个维度来查询。\n条件路由，标签路由和动态配置都采用了yaml格式的文本编写，其他的规则配置还是采用了表单的形式。\n关于兼容性 Dubbo2.6到Dubbo2.7，服务治理发生了比较大的变化，Dubbo Admin兼容两个版本的用法：\n 对于服务级别的配置，会按照Dubbo2.6(URL)和Dubbo2.7(配置文件)两种格式进行写入，保证Dubbo2.6的客户端能够正确读取，解析规则 对于应用级别的配置，包括标签路由，只会按照Dubbo2.7的格式进行写入，因为Dubbo2.6无此功能，不需要做向前兼容。 Dubbo Admin只会按照Dubbo2.7的格式进行配置读取，因此，所有在Dubbo Admin上做的配置都可以被读到，但是之前遗留的，Dubbo2.6格式的URL无法被读取。 对于同一个应用或者服务，每种规则只能够配置一条，否则新的会覆盖旧的。  配置管理 配置管理也是配合Dubbo2.7新增的功能，在Dubbo2.7中，增加了全局和应用维度的配置，\n 全局配置：  全局配置里可以指定注册中心，元数据中心的地址，服务端和客户端的超时时间等，这些配置在全局内生效。除了配置写入，也可以用来查看。如果使用zookeeper作为注册中心和元数据中心，还可以看到配置文件所在位置的目录结构。\n 应用， 服务配置  应用级别的配置可以为应用或者应用内的服务指定配置，在服务维度上，需要区分提供者和消费者。dubbo.reference.{serviceName}表示作为该服务消费者的配置，dubbo.provider.{servcieName}表示作为该服务提供者的配置。优先级服务 \u0026gt; 应用 \u0026gt; 全局。其中注册中心和元数据中心的地址，只能在全局配置中指定，这也是Dubbo2.7中推荐的使用方式。\n元数据和服务测试 元数据是Dubbo2.7中新引入的元素，主要的使用场景就在Dubbo Admin中，主要体现在两个地方：\n 服务详情展示：  跟之前版本相比，Dubbo2.7中增加了对服务方法完整签名的记录，因此服务详情中也增加了方法信息的详情，可以看到方法名，方法参数列表以及返回值信息。\n 服务测试：  更重要的，元数据为服务测试提供了数据基础，可以在页面上调用真实的服务提供者，方便测试，也不需要为了调用服务去搭建一套Dubbo环境以及编写消费端代码。","text":null,"weight":0},{"authors":null,"date":1546819200,"description":"RPC-远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"浅谈 RPC","lvl1":"blog","lvl2":"/zh/blog/2019/01/07/%E6%B5%85%E8%B0%88-rpc/","lvl3":186,"lvl4":"blog","lvl5":null,"objectID":"6fd306c127f0416164a7d251caf72cb7","permalink":"/zh/blog/2019/01/07/%E6%B5%85%E8%B0%88-rpc/","publishdate":"2019-01-07T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2019/01/07/%E6%B5%85%E8%B0%88-rpc/","summary":"近几年随着微服务化项目的崛起，逐渐成为许多公司中大型分布式系统架构的主流方式，而今天所说的 RPC 在这其中扮演着至关重要的角色。随着这段日子公司项目微服务化的演进，发现在日常开发中都在隐式或显式的使用 RPC，一些刚刚接触 RPC 的小伙伴会感觉无所适从，而一些入行多年的老手虽然使用 RPC 经验丰富，但有些对其原理也一知半解，缺乏对原理的深入理解，往往也会造成开发中的一些误用。\n什么是RPC？ RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。\nRPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。现在业界有很多开源的优秀 RPC 框架，例如 Spring Cloud、Dubbo、Thrift 等。\nRPC 起源 RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出。这里我们追溯下当初开发 RPC 的原动机是什么？在 Nelson 的论文 \u0026ldquo;Implementing Remote Procedure Calls\u0026rdquo; 中他提到了几点：\n 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。 高效：过程调用看起来十分简单而且高效。 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制。  通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。Nelson 的论文发表于 30 年前，其观点今天看来确实高瞻远瞩，今天我们使用的 RPC 框架基本就是按这个目标来实现的。\nRPC 结构 Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：\n User User-stub RPCRuntime Server-stub Server  这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。","text":null,"weight":0},{"authors":null,"date":1546646400,"description":"目前在瓜子的私有云上已经运行着数百个dubbo应用，上千个dubbo实例\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 在瓜子二手车的实践","lvl1":"blog","lvl2":"/zh/blog/2019/01/05/dubbo-%E5%9C%A8%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E7%9A%84%E5%AE%9E%E8%B7%B5/","lvl3":246,"lvl4":"blog","lvl5":null,"objectID":"f83fc2fe22c3d891a08c2f3f18ba92c8","permalink":"/zh/blog/2019/01/05/dubbo-%E5%9C%A8%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E7%9A%84%E5%AE%9E%E8%B7%B5/","publishdate":"2019-01-05T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2019/01/05/dubbo-%E5%9C%A8%E7%93%9C%E5%AD%90%E4%BA%8C%E6%89%8B%E8%BD%A6%E7%9A%84%E5%AE%9E%E8%B7%B5/","summary":"前言  随着瓜子业务的不断发展，系统规模在逐渐扩大，目前在瓜子的私有云上已经运行着数百个dubbo应用，上千个dubbo实例。瓜子各部门业务迅速发展，版本没有来得及统一，各个部门都有自己的用法。随着第二机房的建设，dubbo版本统一的需求变得越发迫切。几个月前，公司发生了一次与dubbo相关的生产事故，成为了公司dubbo版本升级的诱因。\n 接下来，我会从这次事故开始，讲讲我们这段时间所做的dubbo版本升级的历程以及dubbo后续多机房的方案。\n一、Ephermal节点未及时删除导致provider不能恢复注册的问题修复 事故背景  在生产环境，瓜子内部各业务线共用一套zookeeper集群作为dubbo的注册中心。2019年9月份，机房的一台交换机发生故障，导致zookeeper集群出现了几分钟的网络波动。在zookeeper集群恢复后，正常情况下dubbo的provider应该会很快重新注册到zookeeper上，但有一小部分的provider很长一段时间没有重新注册到zookeeper上，直到手动重启应用后才恢复注册。\n排查过程  首先，我们统计了出现这种现象的dubbo服务的版本分布情况，发现在大多数的dubbo版本中都存在这种问题，且发生问题的服务比例相对较低，在github中我们也未找到相关问题的issues。因此，推断这是一个尚未修复的且在网络波动情况的场景下偶现的问题。\n 接着，我们便将出现问题的应用日志、zookeeper日志与dubbo代码逻辑进行相互印证。在应用日志中，应用重连zookeeper成功后provider立刻进行了重新注册，之后便没有任何日志打印。而在zookeeper日志中，注册节点被删除后，并没有重新创建注册节点。对应到dubbo的代码中，只有在FailbackRegistry.register(url)的doRegister(url)执行成功或线程被挂起的情况下，才能与日志中的情况相吻合。\npublic void register(URL url) { super.register(url); failedRegistered.remove(url); failedUnregistered.remove(url); try { // Sending a registration request to the server side  doRegister(url); } catch (Exception e) { Throwable t = e; // If the startup detection is opened, the Exception is thrown directly.  boolean check = getUrl().getParameter(Constants.CHECK_KEY, true) \u0026amp;\u0026amp; url.getParameter(Constants.CHECK_KEY, true) \u0026amp;\u0026amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol()); boolean skipFailback = t instanceof SkipFailbackWrapperException; if (check || skipFailback) { if (skipFailback) { t = t.","text":null,"weight":0},{"authors":null,"date":1544400000,"description":"The fifth Dubbo meetup has been held in Hangzhou","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The fifth Dubbo meetup has been held in Hangzhou","lvl1":"blog","lvl2":"/blog/2018/12/10/the-fifth-dubbo-meetup-has-been-held-in-hangzhou/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"5373d23ca6e6134201f23327b745d6b4","permalink":"/blog/2018/12/10/the-fifth-dubbo-meetup-has-been-held-in-hangzhou/","publishdate":"2018-12-10T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/12/10/the-fifth-dubbo-meetup-has-been-held-in-hangzhou/","summary":"","text":null,"weight":0},{"authors":null,"date":1544400000,"description":"第五届Dubbo开发者沙龙在杭州成功举办。","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第五届Dubbo开发者沙龙在杭州成功举办","lvl1":"blog","lvl2":"/zh/blog/2018/12/10/%E7%AC%AC%E4%BA%94%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%9D%AD%E5%B7%9E%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","lvl3":21,"lvl4":"blog","lvl5":null,"objectID":"5373d23ca6e6134201f23327b745d6b4","permalink":"/zh/blog/2018/12/10/%E7%AC%AC%E4%BA%94%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%9D%AD%E5%B7%9E%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","publishdate":"2018-12-10T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/12/10/%E7%AC%AC%E4%BA%94%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%9D%AD%E5%B7%9E%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","summary":"第五届Dubbo开发者沙龙在杭州成功举办，\n分享嘉宾\n 李鼎: 如何参与Dubbo开源社区 slides 曹胜利: Dubbo 2.7新特性介绍及演示 slides 陶杨: Dubbo在考拉的应用实践 slides 小马哥: Dubbo+Nacos服务治理重新实现 slides 赵奕豪: Sentinel:分布式服务的流量防卫兵 slides 陈志轩: 当Dubbo遇上Arthas:排查问题的实践 slides  ","text":null,"weight":0},{"authors":null,"date":1541548800,"description":"本文介绍了如何在 Dubbo 中使用 Nacos 作为服务注册中心","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 融合 Nacos 成为注册中心","lvl1":"blog","lvl2":"/zh/blog/2018/11/07/dubbo-%E8%9E%8D%E5%90%88-nacos-%E6%88%90%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","lvl3":1064,"lvl4":"blog","lvl5":null,"objectID":"f15fd436b997f65df9765134c99653a3","permalink":"/zh/blog/2018/11/07/dubbo-%E8%9E%8D%E5%90%88-nacos-%E6%88%90%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","publishdate":"2018-11-07T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/2018/11/07/dubbo-%E8%9E%8D%E5%90%88-nacos-%E6%88%90%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","summary":"Nacos 作为 Dubbo 生态系统中重要的注册中心实现，其中 dubbo-registry-nacos 则是 Dubbo 融合 Nacos 注册中心的实现。\n预备工作 当您将 dubbo-registry-nacos 整合到您的 Dubbo 工程之前，请确保后台已经启动 Nacos 服务。如果您尚且不熟悉 Nacos 的基本使用的话，可先行参考 Nacos 快速入门：https://nacos.io/en-us/docs/quick-start.html。建议使用 Nacos 0.6.1 以上的版本。\n快速上手 Dubbo 融合 Nacos 成为注册中心的操作步骤非常简单，大致步骤可分为“增加 Maven 依赖”以及“配置注册中心“。\n增加 Maven 依赖 首先，您需要 dubbo-registry-nacos 的 Maven 依赖添加到您的项目中 pom.xml 文件中，并且强烈地推荐您使用 Dubbo 2.6.5：\n\u0026lt;dependencies\u0026gt; ... \u0026lt;!-- Dubbo Nacos registry dependency --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-registry-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Keep latest Nacos client version --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[0.6.1,)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Dubbo dependency --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.","text":null,"weight":0},{"authors":null,"date":1541548800,"description":"This article introduces how to use Nacos in Dubbo application.","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Integrates with Nacos to Become a Registry","lvl1":"blog","lvl2":"/blog/2018/11/07/dubbo-integrates-with-nacos-to-become-a-registry/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"f15fd436b997f65df9765134c99653a3","permalink":"/blog/2018/11/07/dubbo-integrates-with-nacos-to-become-a-registry/","publishdate":"2018-11-07T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/11/07/dubbo-integrates-with-nacos-to-become-a-registry/","summary":"","text":null,"weight":0},{"authors":null,"date":1540598400,"description":"本文主要介绍了 Dubbo 中服务分组和版本聚合的概念和用法\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo服务分组和版本聚合","lvl1":"blog","lvl2":"/zh/blog/2018/10/27/dubbo%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BB%84%E5%92%8C%E7%89%88%E6%9C%AC%E8%81%9A%E5%90%88/","lvl3":473,"lvl4":"blog","lvl5":null,"objectID":"b1d7c29ba7e7c98bdf43719069c6012a","permalink":"/zh/blog/2018/10/27/dubbo%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BB%84%E5%92%8C%E7%89%88%E6%9C%AC%E8%81%9A%E5%90%88/","publishdate":"2018-10-27T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/10/27/dubbo%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BB%84%E5%92%8C%E7%89%88%E6%9C%AC%E8%81%9A%E5%90%88/","summary":"我们在调用Dubbo服务的时候，一般只需要将Consumer端的dubbo:reference指定成服务端中dubbo:service暴露的服务，就可以找到服务端，完成调用，也就是说，Dubbo只需要服务接口信息就可以找到服务提供者。 其实除了服务提供者以外，Dubbo也有服务分组和版本的概念，在客户端去寻找“匹配”的服务端的时候，需要服务接口，版本号，组别这三个信息都匹配，才算是一个有效的服务端：\npublic static boolean isMatch(URL consumerUrl, URL providerUrl) { String consumerInterface = consumerUrl.getServiceInterface(); String providerInterface = providerUrl.getServiceInterface(); if (!(Constants.ANY_VALUE.equals(consumerInterface) || StringUtils.isEquals(consumerInterface, providerInterface))) return false; if (!isMatchCategory(providerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY), consumerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))) { return false; } if (!providerUrl.getParameter(Constants.ENABLED_KEY, true) \u0026amp;\u0026amp; !Constants.ANY_VALUE.equals(consumerUrl.getParameter(Constants.ENABLED_KEY))) { return false; } String consumerGroup = consumerUrl.getParameter(Constants.GROUP_KEY); String consumerVersion = consumerUrl.getParameter(Constants.VERSION_KEY); String consumerClassifier = consumerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE); String providerGroup = providerUrl.getParameter(Constants.GROUP_KEY); String providerVersion = providerUrl.getParameter(Constants.VERSION_KEY); String providerClassifier = providerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE); return (Constants.","text":null,"weight":0},{"authors":null,"date":1538697600,"description":"本文介绍了 Dubbo 协议的设计","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 协议详解","lvl1":"blog","lvl2":"/zh/blog/2018/10/05/dubbo-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","lvl3":335,"lvl4":"blog","lvl5":null,"objectID":"977c141dc477eefa72cd1e170a0c4b4f","permalink":"/zh/blog/2018/10/05/dubbo-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","publishdate":"2018-10-05T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/10/05/dubbo-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","summary":"协议的概念 协议是两个网络实体进行通信的基础，数据在网络上从一个实体传输到另一个实体，以字节流的形式传递到对端。在这个字节流的世界里，如果没有协议，就无法将这个一维的字节流重塑成为二维或者多维的数据结构以及领域对象。\n协议是什么 协议是双方确定的交流语义，比如：我们设计一个字符串传输的协议，它允许客户端发送一个字符串，服务端接收到对应的字符串。这个协议很简单，首先发送一个4字节的消息总长度，然后再发送1字节的字符集charset长度，接下来就是消息的payload，字符集名称和字符串正文。\n发送一个iso-8859-1的字符串abc到对端。经过协议编码，内容是：18 = 4 + 1 + 10 + 3|10|iso-8859-1|abc，当这些字节流发往服务端后，当服务端收到字节流后，首先读取4个字节，将其转换为int，在这个例子中是18，接下来继续读14个字节，将首个字节得到字符集名称长度10，将后续内容的前10字节转换为字符串，内容是iso-8859-1，使用该字符集将后续的字节数组造型成为字符串new String(bytes, \u0026quot;iso-8859-1\u0026quot;)。\n在前面自定义字符串传输协议的例子中，我们已经看到协议在双方传输数据中起到的作用，没有协议就无法完成数据交换，下面是维基百科对于通信协议的定义。\n In telecommunication, a communication protocol is a system of rules that allow two or more entities of a communications system to transmit information via any kind of variation of a physical quantity. The protocol defines the rules syntax, semantics and synchronization of communication and possible error recovery methods. Protocols may be implemented by hardware, software, or a combination of both.","text":null,"weight":0},{"authors":null,"date":1538697600,"description":"This article introduces the design of the Dubbo protocol.","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Introduction to the Dubbo protocol","lvl1":"blog","lvl2":"/blog/2018/10/05/introduction-to-the-dubbo-protocol/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"977c141dc477eefa72cd1e170a0c4b4f","permalink":"/blog/2018/10/05/introduction-to-the-dubbo-protocol/","publishdate":"2018-10-05T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/10/05/introduction-to-the-dubbo-protocol/","summary":"","text":null,"weight":0},{"authors":null,"date":1538265600,"description":"本文主要尝试将Dubbo服务注册到Kubernetes，同时无缝融入Kubernetes的多租户安全体系。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo与Kubernetes集成","lvl1":"blog","lvl2":"/zh/blog/2018/09/30/dubbo%E4%B8%8Ekubernetes%E9%9B%86%E6%88%90/","lvl3":139,"lvl4":"blog","lvl5":null,"objectID":"c85f9dcf1d0d954ef16d7fd6cccac1ed","permalink":"/zh/blog/2018/09/30/dubbo%E4%B8%8Ekubernetes%E9%9B%86%E6%88%90/","publishdate":"2018-09-30T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/09/30/dubbo%E4%B8%8Ekubernetes%E9%9B%86%E6%88%90/","summary":"大体目标 Dubbo的provider不再关心服务注册的事宜，只需要把其Dubbo服务端口打开，由Kubernetes来进行服务的声明和发布；Dubbo的consumer在服务发现时直接发现kubernetes的对应服务endpoints，从而复用Dubbo已有的微服务通道能力。好处是无需依赖三方的软负载注册中心；同时无缝融入Kubernetes的多租户安全体系。Demo的代码参照： https://github.com/dubbo/dubbo-kubernetes\n闲谈 Kubernates是建立在扩展性的具备二次开发的功能层次丰富的体系化系统\n 首先其最核心的功能是管理容器集群，能管理容器化的集群（包括存储，计算），当然这个是建立在对容器运行时(CRI)，网络接口(CNI),存储服务接口（CSI/FV）的基础上； 其次是面向应用(包括无状态/有状态,批处理/服务型应用)的部署和路由能力，特别是基于微服务架构的应用管理，具备了其服务定义和服务发现，以及基于configmap的统一配置能力； 在基础资源（主要是抽象底层IaaS的资源）和应用层的抽象模型之上是治理层，包含弹性扩容，命名空间/租户，等。当然，基于其原子内核的基础能力，在Kubernetes的核心之上搭建统一的日志中心和全方位监控等服务是水到渠成的，CNCF更是有其认定推荐。  来张Kubernetes Architecture的一张图解释下上述描述。在2018年Kubernetes往事实的paas底座的标配迈出质的一步，有人说原因在于基于扩展的二次开发能力，有人说在于其声明式编程和背靠Google和Redhat的强大社区运作，我觉得回归本质是在于下图中的Layered架构和其问题域的领域建模抽象。\n以微服务架构视角，Kubernetes在一定意义上是微服务框架（这时较叫微服务平台或toolkit集更合适），支持微服务的服务发现/注册的基本能力。借用如下图做一个简单描述。\n话题再展开一下，微服务领域涉及众多问题，大概可以用下图说明。\nKubernetes解决得只是少部分，而像动态路由，稳定性控制（断路器，隔水舱等），分布式服务追踪等是个空白，这也就是servicemesh要解决的，是在CNCF的Trail Map占有重要一席；当然Dubbo是基本具备完备的微服务，也就是使得其集成到k8s体系下具有相当的意义。Dubbo在serviemesh中基于sidecar的方案是解决跨语言诉求的通用servicemesh方案，需要新开一个话题来展开说；而引用serviemsh的原始定义：\n A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application.\n  首先服务网格是一个云原生环境下基础设施层，功能在于处理服务间通信，职责是负责实现请求的可靠传递，被使得被监控跟踪，被治理，最终使得微服务架构被赋予高可控的稳定性和快速的问题定位排查能力。\n 可以得出现有Dubbo集成云原生基础设施Kubernetes的基础能力而并解决微服务相关核心问题也算是一种狭义上的servicemesh方案，只是是Java领域的罢了；当玩笑理解也行，哈哈。\n思路/方案 Kubernetes是天然可作为微服务的地址注册中心，类似于Zookeeper， 阿里巴巴内部用到的VIPserver，Configserver。 具体来说，Kubernetes中的Pod是对于应用的运行实例，Pod的被调度部署/启停都会调用API-Server的服务来保持其状态到ETCD；Kubernetes中的service是对应微服务的概念，定义如下\n A Kubernetes Service is an abstraction layer which defines a logical set of Pods and enables external traffic exposure, load balancing and service discovery for those Pods.","text":null,"weight":0},{"authors":null,"date":1538265600,"description":"This article will try to register Dubbo service to Kubernetes and integrate with Kubernetes's multi-tenancy security system.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Integrate Dubbo with Kubernetes","lvl1":"blog","lvl2":"/blog/2018/09/30/integrate-dubbo-with-kubernetes/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"c85f9dcf1d0d954ef16d7fd6cccac1ed","permalink":"/blog/2018/09/30/integrate-dubbo-with-kubernetes/","publishdate":"2018-09-30T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/09/30/integrate-dubbo-with-kubernetes/","summary":"","text":null,"weight":0},{"authors":null,"date":1537401600,"description":"本文介绍了Dubbo在Service Mesh方向的实践与探索","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo Mesh ｜ Service Mesh的实践与探索","lvl1":"blog","lvl2":"/zh/blog/2018/09/20/dubbo-mesh-service-mesh%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/","lvl3":112,"lvl4":"blog","lvl5":null,"objectID":"dda4ed7813e628d82d6a3ca780dc186c","permalink":"/zh/blog/2018/09/20/dubbo-mesh-service-mesh%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/","publishdate":"2018-09-20T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/09/20/dubbo-mesh-service-mesh%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%8E%A2%E7%B4%A2/","summary":"近日，在Aliware Open Source•成都站-Apache Dubbo 开发者沙龙上，阿里巴巴中间件高级技术专家李云（至简）向开发者们分享了阿里巴巴中间件团队在Service Mmesh领域的探索和最新实践。本文是根据至简的现场分享所整理，为大家回顾分享中的精彩内容。\n精彩观点导读   我们去探索一项技术，并不会仅仅因为其先进性，而是因为我们目前遇到了一些无法解决的问题，而这项技术正好能解决这个问题。\n  所有软件最重要的使命不是满足功能要求，而是演进，从而持续成长。\n  微服务本质是对服务的拆分，微服务架构符合工程领域常用的“分而治之”范式。\n  前言 我们去探索一项技术，并不会仅仅因为其先进性，而是因为我们目前遇到了一些无法解决的问题，而这项技术正好能解决这个问题。现在，阿里巴巴整个集团业务的体量很大，在技术上会遇到很多的挑战。而正是因为这些挑战，让我们思考通过哪些新技术可以去解决这些痛点，这也是我们在Service Mesh领域进行探索和实践的出发点。首先，我们先来看看自己遇到了哪些挑战。\n微服务的5大挑战 挑战一：微服务框架自身演进困难。 任何软件都会有他的生命进化曲线，从最初的萌芽，进入形成期，往上发展，再进入平台期，最后进入衰亡期。当然我们希望我们的软件可以在进入平台期后，能借助某次演进进入新的发展期。从这个维度看，所有软件最重要的使命不是满足功能要求，而是演进，从而持续成长。相反，当某个软件无法演进的时候，就会意味着死亡。但软件的演进并不是一个简单的事情，以微服务框架为例，为了进一步提升双11期间整个中间件平台的稳定性，我们会修改若干个功能，并以SDK的方式去提供给业务方，但业务代码和微服务框架SDK是强耦合的，这时候需要我们推动各个业务方和我们一同去做升级。虽然我们的初衷是实现平台稳定性的提升，帮助业务更好的发展，但这时由于大家的出发点和诉求有所不同，业务方和我们一起去做升级是比较困难的。所以要发展微服务框架，首先遇到的挑战就是演进困难。 挑战二：微服务框架SDK多语言并行开发与维护成本高。 以前我们都是通过对技术栈的统一来提升成本优势和团队效率，大家可以用一种语言去开发和维护，避免多语言时团队的不聚焦。但在软件和开源生态演进的过程中，多语言已经成为一种流行，因为不同语言都有其自身的优势，今天大家能看到的一个现象是云原生的生态中有多种开发语言，使用频率最高的语言已经不是Java了，而是Go，是因为Go的footprint很小。再以 Dubbo为例，除了Java，我们还提供C++，Node.js的SDK，以便让更多的开发者可以加入Dubbo生态，但所有的这些，如果没有社区力量的参与，是很难维持的。 挑战三：异构服务框架难以共存完成渐进式演进。 我们结合场景来看看这个挑战。阿里巴巴收购了一些企业，被收购企业的技术栈可能和阿里巴巴不同，比如有些用的是Go语言，有些用的是PHP，这时候为了统一技术栈，我们需要对这类技术平台推倒重来，但这个过程中，我们会面临一系列问题，首当其冲的就是推倒重来会带来巨大的技术风险，其次是可能会面临技术人员大批量流失的风险，这在社会责任的层面也是很难接受。所以我们在寻求一种可能的方案，去解决这类问题。\n挑战四：是单一的语言限制了人才的多样性。 这里，我们不去争论某个编程语言的好与坏，每个语言都有其适用场景，你不能说我手里有个榔头，你面对的都是钉子。以前我们觉得统一技术栈可以集中开发力量，并且带来较高的运维便利性。但伴随着互联网带来的快节奏，以往的团队能力设置已经很难满足这类变化，对工程师个体提出了更高的要求，我们不仅仅需要是某一方面的专家，而且还需要具备多域的工作技能，DevOps和全栈工程师就是这类快节奏变化下最好的注脚。 挑战五：是点状的服务治理难以做到及时、有效和经济。 微服务和架构的核心是拆分，通过拆分，让每个模块可以独立运行，跟上业务的发展速度，持续推动业务的创新。但拆完后新的问题出来了，缺少横向的内容拉通所有独立的烟囱，从而在服务治理上带来极大的挑战。\n分布式应用的发展趋势 微服务会成为大规模分布式应用的主流架构。任何复杂的工程问题都会归结为devide and conquer（分而治之），意思就是就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。微服务本质是对服务的拆分，与工程领域惯用的“分而治之”的思路是一致的。\n微服务架构下应用的开发是多语言的。没有一个语言是一家独大的，每种语言在特定场景下都有其自身的优势，我们希望这种优势能够将技术到产品的周期（time to market）缩短。技术的核心在于创造价值，无论是交付给客户，还是服务于整个社会。因此，微服务是需要不同语言的开发者发挥自身的优势，去进一步完善我们的微服务架构，释放技术价值。 数据安全将成为公有云分布式应用的生命线。云原生时代，业务即便没上云，企业对自身数据的安全都是有诉求的，尤其是在金融行业，如果通过抓包就能获取一些敏感信息，这将会给企业带来巨大的风险。\nCloud native成为distributionless（无分布式）的主要探索路径。分布式发展的终极形式是无分布式，在未来我们做开发，所有的代码在web上写好后，通过点击一个按钮，所有部署都会自动实现，所有的code review的工作可以在一个统一的工作台上全部实现。 以更快的速度，通过构建软件去探索新业务。工程师服务的是客户，通过技术输出来实现技术价值，以互联网的架构帮助赋能传统企业，帮助企业获得差异化竞争力。\n什么是Service Mesh Service Mesh是层次化、规范化、体系化、无侵入的分布式服务治理技术平台。\n层次化 分为数据面和控制面两个概念，数据面是指所有数据流动的那个层面，控制面是用来控制这个数据面的，对服务去做处理。对数据面和控制面进行分层，带来的好处是，针对一个复杂的系统进行切分，可以获得更清晰的认识，这和devide and conque是同一个理念。\n规范化 是指通过标准协议完成数据平面和控制平面的连接，同时，sidecar成为所有traffic互联、互通的约束标准。\n体系化 包含两个维度，一是指observability全局考虑。目前在整个分布式治理过程中的最大挑战是：logging、metrics、tracing这三个observability领域的核心内容缺少体系性的关注。另一个是集中管理的维度，包括服务管理、限流、熔断、安全、灰度在内的服务模块都可以在获得体系化的呈现，每个服务都可以被看到，而非团队a只看限流，团队b只看logging，需要一种技术能力拉通所有的服务模块，这个体系化这个角度看，Service Mesh是一个理想的技术方案。\n无侵入 是指我们希望通过无侵入，当新增一个业务的时候，不需要考虑一个SDK去初始化，而是可以通过sidecar的进程方式来解耦。\nService Mesh的形态 我们从三个维度对比的来看 ServiceMesh 的形态。\n图中左边是传统的微服务形态，调用者和被调用者是通过一个SDK的方式来实现共享服务的，以Dubbo为例，我们会在SDK里提供服务路由、服务发现等功能，虽然我们的开发者在做应用开发的时候并不会太关注SDK的构成，但这些功能是面临不断被变更的可能，有着比较重的逻辑。在右边Service Mesh的形态中，我们首先会对厚重的SDK进行分解，将复杂的逻辑下沉到sidecar，借助sidecar来实现服务的调用。\n虽然在Service Mesh的形态，调用路径要长于传统的形态，路径越长消耗越大，对性能影响越大。但在当前的分布式应用的治理过程中，易用性已经成为一个比性能更重要的话题。当我们给客户部署一套微服务，即便性能很强，但没有处理好易用性问题的话，这将会给技术的推广带来巨大的阻碍，不仅是会影响外部的客户，也会影响内部的用户，如何实现喝着咖啡从容应对双11，必须先解决易用性的问题。在解决易用性问题后，沿着技术的发展路径再去解决性能问题。\nService Mesh的形态中的control plan不会导致重复建设，但在shared service是有可能存在重复建设的。","text":null,"weight":0},{"authors":null,"date":1535846400,"description":"This article introduces how to the Apache publish content and process\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"How to prepare an Apache Release","lvl1":"blog","lvl2":"/blog/2018/09/02/how-to-prepare-an-apache-release/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"3d7271b50c623ea90de867f20749bb61","permalink":"/blog/2018/09/02/how-to-prepare-an-apache-release/","publishdate":"2018-09-02T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/09/02/how-to-prepare-an-apache-release/","summary":"","text":null,"weight":0},{"authors":null,"date":1535846400,"description":"This article recalls how asynchronous call is implemented in Dubbo 2.6.x, and introduces the new way based on CompletableFuture in 2.7.0.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"How to implement a fully asynchronous calls chain based on Dubbo","lvl1":"blog","lvl2":"/blog/2018/09/02/how-to-implement-a-fully-asynchronous-calls-chain-based-on-dubbo/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"9f2ee82929f35ef85b9b8ebd13e0aa9c","permalink":"/blog/2018/09/02/how-to-implement-a-fully-asynchronous-calls-chain-based-on-dubbo/","publishdate":"2018-09-02T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/09/02/how-to-implement-a-fully-asynchronous-calls-chain-based-on-dubbo/","summary":"","text":null,"weight":0},{"authors":null,"date":1535846400,"description":"本文介绍了Apache如何发布内容和流程\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何准备Apache Release","lvl1":"blog","lvl2":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87apache-release/","lvl3":1358,"lvl4":"blog","lvl5":null,"objectID":"3d7271b50c623ea90de867f20749bb61","permalink":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87apache-release/","publishdate":"2018-09-02T00:00:00Z","readingtime":7,"relpermalink":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87apache-release/","summary":"理解Apache发布的内容和流程 总的来说，Source Release是Apache关注的重点，也是发布的必须内容；而Binary Release是可选项，Dubbo可以选择是否发布二进制包到Apache仓库或者发布到Maven中央仓库。\n请参考以下链接，找到更多关于ASF的发布指南:\n Apache Release Guide Apache Release Policy Maven Release Info  本地构建环境准备 主要包括签名工具、Maven仓库认证相关准备\n安装GPG 详细文档请参见这里, Mac OS下配置如下\n$ brew install gpg $ gpg --version #检查版本，应该为2.x 用gpg生成key 根据提示，生成key\n$ gpg --full-gen-key gpg (GnuPG) 2.0.12; Copyright (C) 2009 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) Your selection?","text":null,"weight":0},{"authors":null,"date":1535846400,"description":"本文回顾了 2.6.x 版本的异步实现，然后引出了 2.7.0 版本基于 CompletableFuture 的异步编程方式。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何基于Dubbo实现全异步调用链","lvl1":"blog","lvl2":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Edubbo%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E9%93%BE/","lvl3":656,"lvl4":"blog","lvl5":null,"objectID":"9f2ee82929f35ef85b9b8ebd13e0aa9c","permalink":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Edubbo%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E9%93%BE/","publishdate":"2018-09-02T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2018/09/02/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Edubbo%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E9%93%BE/","summary":"基于Dubbo实现全异步编程，是在2.7.0版本中对现有异步方式增强后新引入的功能。本文先是回顾2.6.x及之前版本对异步的支持情况及存在的问题，引出了2.7.0版本基于CompletableFuture做了哪些针对性的增强，通过几个示例详细阐述了增强后的异步编程的使用方式，最后总结了引入异步模式带来的新问题及Dubbo的解决方法。通过阅读这篇文章，可以很容易的基于Dubbo2.7.0+版本实现一个全异步的远程服务调用链路。\n从3.0.0版本开始，Dubbo框架提供了对Reactive编程范式的支持，除了编程接口之外，在跨进程的RPC通信中引入了Reactive的语义。如果你所在的环境需要使用Reactive编程范式，或者你的RPC调用需要支持流式传输，Reactive应该会给你带来帮助，具体请参考发布在阿里巴巴中间件公众号上的响应式编程支持相关文章。\n 注意，你可能并不是总需要Reactive的语义，尤其是在RPC的场景，CompletableFuture本身也能带给你Reactive模式的编程模型，在选择Reactive（RxJava、Reactor之类）而不是理解及使用成本更低的CompletableFuture前，请尝试关注以下问题：\n 你是请求/响应是一次性传输的还是流式传输的，一个明显特征是你定义的数据类型是 List\u0026lt;String\u0026gt; 还是 Stream\u0026lt;String\u0026gt; 你的RPC请求有没有要求是Cold，即在subscribe后触发，因为CompletableFuture总是hot的 你依赖的编程上下文中是否已经在大量使用Reactive的编程接口 你是否需要Rx框架提供的更丰富的Operator，而这点和1又是密切相关的   2.6.x版本之前的异步方式 在2.6.x及之前的版本提供了一定的异步编程能力，包括Consumer端异步调用、参数回调、事件通知等，在上面的文档链接中有关于使用方式的简单介绍和Demo。\n关于参数回调，其本质上是一种服务端的数据推送能力，这是终端应用很常见的一种需求，关于这部分的重构计划，不在本文讨论范围。\n但当前的异步方式存在以下问题：\n Future获取方式不够直接 Future接口无法实现自动回调，而自定义ResponseFuture虽支持回调但支持的异步场景有限，如不支持Future间的相互协调或组合等 不支持Provider端异步  以Consumer端异步使用方式为例：\n 定义一个普通的同步接口并声明支持异步调用  public interface FooService { String findFoo(String name); } \u0026lt;dubbo:reference id=\u0026#34;fooService\u0026#34; interface=\u0026#34;com.alibaba.foo.FooService\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;findFoo\u0026#34; async=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 通过RpcContext获取Future  // 此调用会立即返回null fooService.findFoo(fooId); // 拿到调用的Future引用，当结果返回后，会被通知和设置到此Future Future\u0026lt;Foo\u0026gt; fooFuture = RpcContext.getContext().getFuture(); fooFuture.get(); 或\n// 此调用会立即返回null fooService.findFoo(fooId); // 拿到Dubbo内置的ResponseFuture并设置回调 ResponseFuture future = ((FutureAdapter)RpcContext.getContext().getFuture()).getFuture(); future.setCallback(new ResponseCallback() { @Override public void done(Object response) { System.","text":null,"weight":0},{"authors":null,"date":1535241600,"description":"The first Dubbo meetup has been held in Beijing.","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The fourth Dubbo meetup has been held in Chengdu","lvl1":"blog","lvl2":"/blog/2018/08/26/the-fourth-dubbo-meetup-has-been-held-in-chengdu/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"2270ec5fceb623924624ad87a4cb7ed3","permalink":"/blog/2018/08/26/the-fourth-dubbo-meetup-has-been-held-in-chengdu/","publishdate":"2018-08-26T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/26/the-fourth-dubbo-meetup-has-been-held-in-chengdu/","summary":"","text":null,"weight":0},{"authors":null,"date":1535241600,"description":"第四届Dubbo开发者沙龙于8月26日在成都举行。","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第四届Dubbo开发者沙龙于8月26日在成都举行","lvl1":"blog","lvl2":"/zh/blog/2018/08/26/%E7%AC%AC%E5%9B%9B%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E4%BA%8E8%E6%9C%8826%E6%97%A5%E5%9C%A8%E6%88%90%E9%83%BD%E4%B8%BE%E8%A1%8C/","lvl3":11,"lvl4":"blog","lvl5":null,"objectID":"2270ec5fceb623924624ad87a4cb7ed3","permalink":"/zh/blog/2018/08/26/%E7%AC%AC%E5%9B%9B%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E4%BA%8E8%E6%9C%8826%E6%97%A5%E5%9C%A8%E6%88%90%E9%83%BD%E4%B8%BE%E8%A1%8C/","publishdate":"2018-08-26T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/08/26/%E7%AC%AC%E5%9B%9B%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E4%BA%8E8%E6%9C%8826%E6%97%A5%E5%9C%A8%E6%88%90%E9%83%BD%E4%B8%BE%E8%A1%8C/","summary":"用户深度沟通交流 8.26上午10:00-12:00，邀请到货车帮，云图金控，前BBD，飞鱼星四家公司开源爱好者及重度用户参与面对面交流；据参与者反馈，解答了对Dubbo的诸多疑惑，特别是如何参与贡献社区，以及捐献代码所带来的价值点。希望后面可以更加深入参与Dubbo社区及活动中。\nmeetup活动信息 本次活动依旧爆满，总报名人数976，现场用户350+，直播PV 13207。\n报名信息 Aliware Open Source•成都站-Apache Dubbo开发者沙龙于8月26日(周日)在成都高新区天府五街200号菁蓉国际广场8号楼2楼会议厅举办，技术GG们的思想盛宴，干货与福利一个都不会少。\n报名链接：http://www.huodongxing.com/event/7453091088400","text":null,"weight":0},{"authors":null,"date":1534896000,"description":"在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。本文介绍了Dubbo框架提供的多种错误处理策略，并通过实例说明如何进行配置。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 集群容错","lvl1":"blog","lvl2":"/zh/blog/2018/08/22/dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/","lvl3":262,"lvl4":"blog","lvl5":null,"objectID":"24e22d6f2a5740ffc332e333924c380a","permalink":"/zh/blog/2018/08/22/dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/","publishdate":"2018-08-22T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/08/22/dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/","summary":"Design For failure 在分布式系统中，集群某个某些节点出现问题是大概率事件，因此在设计分布式RPC框架的过程中，必须要把失败作为设计的一等公民来对待。一次调用失败之后，应该如何选择对失败的选择策略，这是一个见仁见智的问题，每种策略可能都有自己独特的应用场景。因此，作为框架来说，应当针对不同场景提供多种策略，供用户进行选择。\n在Dubbo设计中，通过Cluster这个接口的抽象，把一组可供调用的Provider信息组合成为一个统一的Invoker供调用方进行调用。经过路由规则过滤，负载均衡选址后，选中一个具体地址进行调用，如果调用失败，则会按照集群配置的容错策略进行容错处理。\nDubbo默认内置了若干容错策略，如果不能满足用户需求，则可以通过自定义容错策略进行配置。\n内置容错策略 Dubbo主要内置了如下几种策略：\n Failover(失败自动切换) Failsafe(失败安全) Failfast(快速失败) Failback(失败自动恢复) Forking(并行调用) Broadcast(广播调用)  这些名称比较相似，概念也比较容易混淆，下面逐一进行解释。\nFailover(失败自动切换) Failover是高可用系统中的一个常用概念，服务器通常拥有主备两套机器配置，如果主服务器出现故障，则自动切换到备服务器中，从而保证了整体的高可用性。\nDubbo也借鉴了这个思想，并且把它作为Dubbo默认的容错策略。当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。\nDubbo里默认配置的重试次数是2，也就是说，算上第一次调用，最多会调用3次。\n其配置方法，容错策略既可以在服务提供方配置，也可以服务调用方进行配置。而重试次数的配置则更为灵活，既可以在服务级别进行配置，也可以在方法级别进行配置。具体优先顺序为：\n服务调用方方法级配置 \u0026gt; 服务调用方服务级配置 \u0026gt; 服务提供方方法级配置 \u0026gt; 服务提供方服务级配置 以XML方式为例，具体配置方法如下：\n服务提供方，服务级配置\n\u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.demo.DemoService\u0026#34; ref=\u0026#34;demoService\u0026#34; cluster=\u0026#34;failover\u0026#34; retries=\u0026#34;2\u0026#34; /\u0026gt; 服务提供方，方法级配置\n\u0026lt;dubbo:service interface=\u0026#34;org.apache.dubbo.demo.DemoService\u0026#34; ref=\u0026#34;demoService\u0026#34;cluster=\u0026#34;failover\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; retries=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; 服务调用方，服务级配置\n\u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; interface=\u0026#34;org.apache.dubbo.demo.DemoService\u0026#34; cluster=\u0026#34;failover\u0026#34; retries=\u0026#34;1\u0026#34;/\u0026gt; 服务调用方，方法级配置：\n\u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; interface=\u0026#34;org.apache.dubbo.demo.DemoService\u0026#34; cluster=\u0026#34;failover\u0026#34;\u0026gt; \u0026lt;dubbo:method name=\u0026#34;sayHello\u0026#34; retries=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/dubbo:reference\u0026gt; Failover可以自动对失败进行重试，对调用者屏蔽了失败的细节，但是Failover策略也会带来一些副作用：\n 重试会额外增加一下开销，例如增加资源的使用，在高负载系统下，额外的重试可能让系统雪上加霜。 重试会增加调用的响应时间。 某些情况下，重试甚至会造成资源的浪费。考虑一个调用场景，A-\u0026gt;B-\u0026gt;C，如果A处设置了超时100ms，再B-\u0026gt;C的第一次调用完成时已经超过了100ms，但很不幸B-\u0026gt;C失败，这时候会进行重试，但其实这时候重试已经没有意义，因此在A看来这次调用已经超时，A可能已经开始执行其他逻辑。  Failsafe(失败安全) 失败安全策略的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。","text":null,"weight":0},{"authors":null,"date":1534896000,"description":"本文介绍在spring应用里，怎么把Dubbo和Hystrix结合起来使用。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Spring应用快速集成Dubbo + Hystrix","lvl1":"blog","lvl2":"/zh/blog/2018/08/22/spring%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90dubbo-hystrix/","lvl3":356,"lvl4":"blog","lvl5":null,"objectID":"21a18c39559be18c4ce1dd7019d45684","permalink":"/zh/blog/2018/08/22/spring%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90dubbo-hystrix/","publishdate":"2018-08-22T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/08/22/spring%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90dubbo-hystrix/","summary":"背景 Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。\nDubbo是Alibaba开源的，目前国内最流行的java rpc框架。\n本文介绍在spring应用里，怎么把Dubbo和Hystrix结合起来使用。\n https://github.com/Netflix/Hystrix https://github.com/apache/dubbo  Spring Boot应用 Demo地址： https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-boot-hystrix\n生成dubbo集成spring boot的应用 对于不熟悉dubbo 集成spring boot应用的同学，可以在这里直接生成dubbo + spring boot的工程： http://start.dubbo.io/\n配置spring-cloud-starter-netflix-hystrix spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后在Application类上增加@EnableHystrix来启用hystrix starter：\n@SpringBootApplication @EnableHystrix public class ProviderApplication { 配置Provider端 在Dubbo的Provider上增加@HystrixCommand配置，这样子调用就会经过Hystrix代理。\n@Service(version = \u0026#34;1.0.0\u0026#34;) public class HelloServiceImpl implements HelloService { @HystrixCommand(commandProperties = { @HystrixProperty(name = \u0026#34;circuitBreaker.requestVolumeThreshold\u0026#34;, value = \u0026#34;10\u0026#34;), @HystrixProperty(name = \u0026#34;execution.isolation.thread.timeoutInMilliseconds\u0026#34;, value = \u0026#34;2000\u0026#34;) }) @Override public String sayHello(String name) { // System.","text":null,"weight":0},{"authors":null,"date":1534636800,"description":"本文介绍了一种心跳，两种设计\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 现有心跳方案总结以及改进建议","lvl1":"blog","lvl2":"/zh/blog/2018/08/19/dubbo-%E7%8E%B0%E6%9C%89%E5%BF%83%E8%B7%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE/","lvl3":805,"lvl4":"blog","lvl5":null,"objectID":"f840455ad368413ead939deb01000fdd","permalink":"/zh/blog/2018/08/19/dubbo-%E7%8E%B0%E6%9C%89%E5%BF%83%E8%B7%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE/","publishdate":"2018-08-19T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2018/08/19/dubbo-%E7%8E%B0%E6%9C%89%E5%BF%83%E8%B7%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE/","summary":"1 前言 设计一个好的心跳机制并不是一件容易的事，就我所熟知的几个 RPC 框架，它们的心跳机制可以说大相径庭，这篇文章我将探讨一下如何设计一个优雅的心跳机制，主要从 Dubbo 的现有方案以及一个改进方案来做分析。\n2 预备知识 因为后续我们将从源码层面来进行介绍，所以一些服务治理框架的细节还需要提前交代一下，方便大家理解。\n2.1 客户端如何得知请求失败了？ 高性能的 RPC 框架几乎都会选择使用 Netty 来作为通信层的组件，非阻塞式通信的高效不需要我做过多的介绍。但也由于非阻塞的特性，导致其发送数据和接收数据是一个异步的过程，所以当存在服务端异常、网络问题时，客户端是接收不到响应的，那么我们如何判断一次 RPC 调用是失败的呢？\n误区一：Dubbo 调用不是默认同步的吗？\nDubbo 在通信层是异步的，呈现给使用者同步的错觉是因为内部做了阻塞等待，实现了异步转同步。\n误区二： Channel.writeAndFlush 会返回一个 channelFuture，我只需要判断 channelFuture.isSuccess 就可以判断请求是否成功了。\n注意，writeAndFlush 成功并不代表对端接受到了请求，返回值为 true 只能保证写入网络缓冲区成功，并不代表发送成功。\n避开上述两个误区，我们再来回到本小节的标题：客户端如何得知请求失败？正确的逻辑应当是以客户端接收到失败响应为判断依据。等等，前面不还在说在失败的场景中，服务端是不会返回响应的吗？没错，既然服务端不会返回，那就只能客户端自己造了。\n一个常见的设计是：客户端发起一个 RPC 请求，会设置一个超时时间 client_timeout，发起调用的同时，客户端会开启一个延迟 client_timeout 的定时器\n 接收到正常响应时，移除该定时器。 定时器倒计时完毕，还没有被移除，则认为请求超时，构造一个失败的响应传递给客户端。  Dubbo 中的超时判定逻辑：\npublic static DefaultFuture newFuture(Channel channel, Request request, int timeout) { final DefaultFuture future = new DefaultFuture(channel, request, timeout); // timeout check  timeoutCheck(future); return future; } private static void timeoutCheck(DefaultFuture future) { TimeoutCheckTask task = new TimeoutCheckTask(future); TIME_OUT_TIMER.","text":null,"weight":0},{"authors":null,"date":1534291200,"description":"异步化改造,三大中心改造,服务治理增强\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo2.7 三大新特性详解","lvl1":"blog","lvl2":"/zh/blog/2018/08/15/dubbo2.7-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/","lvl3":442,"lvl4":"blog","lvl5":null,"objectID":"f1dfc5e8627f5ca309669c54388ec89f","permalink":"/zh/blog/2018/08/15/dubbo2.7-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/","publishdate":"2018-08-15T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/15/dubbo2.7-%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/","summary":"1 背景介绍 自 2017 年 7 月阿里重启 Dubbo 开源，到目前为止 github star 数，contributor 数都有了非常大的提升。2018 年 2 月 9 日阿里决定将 Dubbo 项目贡献给 Apache，经过一周的投票，顺利成为了 Apache 的孵化项目，也就是大家现在看到的 Incubator Dubbo。预计在 2019 年 4 月，Dubbo 可以达成毕业，成为 Apache 的顶级项目。\n2 分支介绍 Dubbo 目前有如图所示的 5 个分支，其中 2.7.1-release 只是一个临时分支，忽略不计，对其他 4 个分支进行介绍。\n 2.5.x 近期已经通过投票，Dubbo 社区即将停止对其的维护。 2.6.x 为长期支持的版本，也是 Dubbo 贡献给 Apache 之前的版本，其包名前缀为：com.alibaba，JDK 版本对应 1.6。 3.x-dev 是前瞻性的版本，对 Dubbo 进行一些高级特性的补充，如支持 rx 特性。 master 为长期支持的版本，版本号为 2.7.x，也是 Dubbo 贡献给 Apache 的开发版本，其包名前缀为：org.apache，JDK 版本对应 1.8。   如果想要研究 Dubbo 的源码，建议直接浏览 master 分支。","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article will introduce you the basics of consumer configurations.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":" Dubbo Basic Usage - Dubbo Consumer Configuration","lvl1":"blog","lvl2":"/blog/2018/08/14/dubbo-basic-usage-dubbo-consumer-configuration/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"a1b10a0ad0fcb73b8f029eb44adc5411","permalink":"/blog/2018/08/14/dubbo-basic-usage-dubbo-consumer-configuration/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/dubbo-basic-usage-dubbo-consumer-configuration/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article introduces you how to use Dubbo synchronously or asynchronously.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo: Several ways about synchronous/asynchronous invoke","lvl1":"blog","lvl2":"/blog/2018/08/14/dubbo-several-ways-about-synchronous/asynchronous-invoke/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"88e41d0f0bdc482798b02e61f31b2074","permalink":"/blog/2018/08/14/dubbo-several-ways-about-synchronous/asynchronous-invoke/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/dubbo-several-ways-about-synchronous/asynchronous-invoke/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article will introduce you how to config Dubbo, by XML, property files, annotations or Java code.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo Basic Usage -- Dubbo Provider Configuration","lvl1":"blog","lvl2":"/blog/2018/08/14/dubbo-basic-usage-dubbo-provider-configuration/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"16226f9e3e31cee5fcfd926fd2a267e0","permalink":"/blog/2018/08/14/dubbo-basic-usage-dubbo-provider-configuration/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/dubbo-basic-usage-dubbo-provider-configuration/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article introduces how to use Dubbo's QoS to achieve dynamic configuration.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Manipulating Services Dynamically via QoS","lvl1":"blog","lvl2":"/blog/2018/08/14/manipulating-services-dynamically-via-qos/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"daf35202336a231b9d24fae4449959b5","permalink":"/blog/2018/08/14/manipulating-services-dynamically-via-qos/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/manipulating-services-dynamically-via-qos/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article introduces the implementation details of app start and stop in `dubbo-spring-boot-project`.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Source code analysis of spring-boot+Dubbo App start and stop","lvl1":"blog","lvl2":"/blog/2018/08/14/source-code-analysis-of-spring-boot-dubbo-app-start-and-stop/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"df9fbd9a5d9b3f52f7a91ba679551325","permalink":"/blog/2018/08/14/source-code-analysis-of-spring-boot-dubbo-app-start-and-stop/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/source-code-analysis-of-spring-boot-dubbo-app-start-and-stop/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文介绍了Dubbo优雅停机的原理和使用方式\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 优雅停机","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/dubbo-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/","lvl3":121,"lvl4":"blog","lvl5":null,"objectID":"b1fd982e43cbf4ca17efc20e7ba6ebc2","permalink":"/zh/blog/2018/08/14/dubbo-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/","publishdate":"2018-08-14T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/08/14/dubbo-%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/","summary":"背景 对于任何一个线上应用，如何在服务更新部署过程中保证客户端无感知是开发者必须要解决的问题，即从应用停止到重启恢复服务这个阶段不能影响正常的业务请求。理想条件下，在没有请求的时候再进行更新是最安全可靠的，然而互联网应用必须要保证可用性，因此在技术层面上优化应用更新流程来保证服务在更新时无损是必要的。\n传统的解决方式是通过将应用更新流程划分为手工摘流量、停应用、更新重启三个步骤，由人工操作实现客户端无对更新感知。这种方式简单而有效，但是限制较多：不仅需要使用借助网关的支持来摘流量，还需要在停应用前人工判断来保证在途请求已经处理完毕。这种需要人工介入的方式运维复杂度较高，只能适用规模较小的应用，无法在大规模系统上使用。\n因此，如果在容器/框架级别提供某种自动化机制，来自动进行摘流量并确保处理完以到达的请求，不仅能保证业务不受更新影响，还可以极大地提升更新应用时的运维效率。\n这个机制也就是优雅停机，目前Tomcat/Undertow/Dubbo等容器/框架都有提供相关实现。下面给出正式一些的定义：优雅停机是指在停止应用时，执行的一系列保证应用正常关闭的操作。这些操作往往包括等待已有请求执行完成、关闭线程、关闭连接和释放资源等，优雅停机可以避免非正常关闭程序可能造成数据异常或丢失，应用异常等问题。优雅停机本质上是JVM即将关闭前执行的一些额外的处理代码。\n适用场景  JVM主动关闭(System.exit(int)； JVM由于资源问题退出(OOM)； 应用程序接受到SIGTERM或SIGINT信号。  配置方式 服务的优雅停机 在Dubbo中，优雅停机是默认开启的，停机等待时间为10000毫秒。可以通过配置dubbo.service.shutdown.wait来修改等待时间。\n例如将等待时间设置为20秒可通过增加以下配置实现：\ndubbo.service.shutdown.wait=20000 容器的优雅停机 当使用org.apache.dubbo.container.Main这种容器方式来使用 Dubbo 时，也可以通过配置dubbo.shutdown.hook为true来开启优雅停机。\n通过QOS优雅上下线 基于ShutdownHook方式的优雅停机无法确保所有关闭流程一定执行完，所以 Dubbo 推出了多段关闭的方式来保证服务完全无损。\n多段关闭即将停止应用分为多个步骤，通过运维自动化脚本或手工操作的方式来保证脚本每一阶段都能执行完毕。\n在关闭应用前，首先通过 QOS 的offline指令下线所有服务，然后等待一定时间确保已经到达请求全部处理完毕，由于服务已经在注册中心下线，当前应用不会有新的请求。这时再执行真正的关闭(SIGTERM 或 SIGINT)流程，就能保证服务无损。\nQOS可通过 telnet 或 HTTP 方式使用，具体方式请见Dubbo-QOS命令使用说明。\n流程 Provider在接收到停机指令后\n 从注册中心上注销所有服务； 从配置中心取消监听动态配置； 向所有连接的客户端发送只读事件，停止接收新请求； 等待一段时间以处理已到达的请求，然后关闭请求处理线程池； 断开所有客户端连接。  Consumer在接收到停机指令后\n 拒绝新到请求，直接返回调用异常； 等待当前已发送请求执行完毕，如果响应超时则强制关闭连接。  当使用容器方式运行 Dubbo 时，在容器准备退出前，可进行一系列的资源释放和清理工。\n例如使用 SpringContainer时，Dubbo 的ShutdownHook线程会执行ApplicationContext的stop和close方法，保证 Bean的生命周期完整。\n实现原理   在加载类org.apache.dubbo.config.AbstractConfig时，通过org.apache.dubbo.config.DubboShutdownHook向JVM注册 ShutdownHook。\n/** * Register the ShutdownHook */ public void register() { if (!","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文介绍了Dubbo基于异步通讯机制实现的几种同步和异步调用方式。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 关于同步/异步调用的几种方式","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/dubbo-%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","lvl3":438,"lvl4":"blog","lvl5":null,"objectID":"88e41d0f0bdc482798b02e61f31b2074","permalink":"/zh/blog/2018/08/14/dubbo-%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","publishdate":"2018-08-14T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/14/dubbo-%E5%85%B3%E4%BA%8E%E5%90%8C%E6%AD%A5/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","summary":"我们知道，Dubbo 缺省协议采用单一长连接，底层实现是 Netty 的 NIO 异步通讯机制；基于这种机制，Dubbo 实现了以下几种调用方式：\n 同步调用 异步调用 参数回调 事件通知  同步调用 同步调用是一种阻塞式的调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止；\n通常，一个典型的同步调用过程如下：\n Consumer 业务线程调用远程接口，向 Provider 发送请求，同时当前线程处于阻塞状态； Provider 接到 Consumer 的请求后，开始处理请求，将结果返回给 Consumer； Consumer 收到结果后，当前线程继续往后执行。  这里有 2 个问题：\n Consumer 业务线程是怎么进入阻塞状态的？ Consumer 收到结果后，如何唤醒业务线程往后执行的？  其实，Dubbo 的底层 IO 操作都是异步的。Consumer 端发起调用后，得到一个 Future 对象。对于同步调用，业务线程通过Future#get(timeout)，阻塞等待 Provider 端将结果返回；timeout则是 Consumer 端定义的超时时间。当结果返回后，会设置到此 Future，并唤醒阻塞的业务线程；当超时时间到结果还未返回时，业务线程将会异常返回。\n异步调用 基于 Dubbo 底层的异步 NIO 实现异步调用，对于 Provider 响应时间较长的场景是必须的，它能有效利用 Consumer 端的资源，相对于 Consumer 端使用多线程来说开销较小。\n异步调用，对于 Provider 端不需要做特别的配置。下面的例子中，Provider 端接口定义如下：","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"XML配置，API调用方式配置，注解方式配置\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 基本用法 - Dubbo Consumer 配置","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-dubbo-consumer-%E9%85%8D%E7%BD%AE/","lvl3":244,"lvl4":"blog","lvl5":null,"objectID":"a1b10a0ad0fcb73b8f029eb44adc5411","permalink":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-dubbo-consumer-%E9%85%8D%E7%BD%AE/","publishdate":"2018-08-14T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-dubbo-consumer-%E9%85%8D%E7%BD%AE/","summary":"Dubbo Consumer配置 Consumer配置详解 配置Dubbo Consumer有3种方式：XML配置，API调用方式配置，注解方式配置。\nXML配置 最简单的配置的样例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;hello-world-app\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;multicast://224.5.6.7:1234\u0026#34; /\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20880\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoServiceRemote\u0026#34; interface=\u0026#34;com.alibaba.dubbo.demo.DemoService\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt;  支持的配置标签及对应的配置项详解，参考provider中的用法。\n  接下来重点讲解下\u0026lt;dubbo:reference/\u0026gt;的配置。\n  \u0026lt;dubbo:reference/\u0026gt;支持的主要属性列表：     属性名 说明     id 服务引用id，作为java bean id，需要唯一   interface 接口名，用于查找服务   version 版本号，与服务提供者的版本一致   timeout 服务方法调用超时时间(毫秒)   retries 远程服务调用重试次数，不包括第一次调用，不需要重试请设为0   connections 对每个提供者的最大连接数，rmi、http、hessian等短连接协议表示限制连接数，dubbo等长连接协表示建立的长连接个数   loadbalance 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮询，最少活跃调用   async 是否异步执行，不可靠异步，只是忽略返回值，不阻塞执行线程   generic 泛化调用，可以绕过   check 启动时检查提供者是否存在，true报错，false忽略   actives 每服务消费者每服务每方法最大并发调用数    其他配置属性请参考xsd：http://dubbo.","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"主要讲述如何配置dubbo，按照配置方式上可以分为：XML配置，properties方式配置，注解方式配置，API调用方式配置。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 基础用法 - Provider 配置","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-provider-%E9%85%8D%E7%BD%AE/","lvl3":466,"lvl4":"blog","lvl5":null,"objectID":"16226f9e3e31cee5fcfd926fd2a267e0","permalink":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-provider-%E9%85%8D%E7%BD%AE/","publishdate":"2018-08-14T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/14/dubbo-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95-provider-%E9%85%8D%E7%BD%AE/","summary":"Dubbo基本用法 本章节主要讲述如何配置dubbo，按照配置方式上分，可以分为：XML配置，properties方式配置，注解方式配置，API调用方式配置。 按照功能角度进行划分，可以分为Dubbo Provider和Dubbo Consumer。接下来章节中，分别对dubbo provider和Dubbo consumer进行讲解。\nDubbo Provider配置 Provider 配置详解 配置Dubbo Provider有4种方式：XML配置，properties方式配置，API调用方式配置，注解方式配置。\nXML配置 最简单的配置的样例： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;hello-world-app\u0026#34; /\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;multicast://224.5.6.7:1234\u0026#34; /\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20880\u0026#34; /\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;com.alibaba.dubbo.demo.DemoService\u0026#34; ref=\u0026#34;demoServiceLocal\u0026#34; /\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;demoServiceRemote\u0026#34; interface=\u0026#34;com.alibaba.dubbo.demo.DemoService\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 上面样例中，注意下dubbo schema的写法：\n\u0026lt;beans xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://code.alibabatech.com/schema/dubbo\u0026#34; xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; 支持的配置标签    标签 用途 解释     \u0026lt;dubbo:service/\u0026gt; 服务配置 用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心   \u0026lt;dubbo:reference/\u0026gt; 引用配置 用于创建一个远程服务代理，一个引用可以指向多个注册中心   \u0026lt;dubbo:protocol/\u0026gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受   \u0026lt;dubbo:application/\u0026gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者   \u0026lt;dubbo:module/\u0026gt; 模块配置 用于配置当前模块信息，可选   \u0026lt;dubbo:registry/\u0026gt; 注册中心配置 用于配置连接注册中心相关信息   \u0026lt;dubbo:monitor/\u0026gt; 监控中心配置 用于配置连接监控中心相关信息，可选   \u0026lt;dubbo:provider/\u0026gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选   \u0026lt;dubbo:consumer/\u0026gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选   \u0026lt;dubbo:method/\u0026gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息   \u0026lt;dubbo:argument/\u0026gt; 参数配置 用于指定方法参数配置    配置项详解   \u0026lt;dubbo:application name=\u0026ldquo;hello-world-app\u0026rdquo; /\u0026gt;","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article introduces how to use Dubbo.js to implement cross-language calls.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Implementation of cross-language calls by Dubbo2.js","lvl1":"blog","lvl2":"/blog/2018/08/14/implementation-of-cross-language-calls-by-dubbo2.js/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"fdad666e84829ec800642320e01d014c","permalink":"/blog/2018/08/14/implementation-of-cross-language-calls-by-dubbo2.js/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/implementation-of-cross-language-calls-by-dubbo2.js/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文介绍了 Dubbo 泛化调用的使用场景及相关示例\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo的泛化调用","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/dubbo%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/","lvl3":345,"lvl4":"blog","lvl5":null,"objectID":"e9fed8cbe52caa35d0e4b021f6915311","permalink":"/zh/blog/2018/08/14/dubbo%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/","publishdate":"2018-08-14T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/08/14/dubbo%E7%9A%84%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/","summary":"以下几种场景可以考虑使用泛化调用：\n 服务测试平台 API 服务网关  泛化调用主要用于消费端没有 API 接口的情况；不需要引入接口 jar 包，而是直接通过 GenericService 接口来发起服务调用，参数及返回值中的所有 POJO 均用 Map 表示。泛化调用对于服务端无需关注，按正常服务进行暴露即可。\n下面来看看消费端如何使用泛化调用进行服务调用。\n通过 Spring XML 配置进行泛化调用 在 Spring 配置申明 generic=\u0026quot;true\u0026quot;，如：\n\u0026lt;dubbo:reference id=\u0026#34;userService\u0026#34; interface=\u0026#34;com.alibaba.dubbo.samples.generic.api.IUserService\u0026#34; generic=\u0026#34;true\u0026#34;/\u0026gt; 需要使用的地方，通过强制类型转化为 GenericService 进行调用：\nGenericService userService = (GenericService) context.getBean(\u0026#34;userService\u0026#34;); // primary param and return value String name = (String) userService.$invoke(\u0026#34;delete\u0026#34;, new String[]{int.class.getName()}, new Object[]{1}); System.out.println(name); 其中：\n GenericService 这个接口只有一个方法，名为 $invoke，它接受三个参数，分别为方法名、方法参数类型数组和参数值数组； 对于方法参数类型数组  如果是基本类型，如 int 或 long，可以使用 int.class.getName()获取其类型； 如果是基本类型数组，如 int[]，则可以使用 int[].class.getName()； 如果是 POJO，则直接使用全类名，如 com.","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"This article introduces you when and how to use generic invoke of Dubbo.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Generic invoke of Dubbo","lvl1":"blog","lvl2":"/blog/2018/08/14/generic-invoke-of-dubbo/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"e9fed8cbe52caa35d0e4b021f6915311","permalink":"/blog/2018/08/14/generic-invoke-of-dubbo/","publishdate":"2018-08-14T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/14/generic-invoke-of-dubbo/","summary":"","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文分析 `dubbo-spring-boot-project` 中 Dubbo 启停源码的实现原理。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Spring Boot Dubbo应用启停源码分析","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/spring-boot-dubbo%E5%BA%94%E7%94%A8%E5%90%AF%E5%81%9C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","lvl3":534,"lvl4":"blog","lvl5":null,"objectID":"df9fbd9a5d9b3f52f7a91ba679551325","permalink":"/zh/blog/2018/08/14/spring-boot-dubbo%E5%BA%94%E7%94%A8%E5%90%AF%E5%81%9C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2018-08-14T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/14/spring-boot-dubbo%E5%BA%94%E7%94%A8%E5%90%AF%E5%81%9C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","summary":"背景介绍 Dubbo Spring Boot 工程致力于简化 Dubbo RPC 框架在Spring Boot应用场景的开发。同时也整合了 Spring Boot 特性：\n 自动装配 (比如： 注解驱动, 自动装配等). Production-Ready (比如： 安全, 健康检查, 外部化配置等).  DubboConsumer启动分析 你有没有想过一个问题？dubbo-spring-boot-project中的DubboConsumerDemo应用就一行代码，main方法执行完之后，为什么不会直接退出呢？\n@SpringBootApplication(scanBasePackages = \u0026#34;com.alibaba.boot.dubbo.demo.consumer.controller\u0026#34;) public class DubboConsumerDemo { public static void main(String[] args) { SpringApplication.run(DubboConsumerDemo.class,args); } } 其实要回答这样一个问题，我们首先需要把这个问题进行一个抽象，即一个JVM进程，在什么情况下会退出？\n以Java 8为例，通过查阅JVM语言规范[1]，在12.8章节中有清晰的描述：\nA program terminates all its activity and exits when one of two things happens:\n All the threads that are not daemon threads terminate. Some thread invokes the exit method of class Runtime or class System, and the exit operation is not forbidden by the security manager.","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文介绍了如何使用 dubbo2.js 进行跨语言的 dubbo 调用。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"从跨语言调用到dubbo2.js","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/%E4%BB%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%88%B0dubbo2.js/","lvl3":638,"lvl4":"blog","lvl5":null,"objectID":"fdad666e84829ec800642320e01d014c","permalink":"/zh/blog/2018/08/14/%E4%BB%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%88%B0dubbo2.js/","publishdate":"2018-08-14T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/14/%E4%BB%8E%E8%B7%A8%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%88%B0dubbo2.js/","summary":"dubbo2.js 是 千米网 贡献给 dubbo 社区的一款 nodejs dubbo 客户端，它提供了 nodejs 对原生 dubbo 协议的支持，使得 nodejs 和 java 这两种异构语言的 rpc 调用变得便捷，高效。\n 微服务跨语言调用 微服务架构已成为目前互联网架构的趋势，关于微服务的讨论，几乎占据了各种技术大会的绝大多数版面。国内使用最多的服务治理框架非阿里开源的 dubbo 莫属，千米网也选择了 dubbo 作为微服务治理框架。另一方面，和大多数互联网公司一样，千米的开发语言是多样的，大多数后端业务由 java 支撑，而每个业务线有各自开发语言的选择权，便出现了 nodejs，python，go 多语言调用的问题。 跨语言调用是一个很大的话题，也是一个很有挑战的技术活，目前业界经常被提及的解决方案有如下几种，不妨拿出来老生常谈一番：\n spring cloud。spring cloud 提供了一整套微服务开发组件，它主要面向 java 开发，但由于其使用的协议是基于 restful 风格的 http 协议，这使得其天然具备跨语言能力，异构语言只需要提供 http 客户端，便可以实现跨语言调用。 service mesh。号称下一代微服务框架的 service mesh，其解决跨语言问题的核心在于 SideCar ，SideCar 在 service mesh 的发展过程中概念不断的迁移，但本质都是完成了一件事：处理服务间通信，负责实现请求的可靠传递。 motan。motan 是新浪微博开源的一款跨语言服务治理框架，在其早期版本中仅支持 motan-java，随着版本演进，在目前最新版本(1.1.0)中，提供了 motan-go，motan-php，motan-openresty 等跨语言特性。类似于 service mesh 中的 SideCar，motan 借助于 motan-go 作为 agent 完成协议的转发，并且依赖于定制协议：motan2，实现跨语言调用。  当我们再聊跨语言调用时我们在聊什么？纵观上述几个较为通用，成熟的解决方案，可以得出结论：解决跨语言调用的思路无非是两种：","text":null,"weight":0},{"authors":null,"date":1534204800,"description":"本文介绍了如何使用Dubbo的QoS功能对服务进行动态配置，以及相关的参数及配置方式。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"通过QoS对服务进行动态控制","lvl1":"blog","lvl2":"/zh/blog/2018/08/14/%E9%80%9A%E8%BF%87qos%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/","lvl3":365,"lvl4":"blog","lvl5":null,"objectID":"daf35202336a231b9d24fae4449959b5","permalink":"/zh/blog/2018/08/14/%E9%80%9A%E8%BF%87qos%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/","publishdate":"2018-08-14T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/08/14/%E9%80%9A%E8%BF%87qos%E5%AF%B9%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E6%8E%A7%E5%88%B6/","summary":"QoS，全称为Quality of Service, 是常见于网络设备中的一个术语 ，例如在路由器中，可以通过Qos动态的调整和控制某些端口的权重，从而优先的保障运行在这些端口上的服务质量。\n在Dubbo中，QoS这个概念被用于动态的对服务进行查询和控制。例如对获取当前提供和消费的所有服务，以及对服务进行动态的上下线，即从注册中心上进行注册和反注册操作。\nQoS工作机制 从Dubbo 2.5.8开始，默认引入了Qos功能，默认处于启动状态。所有的QoS功能被抽象成一个个的命令，通过执行这些命令，Qos会返回响应的结果。\n Qos功能基于Netty4实现，在Dubbo 2.6.x之前的版本中，默认依赖的是Netty3，因此需要显示的添加Netty4的依赖，才能确保Netty4正常工作。如果使用http://start.dubbo.io自动生成的Dubbo应用，则无需添加额外的配置，因为已经默认加上了Netty4的依赖。\n Qos的工作机制如下图所示：\n 启动并监听一个端口，默认端口是22222 识别目标请求的协议是Http或者是Telnet，根据协议不同动态添加对应的处理器 针对不同的协议进行解码，解析出需要执行的命令 执行命令并返回结果  QoS命令 QoS目前支持的命令包括：\n help: 帮助命令，列出 ls: 列出当前所有的正在提供的服务，以及消费的服务 online: 动态将某个或全部服务向注册中心进行注册 offline: 动态将某个或全部服务从注册中心摘除（反注册） quit: 退出当前telnet会话  下面，我们具体来操作一下如何通过用QoS对服务进行动态控制。\n通过Telnet方式访问QoS 假设我们的Dubbo服务端已经启动，我们通过Telnet方式进行连接：\n$ telnet localhost 22222 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. ????????? ??? ?? ??????????? ??????????? ???????? ??? ???? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ?","text":null,"weight":0},{"authors":null,"date":1533859200,"description":"This article introduces you what is load balance and how load balance strategy is implemented in Dubbo.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo's Load Balance","lvl1":"blog","lvl2":"/blog/2018/08/10/dubbos-load-balance/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"e65d6c054a1521a8df553ca36aa567ae","permalink":"/blog/2018/08/10/dubbos-load-balance/","publishdate":"2018-08-10T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/10/dubbos-load-balance/","summary":"","text":null,"weight":0},{"authors":null,"date":1533859200,"description":"本文介绍了负载均衡的相关概念以及 Dubbo 中的负载均衡策略实现。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo的负载均衡","lvl1":"blog","lvl2":"/zh/blog/2018/08/10/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","lvl3":471,"lvl4":"blog","lvl5":null,"objectID":"e65d6c054a1521a8df553ca36aa567ae","permalink":"/zh/blog/2018/08/10/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","publishdate":"2018-08-10T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/08/10/dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","summary":"背景 Dubbo是一个分布式服务框架，能避免单点故障和支持服务的横向扩容。一个服务通常会部署多个实例。如何从多个服务 Provider 组成的集群中挑选出一个进行调用，就涉及到一个负载均衡的策略。\n几个概念 在讨论负载均衡之前，我想先解释一下这3个概念。\n 负载均衡 集群容错 服务路由  这3个概念容易混淆。他们都描述了怎么从多个 Provider 中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。\n有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:\n 根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个 Provider。 根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。 结果调用第7个 Provider 失败了。 根据配置的Failover集群容错模式，重试其他服务器。 重试了第13个 Provider，调用成功。  上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个 Provider 中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个 Provider 进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡，最后是集群容错。 本文档只讨论负载均衡，路由和集群容错在其他的文档中进行说明。\nDubbo内置负载均衡策略 Dubbo内置了4种负载均衡策略:\n RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。 RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。 LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。 ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。  1.随机负载均衡 顾名思义，随机负载均衡策略就是从多个 Provider 中随机选择一个。但是 Dubbo 中的随机负载均衡有一个权重的概念，即按照权重设置随机概率。比如说，有10个 Provider，并不是说，每个 Provider 的概率都是一样的，而是要结合这10个 Provider 的权重来分配概率。\nDubbo中，可以对 Provider 设置权重。比如机器性能好的，可以设置大一点的权重，性能差的，可以设置小一点的权重。权重会对负载均衡产生影响。可以在Dubbo Admin中对 Provider 进行权重的设置。\n基于权重的负载均衡算法\n随机策略会先判断所有的 Invoker 的权重是不是一样的，如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个 Invoker 的序号,根据序号选择对应的 Invoker 。如果没有在Dubbo Admin中对服务 Provider 设置权重，那么所有的 Invoker 的权重就是一样的，默认是100。 如果权重不一样，那就需要结合权重来设置随机概率了。算法大概如下： 假如有4个 Invoker。","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"介绍了 Dubbo 中新引入的注解驱动支持\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 注解驱动","lvl1":"blog","lvl2":"/zh/blog/2018/08/07/dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/","lvl3":1333,"lvl4":"blog","lvl5":null,"objectID":"ecadf9bcf8de88e448b3fcb6ae208de7","permalink":"/zh/blog/2018/08/07/dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/","publishdate":"2018-08-07T00:00:00Z","readingtime":7,"relpermalink":"/zh/blog/2018/08/07/dubbo-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/","summary":"注解驱动（Annotation-Driven） @DubboComponentScan 起始版本： 2.5.7 \u0026lt;dubbo:annotation\u0026gt; 历史遗留问题 1. 注解支持不充分 在 Dubbo 2.5.7之前的版本 ，Dubbo 提供了两个核心注解 @Service 以及 @Reference，分别用于Dubbo 服务提供和 Dubbo 服务引用。\n其中，@Service 作为 XML 元素 \u0026lt;dubbo:service\u0026gt;的替代注解，与 Spring Framework @org.springframework.stereotype.Service 类似，用于服务提供方 Dubbo 服务暴露。与之相对应的@Reference，则是替代\u0026lt;dubbo:reference 元素，类似于 Spring 中的 @Autowired。 2.5.7 之前的Dubbo，与早期的 Spring Framework 2.5 存在类似的不足，即注解支持不够充分。注解需要和 XML 配置文件配合使用，如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://code.alibabatech.com/schema/dubbo\u0026#34; xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;dubbo:application name=\u0026#34;annotation-provider\u0026#34;/\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;127.0.0.1:4548\u0026#34;/\u0026gt; \u0026lt;dubbo:annotation package=\u0026#34;com.alibaba.dubbo.config.spring.annotation.provider\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 2. @Service Bean 不支持 Spring AOP 同时，使用 \u0026lt;dubbo:annotation\u0026gt;  方式扫描后的Dubbo @Service ，在 Spring 代理方面存在问题，如 GitHub 上的 issue https://github.","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"This article will introduce you how to use annotations instead of XML to develop Dubbo applications, such as `@EnableDubbo`, `@Service` and `@Reference`.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Use Annotations In Dubbo","lvl1":"blog","lvl2":"/blog/2018/08/07/use-annotations-in-dubbo/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"75f093c8d30844dc5689fc0c6ecbeaf5","permalink":"/blog/2018/08/07/use-annotations-in-dubbo/","publishdate":"2018-08-07T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/07/use-annotations-in-dubbo/","summary":"","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"This article introduces basic concepts of Zookeeper, and how to use Zookeeper as a registry center.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Using Zookeeper in Dubbo","lvl1":"blog","lvl2":"/blog/2018/08/07/using-zookeeper-in-dubbo/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"d9102e221bee150274e1c35aaf40005a","permalink":"/blog/2018/08/07/using-zookeeper-in-dubbo/","publishdate":"2018-08-07T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/07/using-zookeeper-in-dubbo/","summary":"","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"Modern distributed frameworks is similiar to RMI in terms of concepts. They both use Java interface as a service contract, archive service registry and discovery by a registry center, and Shield communication details by a proxy.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Your First Dubbo Demo","lvl1":"blog","lvl2":"/blog/2018/08/07/dubbo-101/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"60d180baf428a8c76570d02952c1f1c5","permalink":"/blog/2018/08/07/dubbo-101/","publishdate":"2018-08-07T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/08/07/dubbo-101/","summary":"","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"介绍了如何使用注解方式而非 XML 方式来开发 Dubbo 应用，可以学习到如何使用 @EnableDubbo、@Service、@Reference 的用法。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在 Dubbo 中使用注解","lvl1":"blog","lvl2":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/","lvl3":994,"lvl4":"blog","lvl5":null,"objectID":"75f093c8d30844dc5689fc0c6ecbeaf5","permalink":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/","publishdate":"2018-08-07T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/","summary":"在 Dubbo 中使用注解 随着微服务架构的广泛地推广和实施。在 Java 生态系统中，以 Spring Boot 和 Spring Cloud 为代表的微服务框架，引入了全新的编程模型，包括：\n 注解驱动（Annotation-Driven） 外部化配置（External Configuration） 以及自动装配（Auto-Configure）  新的编程模型无需 XML 配置、简化部署、提升开发效率。为了更好地实践微服务架构，Dubbo 从 2.5.8 版本开始， 分别针对了上述的三个场景，提供了更完善的支持。本文不讨论传统的 XML 配置方式，而是侧重介绍注解这种方式。外部配置、自动装配两种自动装配会在另外的文章中专门介绍。\n注解介绍 @EnableDubbo @EnableDubbo 注解是 @EnableDubboConfig 和 @DubboComponentScan两者组合的便捷表达方式。与注解驱动相关的是 @DubboComponentScan。\npackage org.apache.dubbo.config.spring.context.annotation; @EnableDubboConfig @DubboComponentScan public @interface EnableDubbo { /** * Base packages to scan for annotated @Service classes. * \u0026lt;p\u0026gt; * Use {@link #scanBasePackageClasses()} for a type-safe alternative to String-based * package names. * * @return the base packages to scan * @see DubboComponentScan#basePackages() */ @AliasFor(annotation = DubboComponentScan.","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"本文介绍了 Zookeeper 的基本概念、用法，以及如何在 Dubbo 应用中使用 Zookeeper 作为注册中心。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在 Dubbo 应用中使用 Zookeeper","lvl1":"blog","lvl2":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-zookeeper/","lvl3":813,"lvl4":"blog","lvl5":null,"objectID":"d9102e221bee150274e1c35aaf40005a","permalink":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-zookeeper/","publishdate":"2018-08-07T00:00:00Z","readingtime":4,"relpermalink":"/zh/blog/2018/08/07/%E5%9C%A8-dubbo-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-zookeeper/","summary":"Zookeeper 介绍 基本概念 在现代的分布式应用中，往往会出现节点和节点之间的协调问题，其中就包括了：选主、集群管理、分布式锁、分布式配置管理、统一命名服务、状态同步等诉求。Apache Zookeeper，正如它的名字所暗示的那样，动物园管理员，就是为了解决这些诉求的一个分布式协调服务框架。\n为了保证高可用，ZooKeeper 本身也可以部署成集群模式，称之为 ZooKeeper ensemble。ZooKeeper 集群中始终确保其中的一台为 leader 的角色，并通过 ZAB (Zookeeper Atomic Broadcast Protocol) 1 协议确保所有节点上的信息的一致。客户端可以访问集群中的任何一台进行读写操作，而不用担心数据出现不一致的现象。\nImage Credit : ebook -Zookeeper-Distributed Process Coordination from O\u0026rsquo;Reilly\nZookeeper 中的数据存储方式与传统的 UNIX 文件系统相似，节点按照树状结构来组织，其中，节点被称之为 znodes (ZooKeeper data nodes)\nImage Credit : ebook -Zookeeper-Distributed Process Coordination from O\u0026rsquo;Reilly\n基本用法 可以通过直接下载的方式 2安装并运行 Zookeeper ，在 Mac 上也可以通过 Homebrew 3 brew install zookeeper 来安装，考虑到通用性，本文采用 docker 的方式来运行 Zookeeper。如果没有安装 docker，请先准备好 docker 环境 4。\n1. 启动 Zookeeper 执行命令将 Zookeeper 运行在 docker 容器中","text":null,"weight":0},{"authors":null,"date":1533600000,"description":"现代的分布式服务框架的基本概念与 RMI 是类似的，同样是使用 Java 的 Interface 作为服务契约，通过注册中心来完成服务的注册和发现，远程通讯的细节也是通过代理类来屏蔽。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第一个 Dubbo 应用","lvl1":"blog","lvl2":"/zh/blog/2018/08/07/dubbo-101/","lvl3":1017,"lvl4":"blog","lvl5":null,"objectID":"60d180baf428a8c76570d02952c1f1c5","permalink":"/zh/blog/2018/08/07/dubbo-101/","publishdate":"2018-08-07T00:00:00Z","readingtime":5,"relpermalink":"/zh/blog/2018/08/07/dubbo-101/","summary":"Java RMI 简介 Java RMI （Remote Method Invocation）- 远程方法调用，能够让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过依赖接口这种更简单自然的方式。\nJava RMI 工作原理 一个典型的 RMI 调用如下图所示：\n 服务端向 RMI 注册服务绑定自己的地址， 客户端通过 RMI 注册服务获取目标地址， 客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致， 本地存根对象将调用信息打包，通过网络发送到服务端， 服务端的 Skeleton 对象收到网络请求之后，将调用信息解包， 然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。  (来源：https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-rmi_flow.png)\nJava RMI 基本概念 Java RMI 是 Java 领域创建分布式应用的技术基石。后续的 EJB 技术，以及现代的分布式服务框架，其中的基本理念依旧是 Java RMI 的延续。在 RMI 调用中，有以下几个核心的概念：\n  通过接口进行远程调用\n  通过客户端的 Stub 对象和服务端的 Skeleton 对象的帮助将远程调用伪装成本地调用\n  通过 RMI 注册服务完成服务的注册和发现","text":null,"weight":0},{"authors":null,"date":1532908800,"description":"The third Dubbo meetup has been held in Shenzhen","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The third Dubbo meetup has been held in Shenzhen","lvl1":"blog","lvl2":"/blog/2018/07/30/the-third-dubbo-meetup-has-been-held-in-shenzhen/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"1e75b66ae63451f2bd31326a19bf101f","permalink":"/blog/2018/07/30/the-third-dubbo-meetup-has-been-held-in-shenzhen/","publishdate":"2018-07-30T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/07/30/the-third-dubbo-meetup-has-been-held-in-shenzhen/","summary":"","text":null,"weight":0},{"authors":null,"date":1532908800,"description":"第三届Dubbo开发者沙龙在深圳成功举办","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第三届Dubbo开发者沙龙在深圳成功举办","lvl1":"blog","lvl2":"/zh/blog/2018/07/30/%E7%AC%AC%E4%B8%89%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%B7%B1%E5%9C%B3%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","lvl3":8,"lvl4":"blog","lvl5":null,"objectID":"1e75b66ae63451f2bd31326a19bf101f","permalink":"/zh/blog/2018/07/30/%E7%AC%AC%E4%B8%89%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%B7%B1%E5%9C%B3%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","publishdate":"2018-07-30T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/07/30/%E7%AC%AC%E4%B8%89%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E6%B7%B1%E5%9C%B3%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","summary":"第三届Dubbo开发者沙龙在深圳成功举办，超过2000位开发者报名，现场参与人数700+，通过阿里云天池、云栖社区、大咖说引导线上直播观看次数17000+\n分享嘉宾\n 陈志轩: Dubbo开源现状和2.7规划 康彬: 乐信集团的微服务化之路 林佳梁: Sentinel——企业用户的全方位流量哨兵  ","text":null,"weight":0},{"authors":null,"date":1532649600,"description":"This article introduces the Sentinel and how to integrate it with Dubbo.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Sentinel: The flow sentinel of Dubbo services","lvl1":"blog","lvl2":"/blog/2018/07/27/sentinel-the-flow-sentinel-of-dubbo-services/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"99e01590eeed2113a9a3e5f17d38784b","permalink":"/blog/2018/07/27/sentinel-the-flow-sentinel-of-dubbo-services/","publishdate":"2018-07-27T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/07/27/sentinel-the-flow-sentinel-of-dubbo-services/","summary":"","text":null,"weight":0},{"authors":null,"date":1532649600,"description":"本文主要介绍了面向分布式服务架构的轻量级流量控制组件 Sentinel 以及在 Dubbo 中整合使用 Sentinel 的最佳实践。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Sentinel 为 Dubbo 服务保驾护航","lvl1":"blog","lvl2":"/zh/blog/2018/07/27/sentinel-%E4%B8%BA-dubbo-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/","lvl3":388,"lvl4":"blog","lvl5":null,"objectID":"99e01590eeed2113a9a3e5f17d38784b","permalink":"/zh/blog/2018/07/27/sentinel-%E4%B8%BA-dubbo-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/","publishdate":"2018-07-27T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/07/27/sentinel-%E4%B8%BA-dubbo-%E6%9C%8D%E5%8A%A1%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA/","summary":"在复杂的生产环境下可能部署着成千上万的 Dubbo 服务实例，流量持续不断地进入，服务之间进行相互调用。但是分布式系统中可能会因流量激增、系统负载过高、网络延迟等一系列问题，导致某些服务不可用，如果不进行相应的控制可能导致级联故障，影响服务的可用性，因此如何对流量进行合理的控制，成为保障服务稳定性的关键。\nSentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级流量控制产品，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。本文将基于 Dubbo，看看 Sentinel 是如何进行流量控制的，并且提供 Dubbo 整合 Sentinel 的最佳实践。\n快速接入 Sentinel Sentinel 意为哨兵，这个命名形象的诠释了 Sentinel 在分布式系统中的工作角色和重要性。以 Sentinel 在 Dubbo 生态系统中的作用为例，Dubbo 的核心模块包括注册中心、服务提供方、服务消费方（服务调用方）和监控四个模块。Sentinel 通过对服务提供方和服务消费方的限流来进一步提升服务的可用性。接下来我们看看 Sentinel 对服务提供方和服务消费方限流的技术实现方式。\nSentinel 提供了与 Dubbo 适配的模块 – Sentinel Dubbo Adapter，包括针对服务提供方的过滤器和服务消费方的过滤器（Filter）。使用时我们只需引入以下模块（以 Maven 为例）：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sentinel-dubbo-adapter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;x.y.z\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。同时提供了灵活的配置选项，例如若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可以手动关闭对应的 Filter。\n接入 Sentinel Dubbo Adapter 后，即使未配置规则，Sentinel 也会对相应的 Dubbo 服务的调用信息进行统计。那么我们怎么知道 Sentinel 接入成功了呢？这时候就要请出一大利器 —— Sentinel 控制台了。\n限流必备 - 监控管理 流量具有很强的实时性，之所以需要限流，是因为我们无法对流量的到来作出精确的预判，不然的话我们完全可以通过弹性的计算资源来处理，所以这时候为了保证限流的准确性，限流框架的监控功能就非常重要了。","text":null,"weight":0},{"authors":null,"date":1532217600,"description":"本文简单描述了2.7.x repackage后对老版本的兼容性实现方案。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 2.7.x repackage 后的兼容实现方案","lvl1":"blog","lvl2":"/zh/blog/2018/07/22/dubbo-2.7.x-repackage-%E5%90%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","lvl3":285,"lvl4":"blog","lvl5":null,"objectID":"41f05de08d76e8654ba99d57401fb234","permalink":"/zh/blog/2018/07/22/dubbo-2.7.x-repackage-%E5%90%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","publishdate":"2018-07-22T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/07/22/dubbo-2.7.x-repackage-%E5%90%8E%E7%9A%84%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","summary":"Dubbo至加入Apache孵化器以来，一个很强的诉求就是需要rename groupId和package name，这两项工作在项目毕业前需要完成。其中rename package相对来说复杂一些，除了要修改所有类的包名为org.apache.dubbo外，更多的是需要考虑如何老版本的兼容性。\n常见的兼容性包括但不限于以下几种情况：\n 用户API  编程API Spring注解   扩展SPI  扩展Filter    2.7.x里就是通过增加了一个新的模块dubbo-compatible来解决以上兼容性问题。\n编程使用API 编程使用API是最直接最原始的使用方式，其他方式诸如Spring schema、注解等方式都是基于原始API的；因此非常有必要对API编程形式进行兼容。\n所有编程相关API的兼容代码均在com.alibaba.dubbo.config包下，下面我们看看几个常见API的兼容实现。\nApplicationConfig package com.alibaba.dubbo.config; @Deprecated public class ApplicationConfig extends org.apache.dubbo.config.ApplicationConfig { public ApplicationConfig() { super(); } public ApplicationConfig(String name) { super(name); } } ProtocolConfig package com.alibaba.dubbo.config; @Deprecated public class ProtocolConfig extends org.apache.dubbo.config.ProtocolConfig { public ProtocolConfig() { } public ProtocolConfig(String name) { super(name); } public ProtocolConfig(String name, int port) { super(name, port); } } 可以看到：","text":null,"weight":0},{"authors":null,"date":1531353600,"description":"介绍Dubbo上下文信息的作用、应用场景、使用方式以及注意事项\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 上下文信息","lvl1":"blog","lvl2":"/zh/blog/2018/07/12/dubbo-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/","lvl3":156,"lvl4":"blog","lvl5":null,"objectID":"c1aff27ddd568d6bb0b1723d286b5ba7","permalink":"/zh/blog/2018/07/12/dubbo-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/","publishdate":"2018-07-12T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/07/12/dubbo-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/","summary":"简介 上下文信息是一次 RPC 调用过程中附带的环境信息，如方法名、参数类型、真实参数、本端/对端地址等。这些数据仅属于一次调用，作用于 Consumer 到 Provider 调用的整个流程。\n提供上下文信息是 RPC 框架很重要的一个功能，使用上下文不仅可以为单次调用指定不同配置，还能在此基础上提供强大的上层功能，如分布式链路追踪。其实现原理就是在上下文中维护一个span_id，Consumer 和 Provider 通过传递span_id来连接一次RPC调用，分别上报日志后可以在追踪系统中串联并展示完整的调用流程。这样可以更方便地发现异常，定位问题。\n使用说明 Dubbo中代表上下文的类是org.apache.dubbo.rpc.RpcContext，可通过下述代码来获取上下文信息。\nRpcContext.getContext() 使用场景 获取调用信息    方法名 用途 作用范围 说明     getRequest 获取 RPC 请求对象 Consumer 获取底层 RPC 请求对象，例如 HttpServletRequest，其他情况为 null   getResponse 获取 RPC 请求响应 Consumer 获取底层 RPC 响应对象，例如HttpServletResponse，其他情况为 null   isProviderSide 当前是否属于 Provider 上下文 Both 服务被调用时为 true，调用其他服务时为false   isConsumerSide 当前是否属于 Consumer 上下文 Both 服务被调用时为 false，调用其他服务时为 true   getUrls 获取当前能调用的 Url 列表 Both Consumer 端会根据不同的 Failover 策略实时变化   getRemotePort 获取远端端口 Both Consumer 端为最后一次调用的 Provider 端口，Provider 为当前请求的 Consumer 端口   getRemoteHost 获取远端主机地址 Both    getRemoteHostName 获取远端主机名 Both    getRemoteAddressString 获取远端地址 Both    getRemoteAddress 获取远端地址 Both    getLocalPort 获取本端端口 Both    getLocalHost 获取本端主机地址 Both    getLocalHostName 获取本端主机名 Both    getLocalAddressString 获取本端地址 Both    getLocalAddress 获取本端地址 Both     传递用户参数 本端传递 调用get和set方法即可完成参数传递。主要用于本端 Filter 之间的数据共享。","text":null,"weight":0},{"authors":null,"date":1531353600,"description":"This article introduces how to use Pinpoint to track Dubbo applications and monitor applications' performance.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Tracking with Pinpoint","lvl1":"blog","lvl2":"/blog/2018/07/12/tracking-with-pinpoint/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"a5730357e0afcdf52b9fe795d0807763","permalink":"/blog/2018/07/12/tracking-with-pinpoint/","publishdate":"2018-07-12T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/07/12/tracking-with-pinpoint/","summary":"","text":null,"weight":0},{"authors":null,"date":1531353600,"description":"本文介绍了利用Pinpoint对Dubbo分布式应用进行调用链跟踪与性能监控。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"使用Pinpoint做分布式跟踪","lvl1":"blog","lvl2":"/zh/blog/2018/07/12/%E4%BD%BF%E7%94%A8pinpoint%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","lvl3":560,"lvl4":"blog","lvl5":null,"objectID":"a5730357e0afcdf52b9fe795d0807763","permalink":"/zh/blog/2018/07/12/%E4%BD%BF%E7%94%A8pinpoint%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","publishdate":"2018-07-12T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/07/12/%E4%BD%BF%E7%94%A8pinpoint%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA/","summary":"在使用Dubbo进行服务化或者整合应用后，假设某个服务后台日志显示有异常，这个服务又被多个应用调用的情况下，我们通常很难判断是哪个应用调用的，问题的起因是什么，因此我们需要一套分布式跟踪系统来快速定位问题，Pinpoint可以帮助我们快速定位问题（当然，解决方案也不止这一种）。\n什么是Pinpoint  摘自Pinpoint学习笔记\n Pinpoint是一个开源的 APM (Application Performance Management/应用性能管理)工具，用于基于java的大规模分布式系统。 仿照Google Dapper，Pinpoint通过跟踪分布式应用之间的调用来提供解决方案，以帮助分析系统的总体结构和内部模块之间如何相互联系。\n 注：对于各个模块之间的通讯英文原文中用的是transaction一词，但是我觉得如果翻译为\u0026quot;事务\u0026quot;容易引起误解，所以替换为\u0026quot;交互\u0026quot;或者\u0026quot;调用\u0026quot;这种比较直白的字眼。\n 在使用上力图简单高效：\n 安装agent，不需要修改哪怕一行代码 最小化性能损失  服务器地图(ServerMap) 通过可视化分布式系统的模块和他们之间的相互联系来理解系统拓扑。点击某个节点会展示这个模块的详情，比如它当前的状态和请求数量。\n实时活动线程图表(Realtime Active Thread Chart) 实时监控应用内部的活动线程。\n请求/应答分布图表(Request/Response Scatter Chart) 长期可视化请求数量和应答模式来定位潜在问题。通过在图表上拉拽可以选择请求查看更多的详细信息。\n调用栈(CallStack) 在分布式环境中为每个调用生成代码级别的可视图，在单个视图中定位瓶颈和失败点。\n巡查(Inspector) 查看应用上的其他详细信息，比如CPU使用率，内存/垃圾回收，TPS，和JVM参数。\n支持模块  JDK 6+ Tomcat 6/7/8, Jetty 8/9, JBoss EAP 6, Resin 4, Websphere 6/7/8, Vertx 3.3/3.4/3.5 Spring, Spring Boot (Embedded Tomcat, Jetty) Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER ActiveMQ, RabbitMQ MySQL, Oracle, MSSQL, CUBRID,POSTGRESQL, MARIA Arcus, Memcached, Redis, CASSANDRA iBATIS, MyBatis DBCP, DBCP2, HIKARICP gson, Jackson, Json Lib log4j, Logback 自定义模块  Pinpoint与Dubbo的结合 启动Pinpoint 参考Pinpoint的Quick start搭建环境（不需要启动TestApp）","text":null,"weight":0},{"authors":null,"date":1530403200,"description":"This article will introduce you that how to implement a dubbo filter\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Your First Dubbo Filter","lvl1":"blog","lvl2":"/blog/2018/07/01/your-first-dubbo-filter/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"ab5b113420b8c465701fae1ce9441122","permalink":"/blog/2018/07/01/your-first-dubbo-filter/","publishdate":"2018-07-01T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/07/01/your-first-dubbo-filter/","summary":"","text":null,"weight":0},{"authors":null,"date":1530403200,"description":"本文介绍了如何开发一个 Dubbo 的 Filter\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第一个 Dubbo Filter","lvl1":"blog","lvl2":"/zh/blog/2018/07/01/%E7%AC%AC%E4%B8%80%E4%B8%AA-dubbo-filter/","lvl3":434,"lvl4":"blog","lvl5":null,"objectID":"ab5b113420b8c465701fae1ce9441122","permalink":"/zh/blog/2018/07/01/%E7%AC%AC%E4%B8%80%E4%B8%AA-dubbo-filter/","publishdate":"2018-07-01T00:00:00Z","readingtime":3,"relpermalink":"/zh/blog/2018/07/01/%E7%AC%AC%E4%B8%80%E4%B8%AA-dubbo-filter/","summary":"概述 在Dubbo的整体设计中，Filter是一个很重要的概念，包括Dubbo本身的大多数功能，都是基于此扩展点实现的，在每次的调用过程中，Filter的拦截都会被执行。\nDubbo Filter的加载机制 Dubbo中已经实现的Filter大概有二十几个，它们的入口都是ProtocolFilterWrapper，ProtocolFilterWrapper对Protocol做了Wrapper，会在加载扩展的时候被加载进来，下面我们来看下这个Filter链是如何构造的。\n//ProtocolFilterWrapper.java public \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; refer(Class\u0026lt;T\u0026gt; type, URL url) throws RpcException { if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) { return protocol.refer(type, url); } return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER); } private static \u0026lt;T\u0026gt; Invoker\u0026lt;T\u0026gt; buildInvokerChain(final Invoker\u0026lt;T\u0026gt; invoker, String key, String group) { Invoker\u0026lt;T\u0026gt; last = invoker; List\u0026lt;Filter\u0026gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group); if (filters.size() \u0026gt; 0) { for (int i = filters.size() - 1; i \u0026gt;= 0; i --) { final Filter filter = filters.","text":null,"weight":0},{"authors":null,"date":1529971200,"description":"回声测试用于检测服务是否可用\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"回声测试","lvl1":"blog","lvl2":"/zh/blog/2018/06/26/%E5%9B%9E%E5%A3%B0%E6%B5%8B%E8%AF%95/","lvl3":279,"lvl4":"blog","lvl5":null,"objectID":"9bae7fa6268cb6e6d0474cd6ea9442f1","permalink":"/zh/blog/2018/06/26/%E5%9B%9E%E5%A3%B0%E6%B5%8B%E8%AF%95/","publishdate":"2018-06-26T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/06/26/%E5%9B%9E%E5%A3%B0%E6%B5%8B%E8%AF%95/","summary":"回声测试用于检测服务是否可用。客户端通过 EchoService 来使用回声测试。EchoService 申明如下：\npublic interface EchoService { /** * echo test. * * @param message message. * @return message. */ Object $echo(Object message); } 用户通过 $echo 方法发起的请求，会按照正常请求的流程执行，能够测试整个调用是否通畅，监控系统可以使用回声测试来检测服务可用性。\n使用范例 所有服务引用自动实现 EchoService 接口，用户只需将服务引用强制转型为 EchoService，即可使用。配置和代码范例如下所示。 Spring 配置：\n\u0026lt;dubbo:reference id=\u0026#34;demoService\u0026#34; interface=\u0026#34;org.apache.dubbo.samples.echo.DemoService\u0026#34; /\u0026gt; 代码：\n// 远程服务引用 DemoService demoService= ctx.getBean(\u0026#34;demoService\u0026#34;); // 强制转型为EchoService EchoService echoService = (EchoService) demoService; // 回声测试可用性 String status = echoService.$echo(\u0026#34;OK\u0026#34;); assert(status.equals(\u0026#34;OK\u0026#34;)); 实现原理 我们在配置服务引用时，并没有配置 EchoService 这个接口，为什么可以直接把服务引用转型为 EchoService 呢？ 用户拿到的服务引用其实是一个 Proxy，Dubbo 在生成 Proxy 的时候，已经默认将 EchoService 这个接口加入到 Proxy 的接口列表中，所以用户拿到的 Proxy 都已经实现了 EchoService。生成代理相关代码如下：","text":null,"weight":0},{"authors":null,"date":1529712000,"description":"The second Dubbo Shanghai meetup has been held successfully.","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The second Dubbo Shanghai meetup has been held successfully","lvl1":"blog","lvl2":"/blog/2018/06/23/the-second-dubbo-shanghai-meetup-has-been-held-successfully/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"a1bdbfc012bedff916c2d70c5b05a55d","permalink":"/blog/2018/06/23/the-second-dubbo-shanghai-meetup-has-been-held-successfully/","publishdate":"2018-06-23T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/06/23/the-second-dubbo-shanghai-meetup-has-been-held-successfully/","summary":"","text":null,"weight":0},{"authors":null,"date":1529712000,"description":"第二届Dubbo开发者沙龙在上海成功举办。","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"第二届Dubbo开发者沙龙在上海成功举办","lvl1":"blog","lvl2":"/zh/blog/2018/06/23/%E7%AC%AC%E4%BA%8C%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E4%B8%8A%E6%B5%B7%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","lvl3":23,"lvl4":"blog","lvl5":null,"objectID":"a1bdbfc012bedff916c2d70c5b05a55d","permalink":"/zh/blog/2018/06/23/%E7%AC%AC%E4%BA%8C%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E4%B8%8A%E6%B5%B7%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","publishdate":"2018-06-23T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/06/23/%E7%AC%AC%E4%BA%8C%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E4%B8%8A%E6%B5%B7%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","summary":"第二届Dubbo开发者沙龙在上海成功举办，超过700位开发者报名，现场参与人数300+，通过阿里云天池、云栖社区、大咖说引导线上直播观看次数10000+\n分享嘉宾及PPT:\n 朱勇: Dubbo开源现状与未来规划 (中文) slides 小马哥: Dubbo Cloud Native 之路的实践与思考 (中文) slides 郭平: Nacos - 贡献Dubbo生态，阿里巴巴注册中心和配置中心开源计划 (中文) slides 潘志伟: Dubbo在互金行业的应用场景 (中文) slides  ","text":null,"weight":0},{"authors":null,"date":1529193600,"description":"本文介绍如何在 Dubbo 中使用 Zipkin 进行全链路追踪\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1500,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在 Dubbo 中使用 Zipkin","lvl1":"blog","lvl2":"/zh/blog/2018/06/17/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-zipkin/","lvl3":1449,"lvl4":"blog","lvl5":null,"objectID":"4f11dc9d1e5b6edafed17d02c4d68109","permalink":"/zh/blog/2018/06/17/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-zipkin/","publishdate":"2018-06-17T00:00:00Z","readingtime":7,"relpermalink":"/zh/blog/2018/06/17/%E5%9C%A8-dubbo-%E4%B8%AD%E4%BD%BF%E7%94%A8-zipkin/","summary":"随着业务的发展，应用的规模不断的扩大，传统的应用架构无法满足诉求，服务化架构改造势在必行，以 Dubbo 为代表的分布式服务框架成为了服务化改造架构中的基石。随着微服务理念逐渐被大众接受，应用进一步向更细粒度拆分，并且，不同的应用由不同的开发团队独立负责，整个分布式系统变得十分复杂。没有人能够清晰及时的知道当前系统整体的依赖关系。当出现问题时，也无法及时知道具体是链路上的哪个环节出了问题。\n在这个背景下，Google 发表了 Dapper 的论文，描述了如何通过一个分布式追踪系统解决上述问题。基于该论文，各大互联网公司实现并部署了自己的分布式追踪系统，其中比较出名的有阿里巴巴的 EagleEye。本文中提到的 Zipkin 是 Twitter 公司开源的分布式追踪系统。下面会详细介绍如何在 Dubbo 中使用 Zipkin 来实现分布式追踪。\nZipkin 简介 Zipkin 是基于 Dapper 论文实现，由 Twitter 开源的分布式追踪系统，通过收集分布式服务执行时间的信息来达到追踪服务调用链路、以及分析服务执行延迟等目的。\nZipkin 架构 Collector 收集器、Storage 存储、API、UI 用户界面等几部分构成了 Zipkin Server 部分，对应于 GitHub 上 openzipkin/zipkin 这个项目。而收集应用中调用的耗时信息并将其上报的组件与应用共生，并拥有各个语言的实现版本，其中 Java 的实现是 GitHub 上 openzipkin/brave。除了 Java 客户端实现之外，openzipkin 还提供了许多其他语言的实现，其中包括了 go、php、JavaScript、.net、ruby 等，具体列表可以参阅 Zipkin 的 Exiting instrumentations。\nZipkin 的工作过程 当用户发起一次调用时，Zipkin 的客户端会在入口处为整条调用链路生成一个全局唯一的 trace id，并为这条链路中的每一次分布式调用生成一个 span id。span 与 span 之间可以有父子嵌套关系，代表分布式调用中的上下游关系。span 和 span 之间可以是兄弟关系，代表当前调用下的两次子调用。一个 trace 由一组 span 组成，可以看成是由 trace 为根节点，span 为若干个子节点的一棵树。","text":null,"weight":0},{"authors":null,"date":1527984000,"description":"本文将会以 dubbo 项目为例向你阐释，给开源项目做贡献并不是一件难事\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"以 Dubbo 为例，聊聊如何向开源项目做贡献","lvl1":"blog","lvl2":"/zh/blog/2018/06/03/%E4%BB%A5-dubbo-%E4%B8%BA%E4%BE%8B%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE/","lvl3":330,"lvl4":"blog","lvl5":null,"objectID":"3d4ee92f128749b55e7577d470f866f9","permalink":"/zh/blog/2018/06/03/%E4%BB%A5-dubbo-%E4%B8%BA%E4%BE%8B%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE/","publishdate":"2018-06-03T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/06/03/%E4%BB%A5-dubbo-%E4%B8%BA%E4%BE%8B%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E5%90%91%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%81%9A%E8%B4%A1%E7%8C%AE/","summary":"Github 上有众多优秀的开源项目，大多数 IT 从业者将其当做了予取予求的工具库，遇到什么需求，先去 Github 搜一把，但有没有想过有一天自己也可以给开源事业做一些贡献呢？本文将会以 dubbo 项目为例，向你阐释，给开源项目做贡献并不是一件难事。\n1 为何要给开源贡献力量 为开源项目做贡献得到的收益是多方面的，为了让你有足够的信心加入到开源项目中，我在文章最开始列举出它的诸多好处。\n1.1 巩固技能 无论你是提交代码，撰写文档，提交 Issue，组织活动，当你切身参与到一个开源项目中，相关的技能都会得到历练，并且在开源项目中找到自己的位置。一方面，日常工作中我们中的大多数人接触到的是业务场景，并没有太多机会接触到基础架构组件，开源项目为我们提供了一个平台，在这里，你可以尽情挑选自己熟悉的项目为它添砖加瓦（以 Dubbo 为例，并不是所有 IT 公司都有能力自研服务治理框架）；另一方面，你所提交的代码，会有管理员协助审核，他们会给出专业的建议，更好的代码规范以及更优的编程思路最终都会变成你的经验。\n1.2 结交朋友 开源社区为你提供了一个平台，在这里，你可以认识很多纯粹的技术爱好者，开源贡献者是最符合 geek 定义的那群人，你所接触到的往往是某个领域最厉害的那批人。\n1.3 建立口碑 这是一个很好的展示个人实力的地方，俗话说：talk is cheap，show me the code. 作为技术人员，没有什么比一个漂亮的 Github 主页更有说服力的了。如果你能够为开源项目做出可观的贡献，你也将收获到业界的知名度，此时开源项目的成就和你是密不可分的。\n1.4 传承开源精神 只有源源不断的贡献者给开源项目添砖加瓦，才可以为 Github 一类的开源社区形成良好的开源风气。否则，只有输出没有输入，开源会失去活力。\n1.5 养成习惯 相信我，一旦养成了每天提交代码的习惯，就像你不想中断打卡一样，你绝不想中断 commit。不止有英语打卡，健身打卡，还有开源打卡！\n2 贡献代码时的一些疑难杂症 如果你是一名开源界的新手，可能会对贡献的流程心生畏惧。比如：我该怎么修改代码并提交？我的代码要是存在bug怎么办？我的代码别人会不会很 low？我该如何寻找合适的开源项目？开源社区那么多的工具和词汇都是什么意思？\n文章的第二部分将从一个小白的角度，介绍一下开源中的一些常见问题。\n2.1 git 常规操作 一般而言，我们选择使用 git 来作为版本管理的工具，你不一定要非常熟练的使用它，在我看来掌握 clone，add，commit，pull，push 即可，遇到复杂的场景，你还有谷歌。\nfork 与 clone\n如果你只是想下载源码，查看他的源码实现，使用 Clone or download 按钮即可。\n如果你想要给开源项目做改动，并且最终请求合并，让开源项目存在你贡献的代码，就应该使用 fork。\nfork 将会复制一份当前主分支的代码进入到你的仓库中，之后你所有的修改，应当基于自己的仓库进行，在功能开发/bug 修复之后，可以使用你的仓库向源仓库提交 pull request。只有源仓库的管理员才有权利合并你的请求。","text":null,"weight":0},{"authors":null,"date":1526860800,"description":"","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":1300,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 外部化配置","lvl1":"blog","lvl2":"/zh/blog/2018/05/21/dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/","lvl3":1264,"lvl4":"blog","lvl5":null,"objectID":"82a7a0b64fb5b3cfa4f7814ce3107668","permalink":"/zh/blog/2018/05/21/dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/","publishdate":"2018-05-21T00:00:00Z","readingtime":6,"relpermalink":"/zh/blog/2018/05/21/dubbo-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE/","summary":"Dubbo 外部化配置 外部化配置 在Dubbo 注解驱动例子中，无论是服务提供方，还是服务消费方，均需要转配相关配置Bean：\n@Bean public ApplicationConfig applicationConfig() { ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(\u0026#34;dubbo-annotation-consumer\u0026#34;); return applicationConfig; } 虽然实现类似于ProviderConfiguration 和 ConsumerConfiguration 这样的 Spring @Configuration Bean 成本并不高，不过通过 Java Code 的方式定义配置 Bean，或多或少是一种 Hard Code（硬编码）的行为，缺少弹性。\n尽管在 Spring 应用中，可以通过 @Value 或者 Environment 的方式获取外部配置，其代码简洁性以及类型转换灵活性存在明显的不足。因此，Spring Boot 提出了外部化配置（External Configuration）的感念，即通过程序以外的配置源，动态地绑定指定类型。\n随着 Spring Boot / Spring Cloud 应用的流行，开发人员逐渐地接受并且使用 Spring Boot 外部化配置（External Configuration），即通过 application.properties 或者 bootstrap.properties 装配配置 Bean。\n下列表格记录了 Dubbo 内置配置类：\n   配置类 标签 用途 解释     ProtocolConfig \u0026lt;dubbo:protocol/\u0026gt; 协议配置 用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受   ApplicationConfig \u0026lt;dubbo:application/\u0026gt; 应用配置 用于配置当前应用信息，不管该应用是提供者还是消费者   ModuleConfig \u0026lt;dubbo:module/\u0026gt; 模块配置 用于配置当前模块信息，可选   RegistryConfig \u0026lt;dubbo:registry/\u0026gt; 注册中心配置 用于配置连接注册中心相关信息   MonitorConfig \u0026lt;dubbo:monitor/\u0026gt; 监控中心配置 用于配置连接监控中心相关信息，可选   ProviderConfig \u0026lt;dubbo:provider/\u0026gt; 提供方配置 当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选   ConsumerConfig \u0026lt;dubbo:consumer/\u0026gt; 消费方配置 当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选   MethodConfig \u0026lt;dubbo:method/\u0026gt; 方法配置 用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息   ArgumentConfig \u0026lt;dubbo:argument/\u0026gt; 参数配置 用于指定方法参数配置    通过申明对应的 Spring 扩展标签，在 Spring 应用上下文中将自动生成相应的配置 Bean。","text":null,"weight":0},{"authors":null,"date":1526083200,"description":"The first Dubbo meetup has been held in Beijing.","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The first Dubbo meetup has been held in Beijing","lvl1":"blog","lvl2":"/blog/2018/05/12/the-first-dubbo-meetup-has-been-held-in-beijing/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"748a9c25ce71bd274db6dfec824bf78a","permalink":"/blog/2018/05/12/the-first-dubbo-meetup-has-been-held-in-beijing/","publishdate":"2018-05-12T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/05/12/the-first-dubbo-meetup-has-been-held-in-beijing/","summary":"","text":null,"weight":0},{"authors":null,"date":1526083200,"description":"首届Dubbo开发者沙龙在北京成功举办","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"首届Dubbo开发者沙龙在北京成功举办","lvl1":"blog","lvl2":"/zh/blog/2018/05/12/%E9%A6%96%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","lvl3":21,"lvl4":"blog","lvl5":null,"objectID":"748a9c25ce71bd274db6dfec824bf78a","permalink":"/zh/blog/2018/05/12/%E9%A6%96%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","publishdate":"2018-05-12T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/05/12/%E9%A6%96%E5%B1%8Adubbo%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99%E5%9C%A8%E5%8C%97%E4%BA%AC%E6%88%90%E5%8A%9F%E4%B8%BE%E5%8A%9E/","summary":"首届Dubbo开发者沙龙在北京成功举办, 超过400位开发者参加。这是一个很好的开始！\n分享嘉宾及主体如下：\n 罗毅: Dubbo 的现状现状与未来规划 PDF 刘军: 第四届阿里中间件性能挑战赛 PDF 陈志轩: 通过 Dubbo 和 Spring-boot 快速构建微服务 PDF 王欣: Dubbo 和微店的服务化实践历程分享 PDF  ","text":null,"weight":0},{"authors":null,"date":1525219200,"description":"This article will introduce you that the ApacheCon NA schedule has been announced attention.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The ApacheCon NA schedule has been announced","lvl1":"blog","lvl2":"/blog/2018/05/02/the-apachecon-na-schedule-has-been-announced/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"5b7c57f582906f44a617d35b1f495726","permalink":"/blog/2018/05/02/the-apachecon-na-schedule-has-been-announced/","publishdate":"2018-05-02T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/05/02/the-apachecon-na-schedule-has-been-announced/","summary":"","text":null,"weight":0},{"authors":null,"date":1525219200,"description":"本文将向你介绍在ApacheCon大会议程公布上相关Dubbo议题演讲。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"ApacheCon NA 大会议程公布","lvl1":"blog","lvl2":"/zh/blog/2018/05/02/apachecon-na-%E5%A4%A7%E4%BC%9A%E8%AE%AE%E7%A8%8B%E5%85%AC%E5%B8%83/","lvl3":12,"lvl4":"blog","lvl5":null,"objectID":"5b7c57f582906f44a617d35b1f495726","permalink":"/zh/blog/2018/05/02/apachecon-na-%E5%A4%A7%E4%BC%9A%E8%AE%AE%E7%A8%8B%E5%85%AC%E5%B8%83/","publishdate":"2018-05-02T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/05/02/apachecon-na-%E5%A4%A7%E4%BC%9A%E8%AE%AE%E7%A8%8B%E5%85%AC%E5%B8%83/","summary":"罗毅/刘军将在蒙特利尔举办的 ApacheCon 大会上进行题为\u0026quot;Introducing Apache Dubbo(Incubating): What is Dubbo and How it Works\u0026quot;的演讲。请点击此处查看大会议程，并在此处中进行注册。","text":null,"weight":0},{"authors":null,"date":1524614400,"description":"The GSoC(Google Summer of Code) 2018 projects has been announced\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"The GSoC(Google Summer of Code) 2018","lvl1":"blog","lvl2":"/blog/2018/04/25/the-gsocgoogle-summer-of-code-2018/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"54d29290e9bfd9313235804ae0b02b2d","permalink":"/blog/2018/04/25/the-gsocgoogle-summer-of-code-2018/","publishdate":"2018-04-25T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/04/25/the-gsocgoogle-summer-of-code-2018/","summary":"","text":null,"weight":0},{"authors":null,"date":1524614400,"description":"谷歌编程之夏会议上2018个项目被宣布，Dubbo位列其中。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"谷歌编程之夏会议上2018个项目被宣布","lvl1":"blog","lvl2":"/zh/blog/2018/04/25/%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%8F%E4%BC%9A%E8%AE%AE%E4%B8%8A2018%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%A2%AB%E5%AE%A3%E5%B8%83/","lvl3":8,"lvl4":"blog","lvl5":null,"objectID":"54d29290e9bfd9313235804ae0b02b2d","permalink":"/zh/blog/2018/04/25/%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%8F%E4%BC%9A%E8%AE%AE%E4%B8%8A2018%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%A2%AB%E5%AE%A3%E5%B8%83/","publishdate":"2018-04-25T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/04/25/%E8%B0%B7%E6%AD%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%8F%E4%BC%9A%E8%AE%AE%E4%B8%8A2018%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%A2%AB%E5%AE%A3%E5%B8%83/","summary":"谷歌编程之夏会议上2018个项目被宣布, Raghu Reddy 的项目\u0026quot;Apache Dubbo 扩展串行协议支持\u0026quot; 被接受! 祝贺他!","text":null,"weight":0},{"authors":null,"date":1524441600,"description":"本文将介绍如何在Dockerhub上发布Dubbo Admin镜像。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"在DockerHub发布Dubbo Admin镜像","lvl1":"blog","lvl2":"/zh/blog/2018/04/23/%E5%9C%A8dockerhub%E5%8F%91%E5%B8%83dubbo-admin%E9%95%9C%E5%83%8F/","lvl3":43,"lvl4":"blog","lvl5":null,"objectID":"f197aacb43d2cdc4e4c3de67733438b1","permalink":"/zh/blog/2018/04/23/%E5%9C%A8dockerhub%E5%8F%91%E5%B8%83dubbo-admin%E9%95%9C%E5%83%8F/","publishdate":"2018-04-23T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/04/23/%E5%9C%A8dockerhub%E5%8F%91%E5%B8%83dubbo-admin%E9%95%9C%E5%83%8F/","summary":"Dubbo Admin是Dubbo的服务治理中心，提供了大量日常运维所需的服务治理、配置管理等功能。\nDubbo Admin同时包含了前端代码和后端代码，如果用户需要自己下载源码并编译打包，需要花费一定时间。 特别是对于一些希望快速调研和试用Dubbo Admin的用户，这种流程的体验并不是很好。\nDocker是一个开源的应用容器引擎，让开发者可以打包应用以及依赖包到一个可移植的镜像中，社区对于提供Dubbo Admin镜像的呼声较高。 Docker官方维护了一个公共仓库DockerHub，该仓库还有很多国内镜像，访问速度快，将Dubbo Admin镜像发布到DockerHub是一个较好的选择。\nDockerHub账号申请 要在DockerHub上发布镜像，自然需要对应的账号。 而DockerHub有两种常见账号，一种是面向个人的，一种是面向组织的。Apache在DockerHub上有一个组织账号1。 自然我们首选是发布在组织账号下。\nDockerHub对于组织账号的管理是基于组的，也就是一个组织账号下有多个组，每个组有不同的成员，而一个组可以管理一个或者多个镜像。\n所以要做的第一步就是申请权限，这个需要提一个issue给Apache Infrastructure团队，申请DockerHub的镜像仓库和组权限。 目前镜像和组已经申请好了，只需要申请组的权限就行了，可以参考之前的申请2。\n申请完权限以后使用Apache账号登陆应该就可以看到对应的镜像和配置选项了。\n添加新的构建规则 发布镜像到DockerHub有两种办法，一种是本地构建好镜像以后远程push到DockerHub，另外一种是提供Dockerfile并借助DockerHub提供的构建功能直接在DockerHub构建。 后者明显操作性和便捷性要好很多，目前Dubbo Admin的镜像也是这样构建发布的。\n当Dubbo Admin有新版本发布以后，需要在项目的docker目录新增一个Dockerfile文件，可以参考目前0.1.0版本的Dockerfile3，其中的配置根据具体的版本可能有细微差别，但是大致上是一致的。\n在添加了Dockerfile之后，进入DockerHub对应的管理界面新增Build Rules\n根据实际情况填写即可。这里需要注意两点：\n latest 版本要和最新的版本配置一致 不要勾选Autobuild  勾选Autobuild会导致每次git提交都会触发自动构建，但是由于Dubbo Admin不提供snapshot的Docker镜像，所以只有发布新版本的时候才需要构建发布。\n修改以后点Save，然后手动触发构建即可。\n总结 总的来说DockerHub上发布镜像的步骤并不复杂，如果已经申请过权限的话，操作起来是很流畅的。\n另外DockerHub的构建是需要排队的，有时候会遇到长时间没有开始构建的情况，需要耐心等待。\n  https://hub.docker.com/r/apache \u0026#x21a9;\u0026#xfe0e;\n https://issues.apache.org/jira/browse/INFRA-18167 \u0026#x21a9;\u0026#xfe0e;\n https://github.com/apache/dubbo-admin/blob/develop/docker/0.1.0/Dockerfile \u0026#x21a9;\u0026#xfe0e;\n   ","text":null,"weight":0},{"authors":null,"date":1524355200,"description":"本文将向你介绍在QCon Beijing 2018上公布Dubbo路线图。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo路线图在QCon Beijing 2018上公布","lvl1":"blog","lvl2":"/zh/blog/2018/04/22/dubbo%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%9C%A8qcon-beijing-2018%E4%B8%8A%E5%85%AC%E5%B8%83/","lvl3":3,"lvl4":"blog","lvl5":null,"objectID":"7bddec71662d1b5cf9b62f702e34dea9","permalink":"/zh/blog/2018/04/22/dubbo%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%9C%A8qcon-beijing-2018%E4%B8%8A%E5%85%AC%E5%B8%83/","publishdate":"2018-04-22T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/04/22/dubbo%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%9C%A8qcon-beijing-2018%E4%B8%8A%E5%85%AC%E5%B8%83/","summary":"罗毅在Qcon Beijing 2018上进行了Dubbo开源现状及未来规划的主题演讲。详细内容请查看幻灯片。","text":null,"weight":0},{"authors":null,"date":1524355200,"description":"This article will introduce you that Dubbo roadmap is announced in QCon Beijing 2018.\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"page","lang":"en","lastmod":1611132661,"lvl0":"Dubbo roadmap is announced in QCon Beijing 2018","lvl1":"blog","lvl2":"/blog/2018/04/22/dubbo-roadmap-is-announced-in-qcon-beijing-2018/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"7bddec71662d1b5cf9b62f702e34dea9","permalink":"/blog/2018/04/22/dubbo-roadmap-is-announced-in-qcon-beijing-2018/","publishdate":"2018-04-22T00:00:00Z","readingtime":0,"relpermalink":"/blog/2018/04/22/dubbo-roadmap-is-announced-in-qcon-beijing-2018/","summary":"","text":null,"weight":0},{"authors":null,"date":1520726400,"description":"本文介绍了如何以Apache Way的方式参与Dubbo社区并做贡献\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"如何参与贡献Dubbo社区","lvl1":"blog","lvl2":"/zh/blog/2018/03/11/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AEdubbo%E7%A4%BE%E5%8C%BA/","lvl3":112,"lvl4":"blog","lvl5":null,"objectID":"fb950a066c904716053ad5d3ff5a618d","permalink":"/zh/blog/2018/03/11/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AEdubbo%E7%A4%BE%E5%8C%BA/","publishdate":"2018-03-11T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/2018/03/11/%E5%A6%82%E4%BD%95%E5%8F%82%E4%B8%8E%E8%B4%A1%E7%8C%AEdubbo%E7%A4%BE%E5%8C%BA/","summary":"前言 本文首次分享是在Apache Dubbo成都meetup上，这个话题是第一次在meetup上讲，不是我们没有更好的话题，相反，我们认为这个话题非常重要，甚至建议这个话题以后每次meetup都要讲。\nDubbo的发展历史大家应该并不陌生了，这里我还是简单回顾一下。Dubbo于2011年在github开源，后面几年由于一些原因停止了维护，直接去年7月份阿里重启维护，并于2018年2月16日捐献给Apache。\n为什么会选择捐献给Apache，主要是为了打消社区对Dubbo未来发展的顾虑，给Dubbo用户足够的信心；Apache认为社区大于代码，非常注重多样性，强调一个项目需要有多个公司和个人贡献者参与，现在Dubbo的发展完全是按The Apache Way社区化的方式来运作的。\nApache的诞生 说到Apache，大家都非常熟悉了，它是全球目前最大的软件基金；Apache的很多项目我们都用过，比如Maven、Log4j、Tomcat等，但有一个项目要特别强调的，那就是 Apache httpd server，这是Apache的第一个项目。\nApache软件基金会正式创建于1999年，主要是为公众提供有用的免费软件，并为软件开发者社区提供支持和服务；它的创建者是一个自称为Apache组织的群体；\n早在1995年，这个组织就存在了，他们聚集在一起，在美国伊利诺伊大学超级计算机应用程序国家中心开发的NCSA HTTPd服务器的基础上开发与维护了一个叫Apache的HTTP服务器。\n最早NCSA HTTPd服务器是一个叫Rob McCool的人开发的，但是后来慢慢失去了兴趣，导致这个功能强大又好用的服务器没人维护；于是一些爱好者和用户就自发开始维护起来，并不断改善功能、发布版本；为了更好进行沟通，一哥们就创建了一个邮件组，并把维护工作高效组织起来，且自称是Apache组织，并把这个软件叫Apache 服务器。\n这也是为什么Apache的所有的项目到今天为止依然以邮件列表作为沟通的主要方式。\n关于Apache的命名来源，从北美当地的一支叫Apache的印第安部落名称而来，这支部落以高超的军事素养和超人的忍耐力著称，19世纪后半期对侵占他们领土的入侵者进行了反抗；为了对这支部落表示敬仰，就取了这个名字；但这里还流传着一个小故事，说是在NCSA HTTPd基础上，大家都通过打补丁不断在修改这个软件，被戏称为A Patchy Server，和Apache Server读音很像。\n随着后来商业需求扩大，围绕Apache HTTP服务器的项目越来越多，后来越来越多的项目启动，也有很多外部组织捐献项目；为了让这些外部项目能顺利进入到Apache基金会，2002年创建了Incubator（孵化）项目。可以看到，经过10多年的发展，到2010年，75个顶级项目，30个孵化项目，每天2697封讨论邮件；2018年这个数据进一步增长，194个顶级项目，54个孵化项目，3255个committers；其中中国人主导的项目，有RocketMQ，WeeX，ECharts，Skywalking等。\nDubbo正在成为Apache顶级项目的路上——Apache孵化项目中。\n回顾一下Apache这些历史和数据，我们不难发现几个关键词：兴趣、参与、邮件；这些就是我们后面要重点介绍的The Apache Way。\nASF组织架构 我们知道每个组织都有它自己的架构，ASF同样也不例外；那Apache的组织架构是什么样的呢？它有什么独特的地方吗？这里特别要强调的是Project Management Committees，即 PMC，每个项目从孵化阶段开始就会有PMC，主要负责保证开源项目的社区活动都能运转良好，这里运转的机制就是The Apache Way。\n图中，Board就是负责整个基金会符合章程的运作。Board我们一般很少能接触到，接触更多的是PMC以及下面的这几层。\n参与Apache项目社区活动的人，一般分为以下几类：\n  直接用户：在座的都是Dubbo的用户，可能部分现在还不是，但将来肯定会是\n  贡献者：部分用户在使用Dubbo过程中，遇到问题，自己通过分析调试找到解决方案，并提交给Dubbo官方，最终被接受，这些用户就是Dubbo的贡献者\n  提交者：贡献多了，经过PMC的提议和投票，就会成为Committer；Committer即意味着正式加入Apache，拥有个人Apache帐号以及相应项目的写权限\n  PMC：Committer再往上走就是PMC，这个必须由现有PMC成员提名\n  个人在社区的成长，就像我们在公司晋升一样，一步一步往上走。\n本文的目的就是告诉大家，从User到Contributor没有大家想像的那么难，从Contributor到Committer也不是不可能；只要大家拥有一颗开源的心，找到自己感兴趣的项目，并持续投入，付出肯定会有回报。\nThe Apache Way 就像你加入一家公司需要了解这家公司的文化一样，参与Apache开源项目之前，同样我们需要需要了解ASF的文化，这个文化就称为The Apache Way。\n这里想特别强调以下几点：\n 社区胜于代码：把项目构建出来这不是开源，去构建社区才是真正的开源；对社区而言，一切都是围绕代码而生，无代码则社区不复存在；在代码之上，则是如何做事、如何待人、如何决策的理念体现；一个健康的社区远比优秀的代码重要——如果代码奇烂无比，社区可以重写，但社区有了毛病，代码最终也会付之东流； 公开透明与共识决策：If it doesn't happen on email, it doesn't happen.","text":null,"weight":0},{"authors":null,"date":1514764800,"description":"统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。\n","dir":"blog/news/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"Dubbo 博客文档中文排版指南","lvl1":"blog","lvl2":"/zh/blog/2018/01/01/dubbo-%E5%8D%9A%E5%AE%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/","lvl3":379,"lvl4":"blog","lvl5":null,"objectID":"b867acff5b7eef90e96c69e3cee81117","permalink":"/zh/blog/2018/01/01/dubbo-%E5%8D%9A%E5%AE%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/","publishdate":"2018-01-01T00:00:00Z","readingtime":2,"relpermalink":"/zh/blog/2018/01/01/dubbo-%E5%8D%9A%E5%AE%A2%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/","summary":"Dubbo 博客文档中文排版指南 [TOC]\n空格 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」—— vinta/paranoid-auto-spacing\n中英文之间需要增加空格 正确：\n 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n 错误：\n 在LeanCloud上，数据存储是围绕AVObject进行的。\n  在 LeanCloud上，数据存储是围绕AVObject 进行的。\n 完整的正确用法：\n 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n中文与数字之间需要增加空格 正确：\n 今天出去买菜花了 5000 元。\n 错误：\n 今天出去买菜花了 5000元。\n  今天出去买菜花了5000元。\n 数字与单位之间需要增加空格 正确：\n 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/impls/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/impls/page/","lvl3":57,"lvl4":"docs","lvl5":null,"objectID":"3f1e9b94883558dc5c5ac4c2c0337ed4","permalink":"/zh/docs/v2.7/dev/impls/page/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/impls/page/","summary":"页面扩展 扩展说明 对等网络节点组网器。\n扩展接口 org.apache.dubbo.container.page.PageHandler\n扩展配置 \u0026lt;dubbo:protocol page=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; \u0026lt;!-- 缺省值设置，当\u0026lt;dubbo:protocol\u0026gt;没有配置page属性时，使用此配置 --\u0026gt; \u0026lt;dubbo:provider page=\u0026#34;xxx,yyy\u0026#34; /\u0026gt; 已知扩展  org.apache.dubbo.container.page.pages.HomePageHandler org.apache.dubbo.container.page.pages.StatusPageHandler org.apache.dubbo.container.page.pages.LogPageHandler org.apache.dubbo.container.page.pages.SystemPageHandler  扩展示例 Maven 项目结构：\nsrc |-main |-java |-com |-xxx |-XxxPageHandler.java (实现PageHandler接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.container.page.PageHandler (纯文本文件，内容为：xxx=com.xxx.XxxPageHandler) XxxPageHandler.java：\npackage com.xxx; import org.apache.dubbo.container.page.PageHandler; public class XxxPageHandler implements PageHandler { public Group lookup(URL url) { // ...  } } META-INF/dubbo/org.apache.dubbo.container.page.PageHandler：\nxxx=com.xxx.XxxPageHandler ","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/dev/principals/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"","lvl1":"docs","lvl2":"/zh/docs/v2.7/dev/principals/introduction/","lvl3":4,"lvl4":"docs","lvl5":null,"objectID":"a802e590854f92c0045b54f27b783ae6","permalink":"/zh/docs/v2.7/dev/principals/introduction/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/dev/principals/introduction/","summary":"设计原则 本章节的设计原则摘录自梁飞在 javaeye 上发表的系列文章。","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/user/examples/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/examples/auth/","lvl3":20,"lvl4":"docs","lvl5":null,"objectID":"1a2186c0cc1f4a5759a1c165ffdf1f0b","permalink":"/zh/docs/v2.7/user/examples/auth/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/examples/auth/","summary":"服务鉴权 类似支付之类的对安全性敏感的业务可能会有限制匿名调用的需求。在加固安全性方面，2.7.5 引入了基于AK/SK机制的认证鉴权机制，并且引入了鉴权服务中心，主要原理是消费端在请求需要鉴权的服务时，会通过SK、请求元数据、时间戳、参数等信息来生成对应的请求签名，通过Dubbo的Attahcment机制携带到对端进行验签，验签通过才进行业务逻辑处理。如下图所示：\n具体的接入方式也并不复杂：\n  使用者需要在微服务站点上填写自己的应用信息，并为该应用生成唯一的证书凭证。\n  之后在管理站点上提交工单，申请某个敏感业务服务的使用权限，并由对应业务管理者进行审批，审批通过之后，会生成对应的AK/SK到鉴权服务中心。\n  导入该证书到对应的应用下，并且进行配置。配置方式也十分简单，以注解方式为例：\n服务提供端，只需要设置service.auth为true，表示该服务的调用需要鉴权认证通过。param.sign为true表示需要对参数也进行校验。\n@Service(parameters = {\u0026#34;service.auth\u0026#34;,\u0026#34;true\u0026#34;,\u0026#34;param.sign\u0026#34;,\u0026#34;true\u0026#34;}) public class AuthDemoServiceImpl implements AuthService { } 服务消费端，只需要配置好对应的证书等信息即可，之后会自动地在对这些需要认证的接口发起调用前进行签名操作，通过与鉴权服务的交互，用户无需在代码中配置AK/SK这些敏感信息，并且在不重启应用的情况下刷新AK/SK，达到权限动态下发的目的。\n  该方案目前已经提交给Dubbo开源社区，并且完成了基本框架的合并，除了AK/SK的鉴权方式之外，通过SPI机制支持用户可定制化的鉴权认证以及适配公司内部基础设施的密钥存储。","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"docs/v2.7/user/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1611132661,"lvl0":"","lvl1":"docs","lvl2":"/zh/docs/v2.7/user/new-features-in-a-glance/","lvl3":148,"lvl4":"docs","lvl5":null,"objectID":"cecbcf42e6c3bd62c769e9245e37728d","permalink":"/zh/docs/v2.7/user/new-features-in-a-glance/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/docs/v2.7/user/new-features-in-a-glance/","summary":"Dubbo 版本发布及新特性速览 版本速览 Dubbo 社区目前主力维护的有 2.6.x 和 2.7.x 两大版本，其中，\n 2.6.x 主要以 bugfix 和少量 enhancements 为主，因此能完全保证稳定性 2.7.x 作为社区的主要开发版本，得到持续更新并增加了大量新 feature 和优化，同时也带来了一些稳定性挑战  2.7.x 版本     版本 重要功能 升级建议     1 2.7.6 bugfix of 2.7.5\n服务鉴权 推荐生产使用   2 2.7.5 服务自省\nHTTP/2（gRPC） Protobuf TLS\n性能优化\nhttps://github.com/apache/dubbo/releases/tag/dubbo-2.7.5 不建议大规模生产使用   3 2.7.4.1 bugfixes and enhancements of 2.7.3 推荐生产使用   4 2.7.3 bigfixes of and enhancements of 2.","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"blog/","expirydate":-62135596800,"fuzzywordcount":0,"keywords":null,"kind":"section","lang":"en","lastmod":1611132661,"lvl0":"Nacos Blog","lvl1":"blog","lvl2":"/blog/","lvl3":0,"lvl4":"blog","lvl5":null,"objectID":"b0d8ccffb8d530bff08365a148a04ee6","permalink":"/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/blog/","summary":"","text":null,"weight":0},{"authors":null,"date":-62135596800,"description":"","dir":"blog/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1611132661,"lvl0":"Nacos 博客","lvl1":"blog","lvl2":"/zh/blog/","lvl3":23,"lvl4":"blog","lvl5":null,"objectID":"b0d8ccffb8d530bff08365a148a04ee6","permalink":"/zh/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/zh/blog/","summary":"This is the blog section. It has two categories: News and Releases.\nFiles in these directories will be listed in reverse chronological order.","text":null,"weight":0}]